{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>qcfinancial</code>","text":"<p>Librer\u00eda para la valorizaci\u00f3n de derivados de tasa de inter\u00e9s y tipo de cambio.</p>"},{"location":"#instalacion","title":"Instalaci\u00f3n","text":"<pre><code>pip install qcfinancial\n</code></pre> <p>La librer\u00eda est\u00e1 disponible para Windows 10, MacOS y Linux. Sin embargo, por favor considerar lo siguiente:</p> <ul> <li>Soporta Python desde la versi\u00f3n 3.8 en adelante.</li> <li>Se trata de una librer\u00eda cuyo core es C++ de la cual s\u00f3lo se distribuyen wheels.</li> <li>Para algunas plataformas y versiones de Python, dichos wheels podr\u00edan no estar disponibles.</li> <li>Si la instalaci\u00f3n presenta alg\u00fan error, levantar un issue aqu\u00ed mismo en GitHub, el cual trataremos de resolver lo antes posible.</li> </ul>"},{"location":"#documentacion","title":"Documentaci\u00f3n","text":"<p>La documentaci\u00f3n est\u00e1 escrita utilizando Jupyter notebooks. Para ejecutar dichos notebooks es posible clonar o descargar el Repo.</p>"},{"location":"1_Objetos_Fundamentales/","title":"Objetos Fundamentales","text":"<p>Para ejecutar todos los ejemplos se debe importar la librer\u00eda. Se sugiere utilizar siempre el alias <code>qcf</code>. </p> <pre><code>import qcfinancial as qcf\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#monedas","title":"Monedas","text":"<p>Las divisas se representan con objetos de tipo <code>QCCurrency</code> y sus subclases. En estos momentos, de forma expl\u00edcita, est\u00e1n implementadas las siguientes divisas:</p> <pre><code>for fx in qcf.QCCurrencyEnum.__dict__['__entries']:\n    print(fx)\n</code></pre> <pre><code>AUD\nBRL\nCAD\nCHF\nCLF\nCL2\nCLP\nCNY\nCOP\nDKK\nEUR\nGBP\nHKD\nJPY\nMXN\nNOK\nPEN\nSEK\nUSD\n</code></pre> <p>Si se requiere otra, solicitarlo ingresando un issue en el git repo del proyecto.</p> <p>Nota: La divisa <code>CL2</code> corresponde a CLF, pero usando solamente dos decimales.</p> <p>El constructor por default retorna USD.</p> <pre><code>x = qcf.QCCurrency()\nprint(f\"ISO Code: {x.get_iso_code()}\")\n</code></pre> <pre><code>ISO Code: USD\n</code></pre> <p>Alta de divisas CLP, USD y JPY (USD se puede instanciar tambi\u00e9n de forma expl\u00edcita).</p> <pre><code>monedas = [\n    clp:=qcf.QCCLP(),\n    usd:=qcf.QCUSD(),\n    jpy:=qcf.QCJPY(),\n]\n</code></pre> <p>Sin usar las subclases se puede instanciar una divisa que no est\u00e9 implementada, por ejemplo para el peso argentino ARS:</p> <pre><code>ars = qcf.QCCurrency('Peso argentino', 'ARS', 32, 0)\nmonedas.append(ars)\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodos-get_name-get_iso_code-get_iso_number-get_decimal_places-y-amount","title":"M\u00e9todos: <code>get_name</code>, <code>get_iso_code</code>, <code>get_iso_number</code>, <code>get_decimal_places</code> y <code>amount</code>.","text":"<p>El m\u00e9todo <code>amount</code>debe utilizarse cuando se debe pagar o recibir un monto resultado de un c\u00e1lculo. De esta forma, el monto se redondea al n\u00famero correcto de decimales en la divisa (que se obtiene con <code>get_decimal_places</code>). Por ejemplo, en CLP, se redondea a 0 decimales ya que en esta divisa no se utilizan los centavos.</p> <pre><code>cantidad = 100.123456\nfor moneda in monedas:\n    print(f\"Nombre: {format(moneda.get_name())}\")\n    print(f\"C\u00f3digo ISO: {moneda.get_iso_code()}\")\n    print(f\"N\u00famero ISO: {moneda.get_iso_number()}\")\n    print(f\"N\u00famero de decimales: {moneda.get_decimal_places()}\")\n    print(f\"Cantidad {cantidad} con el n\u00famero correcto de decimales: {moneda.amount(cantidad):.4f}\")\n    print()\n</code></pre> <pre><code>Nombre: Chilean Peso\nC\u00f3digo ISO: CLP\nN\u00famero ISO: 152\nN\u00famero de decimales: 0\nCantidad 100.123456 con el n\u00famero correcto de decimales: 100.0000\n\nNombre: U. S. Dollar\nC\u00f3digo ISO: USD\nN\u00famero ISO: 840\nN\u00famero de decimales: 2\nCantidad 100.123456 con el n\u00famero correcto de decimales: 100.1200\n\nNombre: Japanese Yen\nC\u00f3digo ISO: JPY\nN\u00famero ISO: 392\nN\u00famero de decimales: 2\nCantidad 100.123456 con el n\u00famero correcto de decimales: 100.1200\n\nNombre: Peso argentino\nC\u00f3digo ISO: ARS\nN\u00famero ISO: 32\nN\u00famero de decimales: 0\nCantidad 100.123456 con el n\u00famero correcto de decimales: 100.0000\n</code></pre> <p>M\u00e1s adelante, cuando veamos el concepto de \u00edndice, veremos como disponer de un objeto moneda simplifica la conversi\u00f3n de montos de una moneda a otra.</p>"},{"location":"1_Objetos_Fundamentales/#fechas","title":"Fechas","text":"<p>Las fechas se representan con objetos de tipo <code>QCDate</code>. Para inicializar un <code>QCDate</code> se requiere el d\u00eda, el mes y el a\u00f1o de la fecha. Tambi\u00e9n se puede inicializar sin valor (default constructor) en cuyo caso se obtendr\u00e1 el 12-01-1969.</p>"},{"location":"1_Objetos_Fundamentales/#constructores","title":"Constructores","text":"<p>Inicializar sin valor.</p> <pre><code>fecha = qcf.QCDate()\nprint(f\"Fecha: {fecha}\")\n</code></pre> <pre><code>Fecha: 1969-01-12\n</code></pre> <p>Inicializar con una fecha espec\u00edfica. En este caso, el contructor realiza una validaci\u00f3n de los par\u00e1metros iniciales.</p> <pre><code>fecha1 = qcf.QCDate(14, 9, 2024)  # d\u00eda, mes, a\u00f1o\nprint(f\"Fecha: {fecha1}\")\n</code></pre> <pre><code>Fecha: 2024-09-14\n</code></pre> <p>Error al tratar de construir una fecha inv\u00e1lida.</p> <pre><code>try:\n    fecha0 = qcf.QCDate(31, 2, 2024)  # \u00a1\u00a1\u00a1 31 de febrero !!!\nexcept ValueError as e:\n    print(e)\n</code></pre> <pre><code>Invalid day for month = 2\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodos-description-iso_code-y-__str__","title":"M\u00e9todos <code>description</code>, <code>iso_code</code> y <code>__str__</code>","text":"<pre><code>print(f\"description(True): {fecha.description(True)}\")\nprint(f\"description(False): {fecha.description(False)}\")\nprint(f\"iso_code(): {fecha.iso_code()}\")\nprint(f\"__str__: {fecha}\")\n</code></pre> <pre><code>description(True): 12-01-1969\ndescription(False): 1969-01-12\niso_code(): 1969-01-12\n__str__: 1969-01-12\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#getters-y-setters","title":"Getters y Setters","text":"<p>M\u00e9todos: <code>set_day</code>, <code>set_month</code> y <code>set_year</code>.</p> <pre><code>fecha1.set_day(17)\nfecha1.set_month(10)\nfecha1.set_year(2024)\nprint(f\"Fecha: {fecha1}\")\n</code></pre> <pre><code>Fecha: 2024-10-17\n</code></pre> <p>M\u00e9todos <code>day</code>, <code>month</code> y <code>year</code>.</p> <pre><code>print(f\"D\u00eda: {fecha1.day()}\")\nprint(f\"Mes: {fecha1.month()}\")\nprint(f\"A\u00f1o: {fecha1.year()}\")\n</code></pre> <pre><code>D\u00eda: 17\nMes: 10\nA\u00f1o: 2024\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-week_day","title":"M\u00e9todo <code>week_day</code>","text":"<p>Retorna una variable de tipo <code>enum QC_Financial.WeekDay</code> que representa el d\u00eda de la semana al que corresponde a la fecha.</p> <pre><code>dia_semana = fecha1.week_day()\nprint(f\"Tipo del retorno: {type(dia_semana)}\")\nprint(f\"D\u00eda de la semana: {dia_semana}\")\n</code></pre> <pre><code>Tipo del retorno: &lt;class 'qcfinancial.WeekDay'&gt;\nD\u00eda de la semana: WeekDay.THU\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-add_months","title":"M\u00e9todo <code>add_months</code>","text":"<p>Suma n meses a <code>fecha1</code> y retorna esa nueva fecha sin cambiar el valor de <code>fecha1</code>.</p> <pre><code>num_meses = 12\nfecha2 = fecha1.add_months(num_meses)\nprint(f\"fecha1: {fecha1}\")\nprint(f\"fecha2: {fecha2}\")\n</code></pre> <pre><code>fecha1: 2024-10-17\nfecha2: 2025-10-17\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-add_days","title":"M\u00e9todo <code>add_days</code>","text":"<p>Suma n d\u00edas a <code>fecha1</code> sin cambiar el valor de <code>fecha1</code>.</p> <pre><code>num_dias = 30\nfecha3 = fecha1.add_days(num_dias)\nprint(f\"fecha1: {fecha1}\")\nprint(f\"fecha3: {fecha3}\")\n</code></pre> <pre><code>fecha1: 2024-10-17\nfecha3: 2024-11-16\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-day_diff","title":"M\u00e9todo <code>day_diff</code>","text":"<p>Calcula la diferencia en d\u00edas con otra fecha. Si la otra fecha es mayor el resultado es positivo, si no, es negativo.</p> <pre><code># Dado que fecha3 &gt; fecha1 entonces el resultado es positivo\nprint(f\"fecha1.day_diff(fecha3): {fecha1.day_diff(fecha3)} (d\u00edas)\")\n\n# Se invierten los roles y el resultado es negativo\nprint(f\"fecha3.day_diff(fecha1): {fecha3.day_diff(fecha1)} (d\u00edas)\")\n</code></pre> <pre><code>fecha1.day_diff(fecha3): 30 (d\u00edas)\nfecha3.day_diff(fecha1): -30 (d\u00edas)\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#orden-en-qcdate","title":"Orden en <code>QCDate</code>","text":"<p>El orden de <code>QCDate</code> permite que las fechas pueden compararse entre si.</p> <pre><code>print(f\"fecha1: {fecha1}\")\nprint(f\"fecha2: {fecha2}\")\nprint(f\"fecha1 == fecha2: {fecha1 == fecha2}\")\nprint(f\"fecha1 != fecha2: {fecha1 != fecha2}\")\nprint(f\"fecha1 &lt; fecha2: {fecha1 &lt; fecha2}\")\nprint(f\"fecha1 &lt;= fecha2: {fecha1 &lt;= fecha2}\")\nprint(f\"fecha1 &gt; fecha2: {fecha1 &gt; fecha2}\")\nprint(f\"fecha1 &gt;= fecha2: {fecha1 &gt;= fecha2}\")\n</code></pre> <pre><code>fecha1: 2024-10-17\nfecha2: 2025-10-17\nfecha1 == fecha2: False\nfecha1 != fecha2: True\nfecha1 &lt; fecha2: True\nfecha1 &lt;= fecha2: True\nfecha1 &gt; fecha2: False\nfecha1 &gt;= fecha2: False\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#un-objeto-qcdate-es-hashable","title":"Un objeto <code>QCDate</code> es hashable","text":"<p>Esto permite que las fechas puedan usarse como <code>key</code> en un <code>dict</code>de Python. El hash que se utiliza coincide con la representaci\u00f3n como entero de una fecha que se utiliza en Excel.</p> <pre><code>print(fecha1.__hash__())\n</code></pre> <pre><code>45582\n</code></pre> <p>Por ejemplo, una serie de tiempo:</p> <pre><code>serie_de_tiempo = {\n    qcf.QCDate(22, 5, 2024): 100.01,\n    qcf.QCDate(23, 5, 2024): 100.02,\n    qcf.QCDate(24, 5, 2024): 100.03,\n}\nprint(f\"Valor al: {qcf.QCDate(23, 5, 2024)} es {serie_de_tiempo[qcf.QCDate(23, 5, 2024)]}\")\n</code></pre> <pre><code>Valor al: 2024-05-23 es 100.02\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-build_qcdate_from_string","title":"M\u00e9todo <code>build_qcdate_from_string</code>","text":"<p>Se trata de un factory method que permite inicializar un objeto <code>QCDate</code> a partir de un <code>string</code>. El formato del <code>string</code> debe ser yyyy&amp;mm&amp;dd donde &amp; es un separador arbitrario.</p> <pre><code>str1 = \"2020-01-01\"\nstr2 = \"2020/01/02\"\nstr3 = \"2020&amp;01&amp;03\"\n\nfecha4 = qcf.build_qcdate_from_string(str1)\nprint(f\"{str1}: {fecha4}\")\n\nfecha4 = qcf.build_qcdate_from_string(str2)\nprint(f\"{str2}: {fecha4}\")\n\nfecha4 = qcf.build_qcdate_from_string(str3)\nprint(f\"{str3}: {fecha4}\")\n</code></pre> <pre><code>2020-01-01: 2020-01-01\n2020/01/02: 2020-01-02\n2020&amp;01&amp;03: 2020-01-03\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#calendarios","title":"Calendarios","text":"<p>Para construir correctamente la tabla de desarrollo de un bono o de las patas de un swap, es necesario conocer los calendarios que se debe aplicar en cada caso. </p> <p>S\u00f3lo as\u00ed es posible determinar qu\u00e9 fechas de pago, de inicio y fin de devengo y otras son admisibles.</p> <p>Los calendarios se representan con objetos de tipo <code>BusinesssCalendar</code> y son listas de fechas arbitrarias que representan d\u00edas feriados en alguna ciudad, pa\u00eds, regi\u00f3n o uni\u00f3n de las anteriores. </p> <p>Para dar de alta un calendario se requiere:</p> <ul> <li>una fecha inicial (<code>QCDate</code>)</li> <li>y un n\u00famero entero positivo que representa el plazo inicial total del calendario en a\u00f1os.</li> </ul> <p>El objeto <code>BusinessCalendar</code> incluye expl\u00edcitamente todos los d\u00edas 1 de enero y considera siempre como feriado los d\u00edas s\u00e1bado y domingo (aunque no pertenecen de forma expl\u00edcita a la lista).</p> <p>En el siguiente loop, por ejemplo, no se imprime nada.</p> <pre><code>fecha_inicio_calendario = qcf.QCDate(1, 1, 2024)\nscl = qcf.BusinessCalendar(fecha1, 10)\n</code></pre> <pre><code>for holiday in scl.get_holidays():\n    print(holiday)\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-add_holiday","title":"M\u00e9todo <code>add_holiday</code>","text":"<p>Agrega una fecha a la lista.</p> <pre><code>scl.add_holiday(qcf.QCDate(18, 9, 2024))\n</code></pre> <pre><code>for holiday in scl.get_holidays():\n    print(holiday)\n</code></pre> <pre><code>2024-09-18\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-next_busy_day","title":"M\u00e9todo <code>next_busy_day</code>","text":"<p>Dada una fecha, si \u00e9sta es h\u00e1bil retorna la misma fecha, si, por el contrario, la fecha es inh\u00e1bil, devuelve la siguiente fecha h\u00e1bil del calendario.</p> <p>Veamos qu\u00e9 ocurre si aplicamos este m\u00e9todo al 18-09-2024, fecha que acabamos de incluir.</p> <pre><code>print(f\"Next para el {(sept18 := qcf.QCDate(18, 9, 2024))}: {scl.next_busy_day(sept18)}\")\n</code></pre> <pre><code>Next para el 2024-09-18: 2024-09-19\n</code></pre> <p>Agregamos ahora el 19-09-2024 y vemos el nuevo resultado.</p> <pre><code>print(\"Se agrega el 19-9-2024 a la lista\")\nscl.add_holiday(qcf.QCDate(19, 9, 2024))\nnext = scl.next_busy_day(qcf.QCDate(18, 9, 2024))\nprint(f\"Nuevo next para el {sept18}: {next.week_day()}, {next}\")\n</code></pre> <pre><code>Se agrega el 19-9-2024 a la lista\nNuevo next para el 2024-09-18: WeekDay.FRI, 2024-09-20\n</code></pre> <p>Pero el 2024, el 20 de septiembre tambi\u00e9n es feriado. Incluy\u00e1moslo y veamos el efecto.</p> <pre><code>print(\"Se agrega el 20-9-2024 a la lista\")\nscl.add_holiday(qcf.QCDate(20, 9, 2024))\nnext = scl.next_busy_day(qcf.QCDate(18, 9, 2024))\nprint(f\"Nuevo next para el {sept18}: {next.week_day()}, {next}\")\n</code></pre> <pre><code>Se agrega el 20-9-2024 a la lista\nNuevo next para el 2024-09-18: WeekDay.MON, 2024-09-23\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-mod_next_busy_day","title":"M\u00e9todo <code>mod_next_busy_day</code>","text":"<p>Opera igual que la funci\u00f3n anterior a menos que \u00e9sta retorne una fecha del mes siguiente, en ese caso retorna la fecha h\u00e1bil anterior.</p> <p>Probemos el comportamiento usando el 30-04-2024.</p> <pre><code>abril30 = qcf.QCDate(30, 4, 2024)\nprint(f\"Abril 30: {abril30.week_day()}, {abril30}\")\n</code></pre> <pre><code>Abril 30: WeekDay.TUE, 2024-04-30\n</code></pre> <p>Vemos que es un martes y no es feriado, por lo tanto al aplicar <code>next_busy_day</code> no hay cambio de fecha:</p> <pre><code>print(f\"Next para el {abril30}: {scl.next_busy_day(abril30)}\")\n</code></pre> <pre><code>Next para el 2024-04-30: 2024-04-30\n</code></pre> <p>Ahora, si lo agregamos al calendario, s\u00ed se produce el cambio de fecha.</p> <pre><code>scl.add_holiday(abril30)\nprint(f\"Next para el {abril30}: {scl.next_busy_day(abril30)}\")\n</code></pre> <pre><code>Next para el 2024-04-30: 2024-05-01\n</code></pre> <p>Y vemos adem\u00e1s que nos cambiamos de mes, pero si aplicamos <code>mod_next_busy_day</code> vemos que el resultado es el d\u00eda h\u00e1bil anterior.</p> <pre><code>print(f\"Mod next para el {abril30}: {scl.mod_next_busy_day(abril30)}\")\n</code></pre> <pre><code>Mod next para el 2024-04-30: 2024-04-29\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-prev_busy_day","title":"M\u00e9todo <code>prev_busy_day</code>","text":"<p>Opera de forma an\u00e1loga a <code>busy_day</code>, pero retornando la fecha h\u00e1bil anterior.</p> <pre><code>print(\"prev:\", scl.prev_busy_day(abril30))\n</code></pre> <pre><code>prev: 2024-04-29\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-shift","title":"M\u00e9todo <code>shift</code>","text":"<p>Suma un n\u00famero n (positivo o negativo) de d\u00edas h\u00e1biles a una fecha.</p> <p>Veamos algunos ejemplos.</p> <pre><code>print(f\"Fecha inicial: {abril30}\")\nshifted = scl.shift(abril30, 0)\nprint(f\"n = 0, {shifted.week_day()}, {shifted}\")\n\nshifted = scl.shift(abril30, 1)\nprint(f\"n = 1, {shifted.week_day()}, {shifted}\")\n\nshifted = scl.shift(abril30, 5)\nprint(f\"n = 5, {shifted.week_day()}, {shifted}\")\n</code></pre> <pre><code>Fecha inicial: 2024-04-30\nn = 0, WeekDay.TUE, 2024-04-30\nn = 1, WeekDay.WED, 2024-05-01\nn = 5, WeekDay.TUE, 2024-05-07\n</code></pre> <p>Veamos en particular qu\u00e9 ocurre cuando usamos un n\u00famero negativo.</p> <pre><code>mayo2 = qcf.QCDate(2, 5, 2024)\nprint(f\"n = -1: {scl.shift(mayo2, -1)}\")\n</code></pre> <pre><code>n = -1: 2024-05-01\n</code></pre> <p>Agreguemos el 2024-05-01 a los feriados de <code>scl</code> y veamos c\u00f3mo cambia el primer resultado.</p> <pre><code>scl.add_holiday(qcf.QCDate(1, 5, 2024))\nprint(f\"n = -1: {scl.shift(mayo2, -1)}\")\n</code></pre> <pre><code>n = -1: 2024-04-29\n</code></pre> <p>Se va al 29 de abril porque tambi\u00e9n agregamos como feriado el 30 de abril.</p>"},{"location":"1_Objetos_Fundamentales/#integracion-con-holidays","title":"Integraci\u00f3n con <code>holidays</code>","text":"<p><code>holidays</code> es una muy buena librer\u00eda en Python puro que provee los feriados de m\u00e1s de 100 pa\u00edses, ciudades y mercados. Cuando no se est\u00e1 conectado a una BBDD y se quiere dar de alta un calendario, integrar <code>holidays</code> con <code>qcf.BusinessCalendar</code> es una muy buena opci\u00f3n.</p> <p>En el siguiente ejemplo, se construye el calendario de Santiago.</p> <pre><code>import holidays as hol\n</code></pre> <pre><code>scl = us_holidays = hol.CL(years=range(2024, 2045))\n</code></pre> <p>Vemos que <code>scl</code> es un objeto similar a un Python <code>dict</code>.</p> <pre><code>for i, d in enumerate(scl.items()):\n    if i &lt; 10:\n        print(d[0], d[1])\n</code></pre> <pre><code>2024-01-01 New Year's Day\n2024-03-29 Good Friday\n2024-03-30 Holy Saturday\n2024-05-01 Labor Day\n2024-05-21 Navy Day\n2024-06-20 National Day of Indigenous Peoples\n2024-06-29 Saint Peter and Saint Paul's Day\n2024-07-16 Our Lady of Mount Carmel\n2024-08-15 Assumption Day\n2024-09-18 Independence Day\n</code></pre> <p>Damos de alta un objeto de tipo <code>qcf.BusinessCalendar</code>.</p> <pre><code>qcf_scl = qcf.BusinessCalendar(qcf.QCDate(1, 2, 2024), 20)\n</code></pre> <p>Y luego lo poblamos con las fechas de <code>scl</code>.</p> <pre><code>for d in scl.keys():\n    qcf_scl.add_holiday(qcf.QCDate(d.isoformat()))\n</code></pre> <p>Este procedimiento puede encapsularse f\u00e1cilmente en una funci\u00f3n, de hecho, la agregaremos al m\u00f3dulo <code>aux_functions</code> para seguir utiliz\u00e1ndola m\u00e1s adelante.</p> <pre><code>def get_business_calendar(which_holidays: str, years: range) -&gt; qcf.BusinessCalendar:\n    py_cal = hol.country_holidays(which_holidays, years=years)\n    yrs = [y for y in years]\n    qcf_cal = qcf.BusinessCalendar(qcf.QCDate(1, 1, yrs[0]), yrs[-1] - yrs[0])\n    for d in py_cal.keys():\n        qcf_cal.add_holiday(qcf.QCDate(d.isoformat()))\n    return qcf_cal\n</code></pre> <p>Ejemplo:</p> <pre><code>ny = get_business_calendar('US', range(2024, 2045))\n</code></pre> <pre><code>for i, d in enumerate(ny.get_holidays()):\n    if i &lt; 10:\n        print(d)\n</code></pre> <pre><code>2024-01-01\n2024-01-15\n2024-02-19\n2024-05-27\n2024-06-19\n2024-07-04\n2024-09-02\n2024-10-14\n2024-11-11\n2024-11-28\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#fracciones-de-ano","title":"Fracciones de A\u00f1o","text":"<p>Las fracciones de a\u00f1o corresponden a las distintas formas de medir un intervalo de tiempo entre dos fechas que com\u00fanmente se utiliza en los productos de tasa de inter\u00e9s.</p> <p>En <code>qcfinancial</code> est\u00e1n definidas las m\u00e1s utilizadas.</p> <pre><code>yfs = [\n    act360 := qcf.QCAct360(),\n    act365 := qcf.QCAct365(),\n    act30 := qcf.QCAct30(),\n    t30360 := qcf.QC30360(),\n    t3030 := qcf.QC3030(),\n\n    # Corresponde a dep\u00f3sitos a plazo en CLP\n    act30 := qcf.QCAct30(),\n\n    # La utilizan los bonos del tesoro americano\n    actact := qcf.QCActAct(),\n]\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodos-yf-y-count_days","title":"M\u00e9todos <code>yf</code> y <code>count_days</code>","text":"<p>El m\u00e9todo <code>yf</code>, que retorna el valor de la fracci\u00f3n de a\u00f1o, est\u00e1 sobrecargado, se puede calcular usando como argumentos un n\u00famero de d\u00edas o un par de fechas (<code>QCDate</code>).</p> <pre><code>print(f\"\\nfecha1: {fecha1} y fecha3: {fecha3}\")\nprint(\"---------------------------------------\\n\")\nfor yf in yfs:\n    print(type(yf))\n    print(f\"yf(30): {yf.yf(30):.6f}\")\n    print(f\"yf.yf(fecha1, fecha3): {yf.yf(fecha1, fecha3):.6f}\")\n    print(f\"yf.yf.count_days(fecha1, fecha3): {yf.count_days(fecha1, fecha3):.0f}\")\n    print()\n</code></pre> <pre><code>fecha1: 2024-10-17 y fecha3: 2024-11-16\n---------------------------------------\n\n&lt;class 'qcfinancial.QCAct360'&gt;\nyf(30): 0.083333\nyf.yf(fecha1, fecha3): 0.083333\nyf.yf.count_days(fecha1, fecha3): 30\n\n&lt;class 'qcfinancial.QCAct365'&gt;\nyf(30): 0.082192\nyf.yf(fecha1, fecha3): 0.082192\nyf.yf.count_days(fecha1, fecha3): 30\n\n&lt;class 'qcfinancial.QCAct30'&gt;\nyf(30): 1.000000\nyf.yf(fecha1, fecha3): 1.000000\nyf.yf.count_days(fecha1, fecha3): 30\n\n&lt;class 'qcfinancial.QC30360'&gt;\nyf(30): 0.083333\nyf.yf(fecha1, fecha3): 0.080556\nyf.yf.count_days(fecha1, fecha3): 29\n\n&lt;class 'qcfinancial.QC3030'&gt;\nyf(30): 1.000000\nyf.yf(fecha1, fecha3): 0.966667\nyf.yf.count_days(fecha1, fecha3): 29\n\n&lt;class 'qcfinancial.QCAct30'&gt;\nyf(30): 1.000000\nyf.yf(fecha1, fecha3): 1.000000\nyf.yf.count_days(fecha1, fecha3): 30\n\n&lt;class 'qcfinancial.QCActAct'&gt;\nyf(30): 0.082192\nyf.yf(fecha1, fecha3): 0.082192\nyf.yf.count_days(fecha1, fecha3): 30\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#funciones-y-factores-de-capitalizacion","title":"Funciones y Factores de Capitalizaci\u00f3n","text":"<p>Las funciones de capitalizaci\u00f3n representan las distintas formas en que se puede usar el valor de una tasa de inter\u00e9s para calcular o traer a valor presente un flujo de caja futuro. Al resultado de la funci\u00f3n de capitalizaci\u00f3n lo llamamos factor de capitalizaci\u00f3n.</p> <p>Est\u00e1n disponibles los siguientes 3 tipos de funciones (donde \\(yf\\) es la fracci\u00f3n de a\u00f1o asociada a la tasa de valor \\(r\\)):</p> <ul> <li> <p>QCLinearWf:     \\(\\rightarrow 1 + r \\cdot yf\\)</p> </li> <li> <p>QCCompoundWf:    \\(\\rightarrow \\left(1 + r \\right)^{yf}\\)</p> </li> <li> <p>QCContinousWf:  \\(\\rightarrow exp(r \\cdot yf)\\)</p> </li> </ul> <pre><code>wfs = [\n    lin_wf:=qcf.QCLinearWf(),\n    com_wf:=qcf.QCCompoundWf(),\n    exp_wf:=qcf.QCContinousWf(),\n]\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-wf","title":"M\u00e9todo <code>wf</code>","text":"<p>Este m\u00e9todo permite calcular el factor de capitalizaci\u00f3n a partir del valor de una tasa y el valor de una fracci\u00f3n de a\u00f1o.</p> <pre><code>r = .1   # Valor de la tasa\nyf = .5  # Fracci\u00f3n de a\u00f1o\n\nfor wf in wfs:\n    print(f\"Funci\u00f3n: {wf}. Factor: {wf.wf(r, yf):6f}\")\n</code></pre> <pre><code>Funci\u00f3n: Lin. Factor: 1.050000\nFunci\u00f3n: Com. Factor: 1.048809\nFunci\u00f3n: Exp. Factor: 1.051271\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-rate","title":"M\u00e9todo <code>rate</code>","text":"<p>Dada una funci\u00f3n de capitalizaci\u00f3n, permite obtener la tasa de inter\u00e9s correspondiente a un factor de capitalizaci\u00f3n y fracci\u00f3n de a\u00f1o.</p> <p>En este caso el factor de capitalizaci\u00f3n es 1.1, la fracci\u00f3n de a\u00f1o es 1.0 y la funci\u00f3n de capitalizaci\u00f3n es Linear.</p> <pre><code>print(f\"Tasa equivalente: {wfs[0].rate(1.1, 1.0):.4%}\")\n</code></pre> <pre><code>Tasa equivalente: 10.0000%\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#tasas-de-interes","title":"Tasas de Inter\u00e9s","text":"<p>Utilizando un n\u00famero real, una fracci\u00f3n de a\u00f1o y una funci\u00f3n de capitalizaci\u00f3n, se puede dar de alta (instanciar) un objeto de tipo <code>QCInterestRate</code> que representa una tasa de inter\u00e9s (ver por ejemplo el video Convenciones de Tasas).</p> <pre><code>r0 = 0.1\ntasas = [\n    tasa_lin_act360 := qcf.QCInterestRate(0.1, act360, lin_wf),\n    tasa_com_act365 := qcf.QCInterestRate(0.1, act365, com_wf),\n    tasa_exp_act365 := qcf.QCInterestRate(0.1, act365, exp_wf),\n]\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodos-get_value-y-set_value","title":"M\u00e9todos <code>get_value</code> y <code>set_value</code>","text":"<p>Permiten obtener y definir el valor de la tasa de inter\u00e9s.</p> <pre><code>for tasa in tasas:\n    print(f\"Descripci\u00f3n: {tasa}\") # Est\u00e1 definido el m\u00e9todo __str__\n\n    # Se obtiene el valor de la tasa utilizando get_value\n    print(\"Obtener valor:\", tasa.get_value())\n\n    # Se utiliza set_value para cambiar el valor de la tasa\n    r1 = 0.12\n    tasa.set_value(r1)\n    print(\"Obtener nuevo valor:\", tasa.get_value())\n    print()\n</code></pre> <pre><code>Descripci\u00f3n: 0.100000 Act360 Lin\nObtener valor: 0.1\nObtener nuevo valor: 0.12\n\nDescripci\u00f3n: 0.100000 Act365 Com\nObtener valor: 0.1\nObtener nuevo valor: 0.12\n\nDescripci\u00f3n: 0.100000 Act365 Exp\nObtener valor: 0.1\nObtener nuevo valor: 0.12\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodos-wf-y-dwf","title":"M\u00e9todos <code>wf</code> y <code>dwf</code>","text":"<p>Tanto <code>wf</code> como <code>dwf</code>son m\u00e9todos sobrecargados. El primero permite calcular el valor del factor de capitalizaci\u00f3n de la tasa de inter\u00e9s utilizando un n\u00famero de d\u00edas o un par de fechas, mientras que el segundo calcula la derivada del factor de capitalizaci\u00f3n respecto a la tasa de inter\u00e9s. </p> <p>\u00bfC\u00f3mo se realiza el c\u00e1lculo de la derivada? Veamos un ejemplo:</p> <p>Consideremos una tasa de inter\u00e9s cuya funci\u00f3n de capitalizaci\u00f3n es \\(g\\). De ese modo el factor de capitalizaci\u00f3n \\(wf\\) para un valor de tasa \\(r\\) y una fracci\u00f3n de a\u00f1o \\(yf\\) est\u00e1 dado por:</p> \\[wf = g\\left(r,yf\\right)\\] <p>En muchas situaciones nos interesar\u00e1 saber como cambia el factor de capitalizaci\u00f3n cuando el valor \\(r\\) de la tasa cambia. Cuando el cambio de valor, es peque\u00f1o, digamos un punto b\u00e1sico, resulta conveniente calcular el cambio de valor en \\(wf\\), \\(\\Delta wf\\) usando la derivada de la funci\u00f3n \\(g\\) respecto a \\(r\\), m\u00e1s precisamente:</p> \\[\\Delta wf = \\frac{dg\\left(r,yf\\right)}{dr}\\left(r_0,yf\\right)\\cdot\\delta\\] <p>Donde \\(r_0\\) es el valor inicial de la tasa y \\(\\delta\\) es el cambio en su valor.</p> <p>Tenemos que:</p> <ul> <li> <p>Si \\(g=1+r\\cdot yf\\) entonces \\(\\Delta wf = yf\\cdot\\delta\\)</p> </li> <li> <p>Si \\(g=\\left(1+r\\right)^{yf}\\) entonces \\(\\Delta wf = yf\\cdot\\left(1+r_0\\right)^{yf-1}\\cdot\\delta\\)</p> </li> <li> <p>Si \\(g=exp\\left(r\\cdot yf\\right)\\) entonces \\(\\Delta wf = yf\\cdot exp\\left(r_0\\cdot yf\\right)\\cdot\\delta\\)</p> </li> </ul> <p>Calculemos <code>wf</code> y <code>dwf</code> usando un par de fechas.</p> <pre><code>for i, tasa in enumerate(tasas):\n    # Retorna el factor de capitalizaci\u00f3n entre las fechas\n    print(f\"wf(fecha1, fecha3): {tasa.wf(fecha1, fecha3):.8f}\")\n\n    # Retorna la derivada del factor de capitalizaci\u00f3n respecto al valor de la tasa entre las fechas\n    print(f\"dwf(fecha1, fecha3): {tasa.dwf(fecha1, fecha3):.8f}\")\n\n    # Para verificar se calcula \"a mano\" la derivada\n    match i:\n        case 0:\n            print(f\"Check: {tasa.yf(fecha1, fecha3):.8f}\")\n        case 1:\n            yf_ = tasa.yf(fecha1, fecha3)\n            print(f\"Check: {tasa.yf(fecha1, fecha3) * (1 + r1)**(yf_ - 1):.8f}\")\n        case 2:\n            print(f\"Check: {tasa.yf(fecha1, fecha3) * tasa.wf(fecha1, fecha3):.8f}\")\n\n    print()\n</code></pre> <pre><code>wf(fecha1, fecha3): 1.01000000\ndwf(fecha1, fecha3): 0.08333333\nCheck: 0.08333333\n\nwf(fecha1, fecha3): 1.00935820\ndwf(fecha1, fecha3): 0.07407228\nCheck: 0.07407228\n\nwf(fecha1, fecha3): 1.00991181\ndwf(fecha1, fecha3): 0.08300645\nCheck: 0.08300645\n</code></pre> <p>Veamos ahora la sobrecarga y utilicemos un n\u00famero de d\u00edas.</p> <pre><code>dias = 400\nfor i, tasa in enumerate(tasas):\n    # Retorna el factor de capitalizaci\u00f3n entre las fechas\n    print(f\"wf(dias): {tasa.wf(dias):.8F}\")\n\n    # Retorna la derivada del factor de capitalizaci\u00f3n respecto al valor de la tasa entre las fechas\n    print(f\"dwf(dias): {tasa.dwf(dias):.8f}\")\n\n    # Para verificar se calcula \"a mano\" la derivada\n    match i:\n        case 0:\n            print(f\"Check: {dias / 360:.8f}\")\n        case 1:\n            yf_ = dias / 365\n            print(f\"Check: {yf_ * (1 + r1)**(yf_ - 1):.8f}\")\n        case 2:\n            print(f\"Check: {dias / 365 * tasa.wf(dias):.8f}\")\n\n    print()\n</code></pre> <pre><code>wf(dias): 1.13333333\ndwf(dias): 1.11111111\nCheck: 1.11111111\n\nwf(dias): 1.13223756\ndwf(dias): 1.10786454\nCheck: 1.10786454\n\nwf(dias): 1.14054572\ndwf(dias): 1.24991312\nCheck: 1.24991312\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-get_rate_from_wf","title":"M\u00e9todo <code>get_rate_from_wf</code>","text":"<p>Este m\u00e9todo permite calcular la tasa de inter\u00e9s correspondiente a un dado factor de capitalizaci\u00f3n, utilizando la funci\u00f3n de capitalizaci\u00f3n y la fracci\u00f3n de a\u00f1o de la tasa. El intervalo de tiempo de la tasa se puede especificar con un par de fechas o con un n\u00famero de d\u00edas.</p> <p>Veamos un ejemplo:</p> <pre><code>factor = 1.0025\ndias = 31\nfor tasa in tasas:\n    aux = f\"{tasa}\"[-10:]\n    print(f\"Tasa: {aux}\")\n    print(f\"get_rate_from_wf(factor, fecha1, fecha3): {tasa.get_rate_from_wf(factor, fecha1, fecha3):.4%}\")\n    print(f\"get_rate_from_wf(factor, dias): {tasa.get_rate_from_wf(factor, dias):.4%}\\n\")\n</code></pre> <pre><code>Tasa: Act360 Lin\nget_rate_from_wf(factor, fecha1, fecha3): 3.0000%\nget_rate_from_wf(factor, dias): 2.9032%\n\nTasa: Act365 Com\nget_rate_from_wf(factor, fecha1, fecha3): 3.0845%\nget_rate_from_wf(factor, dias): 2.9835%\n\nTasa: Act365 Exp\nget_rate_from_wf(factor, fecha1, fecha3): 3.0379%\nget_rate_from_wf(factor, dias): 2.9399%\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#tenor","title":"Tenor","text":"<p>Es una clase que representa el concepto de plazo estructurado o tenor (1D, 1M, 1Y ...).</p>"},{"location":"1_Objetos_Fundamentales/#ejemplos","title":"Ejemplos","text":"<pre><code>tenors = [\n    _1d := qcf.Tenor(\"1d\"),\n    _1m := qcf.Tenor(\"1M\"),\n    _1y := qcf.Tenor(\"1y\"),\n    _1d_1m_1y := qcf.Tenor(\"1D1M1Y\"),\n\n    # Notar que, en este caso, el constructor es capaz de eliminar\n    # los espacios y la substr nyse\n    _2y_3m := qcf.Tenor(\"2y nyse 3m\"),  \n]\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodos-get_string-get_days-get_months-y-get_years","title":"M\u00e9todos <code>get_string</code>, <code>get_days</code>, <code>get_months</code> y <code>get_years</code>","text":"<pre><code>for tenor in tenors:\n    print(f\"string: {tenor.get_string()}\")\n    print(f\"dias: {tenor.get_days()}\")\n    print(f\"meses: {tenor.get_months()}\")\n    print(f\"a\u00f1os: {tenor.get_years()}\\n\")\n</code></pre> <pre><code>string: 1D\ndias: 1\nmeses: 0\na\u00f1os: 0\n\nstring: 1M\ndias: 0\nmeses: 1\na\u00f1os: 0\n\nstring: 1Y\ndias: 0\nmeses: 0\na\u00f1os: 1\n\nstring: 1Y1M1D\ndias: 1\nmeses: 1\na\u00f1os: 1\n\nstring: 2Y3M\ndias: 0\nmeses: 3\na\u00f1os: 2\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-set_tenor","title":"M\u00e9todo <code>set_tenor</code>","text":"<pre><code>for i, tenor in enumerate(tenors):\n    tenor.set_tenor(f\"{i}d{i}m{i}y\")\n    print(f\"string: {tenor.get_string()}\\n\")\n</code></pre> <pre><code>string: 0D\n\nstring: 1Y1M1D\n\nstring: 2Y2M2D\n\nstring: 3Y3M3D\n\nstring: 4Y4M4D\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#fx-rate","title":"FX Rate","text":"<p>Es una clase que representa el concepto de tipo de cambio entre dos monedas. Para dar de alta un FXRate se requiere:</p> <ul> <li> <p>QCCurrency: la moneda fuerte del par.</p> </li> <li> <p>QCCurrency: la moneda d\u00e9bl del par.</p> </li> </ul>"},{"location":"1_Objetos_Fundamentales/#ejemplo-usdclp","title":"Ejemplo: USDCLP","text":"<pre><code>usdclp = qcf.FXRate(usd, clp)\n</code></pre> <p>Utilizando el m\u00e9todo <code>get_code</code> se puede obtener el c\u00f3digo del par seg\u00fan la convenci\u00f3n usual.</p> <pre><code>print(f\"C\u00f3digo: {usdclp.get_code()}\")\n</code></pre> <pre><code>C\u00f3digo: USDCLP\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#fx-rate-index","title":"FX Rate Index","text":"<p>Esta clase representa un \u00edndice de tipo de cambio, por ejemplo, el d\u00f3lar observado que publica el Banco Central de Chile.</p> <p>Para dar de alta un FXRateIndex se requiere:</p> <ul> <li><code>FXRate</code>: el FXRate correspondiente.</li> <li><code>str</code>: nombre del \u00edndice</li> <li><code>Tenor</code>: la regla de fixing, es 1D como el USD Observado o es 0D como un \u00edndice de cierre de d\u00eda.</li> <li><code>Tenor</code>: la regla para la valuta. Es 1D como el USDCLP o 2D como el EURUSD.</li> <li><code>BusinessCalendar</code>: el calendario adecuado para aplicar las reglas de fixing y valuta.</li> </ul>"},{"location":"1_Objetos_Fundamentales/#ejemplo","title":"Ejemplo","text":"<pre><code>_1d.set_tenor(\"1d\")\nusdclp_obs = qcf.FXRateIndex(usdclp, \"USDOBS\", _1d, _1d, qcf_scl)\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodos-fixing_date-y-value_date","title":"M\u00e9todos <code>fixing_date</code> y <code>value_date</code>","text":"<p>El m\u00e9todo <code>fixing_date</code> retorna la fecha de fixing del \u00edndice dada la fecha de publicaci\u00f3n. Por su parte, <code>value_date</code> retorna la fecha de la valuta dada la fecha de publicaci\u00f3n.</p> <pre><code>print(f\"Fecha de publicaci\u00f3n: {fecha1.week_day()}, {fecha1}\")\nprint(f\"Fecha de fixing: {usdclp_obs.fixing_date(fecha1)}\")\nprint(f\"Fecha de valuta: {usdclp_obs.value_date(fecha1)}\")\n</code></pre> <pre><code>Fecha de publicaci\u00f3n: WeekDay.THU, 2024-10-17\nFecha de fixing: 2024-10-16\nFecha de valuta: 2024-10-17\n</code></pre> <p>Notar que la fecha de fixing se calcula aplicando la regla de fixing a la fecha de publicaci\u00f3n, mientras que la fecha de valuta se calcula aplicando la regla de valuta a la fecha de fixing.</p>"},{"location":"1_Objetos_Fundamentales/#metodo-convert","title":"M\u00e9todo <code>convert</code>","text":"<p>El m\u00e9todo <code>convert</code> permite pasar r\u00e1pidamente de una moneda a la otra (de las que forman el par del \u00edndice) usando un valor para el \u00edndice.</p> <p>Veamos un ejemplo:</p> <pre><code>monto_usd = 1_000_000\nmonto_clp = 900_000_000\nvalor_usdclp_obs = 900.00\n\nresult = usdclp_obs.convert(monto_usd, qcf.QCUSD(), valor_usdclp_obs)\nprint(f\"Monto en CLP es: {result:,.0f}\")\n\nresult = usdclp_obs.convert(monto_clp, qcf.QCCLP(), valor_usdclp_obs)\nprint(f\"Monto en USD es: {result:,.0f}\")\n</code></pre> <pre><code>Monto en CLP es: 900,000,000\nMonto en USD es: 1,000,000\n</code></pre> <p>Esta funci\u00f3n es c\u00f3moda porque evita tener que controlar en el propio c\u00f3digo si la divisa del monto a convertir es la fuerte o la d\u00e9bil del par.</p>"},{"location":"1_Objetos_Fundamentales/#qccurrencyconverter","title":"QCCurrencyConverter","text":"<p>Este es un objeto que permite realizar conversiones de una moneda a otra con un poco m\u00e1s de generalidad que en el caso anterior.</p> <pre><code>ccy_converter = qcf.QCCurrencyConverter()\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#metodo-convert_1","title":"M\u00e9todo <code>convert</code>","text":"<p>El m\u00e9todo <code>convert</code> se puede utilizar con dos conjuntos distintos de argumentos:</p> <ul> <li><code>float</code>: que representa el monto en una divisa a convertir,</li> <li><code>QCCurrency</code>: que representa la divisa del monto anterior</li> <li><code>float</code>: que representa el valor del tipo de cambio a utilizar en la convenci\u00f3n de mercado del par</li> <li><code>FXRateIndex</code>: que representa el par de monedas entre las cuales se realiza la conversi\u00f3n</li> </ul> <p>Por ejemplo:</p> <pre><code>print(f'Monto en CLP: {ccy_converter.convert(monto_usd, usd, 900, usdclp_obs):,.0f}')\nprint(f'Monto en USD: {ccy_converter.convert(monto_clp, clp, 900, usdclp_obs):,.0f}')\n</code></pre> <pre><code>Monto en CLP: 900,000,000\nMonto en USD: 1,000,000\n</code></pre> <p>Para el segundo m\u00e9todo se introducen dos <code>enum</code> definidos en <code>QCCurrencyConverter</code>:</p>"},{"location":"1_Objetos_Fundamentales/#enum-para-monedas","title":"Enum para Monedas","text":"<pre><code>qcf.QCCurrencyEnum.CLP\n</code></pre> <pre><code>&lt;QCCurrencyEnum.CLP: 6&gt;\n</code></pre> <pre><code>qcf.QCCurrencyEnum.USD\n</code></pre> <pre><code>&lt;QCCurrencyEnum.USD: 18&gt;\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#enum-para-fxrates","title":"Enum para FXRates","text":"<pre><code>qcf.QCFxRateEnum.USDCLP\n</code></pre> <pre><code>&lt;QCFxRateEnum.USDCLP: 15&gt;\n</code></pre> <pre><code>qcf.QCFxRateEnum.EURUSD\n</code></pre> <pre><code>&lt;QCFxRateEnum.EURUSD: 31&gt;\n</code></pre> <p>Con estos <code>enum</code> el segundo conjunto de argumentos para el m\u00e9todo <code>convert</code> es:</p> <ul> <li>float: que representa el monto en una divisa a convertir,</li> <li>QCCurrencyEnum: que representa la divisa del monto anterior</li> <li>float: que representa el valor del tipo de cambio a utilizar en la convenci\u00f3n de mercado del par</li> <li>QCFxRateEnum: que representa el par de monedas entre las cuales se realiza la conversi\u00f3n</li> </ul> <p>Por ejemplo:</p> <pre><code>print(f'Monto en USD: {ccy_converter.convert(monto_clp, qcf.QCCurrencyEnum.CLP, 900, qcf.QCFxRateEnum.USDCLP):,.0f}')\nprint(f'Monto en CLP: {ccy_converter.convert(monto_usd, qcf.QCCurrencyEnum.USD, 900, qcf.QCFxRateEnum.USDCLP):,.0f}')\n</code></pre> <pre><code>Monto en USD: 1,000,000\nMonto en CLP: 900,000,000\n</code></pre> <p>Las divisas disponibles en <code>QCCurrencyEnum</code> son las mismas que en <code>QCCurrency</code>:</p> <pre><code>qcf.QCCurrencyEnum.AUD\n</code></pre> <pre><code>&lt;QCCurrencyEnum.AUD: 0&gt;\n</code></pre> <pre><code>qcf.QCCurrencyEnum.BRL\n</code></pre> <pre><code>&lt;QCCurrencyEnum.BRL: 1&gt;\n</code></pre> <pre><code>qcf.QCCurrencyEnum.PEN\n</code></pre> <pre><code>&lt;QCCurrencyEnum.PEN: 16&gt;\n</code></pre> <p>Los pares de divisas en <code>QCFxRateEnum</code> son los pares de las divisas versus el USD (en su convenci\u00f3n de mercado) y las divisas versus CLP, que aunque no son pares l\u00edquidos, son \u00fatiles cuando se quiere expresar montos en cualquier divisa en CLP.</p> <pre><code>qcf.QCFxRateEnum.USDCLP\n</code></pre> <pre><code>&lt;QCFxRateEnum.USDCLP: 15&gt;\n</code></pre> <pre><code>qcf.QCFxRateEnum.EURUSD\n</code></pre> <pre><code>&lt;QCFxRateEnum.EURUSD: 31&gt;\n</code></pre> <pre><code>qcf.QCFxRateEnum.EURCLP\n</code></pre> <pre><code>&lt;QCFxRateEnum.EURCLP: 32&gt;\n</code></pre>"},{"location":"1_Objetos_Fundamentales/#time-series","title":"Time Series","text":"<p>Este es un objeto que permite almacenar series de tiempo financieras y se utilizar\u00e1n m\u00e1s adelante en el fixing y valorizaci\u00f3n de flujos de caja de tasa de inter\u00e9s. Su estructura interna es muy similar a la de un objeto <code>dict[datetime.date, float]</code> en Python, s\u00f3lo se debe reemplazar la <code>key</code> del <code>dict</code> por un objeto de tipo <code>QCCDate</code>.</p>"},{"location":"1_Objetos_Fundamentales/#ejemplo_1","title":"Ejemplo","text":"<pre><code>ts = qcf.time_series()\nts[fecha1] = 10.0\n</code></pre> <pre><code>type(ts)\n</code></pre> <pre><code>qcfinancial.time_series\n</code></pre> <pre><code>ts[fecha1]\n</code></pre> <pre><code>10.0\n</code></pre> <pre><code>for k, v in ts.items():\n    print(k, v)\n</code></pre> <pre><code>2024-10-17 10.0\n</code></pre>"},{"location":"2_Cashflows/","title":"Cashflows","text":"<p>Para ejecutar todos los ejemplos se debe importar la librer\u00eda. Se sugiere utilizar siempre el alias <code>qcf</code>. </p> <pre><code>import qcfinancial as qcf\nimport aux_functions as aux\nimport pandas as pd\n</code></pre> <pre><code>qcf.id()\n</code></pre> <pre><code>'version: 1.6.1, build: 2025-06-06 09:09'\n</code></pre>"},{"location":"2_Cashflows/#simple-cashflow","title":"Simple Cashflow","text":"<p>Un objeto de tipo <code>SimpleCashflow</code> representa un flujo de caja cierto en una fecha y moneda. Para instanciar un objeto de este tipo se requiere:</p> <ul> <li><code>QCDate</code>: fecha del flujo</li> <li><code>float</code>: monto del flujo</li> <li><code>QCCurrency</code>: moneda del flujo</li> </ul> <p>Veamos un ejemplo. Primero se define los par\u00e1metros.</p> <pre><code>fecha1 = qcf.QCDate(24, 8, 2024)\nmonto = 1_000_000\nclp = qcf.QCCLP()\n</code></pre> <p>Luego, se instancia el objeto.</p> <pre><code>simple_cashflow = qcf.SimpleCashflow(\n    fecha1, \n    monto, \n    clp,\n)\n</code></pre>"},{"location":"2_Cashflows/#metodos-amount-ccy-y-date","title":"M\u00e9todos <code>amount</code>, <code>ccy</code> y <code>date</code>","text":"<p>Permiten obtener el monto, la moneda y la fecha del flujo.</p> <pre><code>print(f\"Monto: {simple_cashflow.amount():,.0f}\")\n</code></pre> <pre><code>Monto: 1,000,000\n</code></pre> <pre><code>print(f\"Moneda: {simple_cashflow.ccy()}\")\n</code></pre> <pre><code>Moneda: CLP\n</code></pre> <pre><code>print(f\"Fecha: {simple_cashflow.date()}\")\n</code></pre> <pre><code>Fecha: 2024-08-24\n</code></pre>"},{"location":"2_Cashflows/#metodo-is_expired","title":"M\u00e9todo <code>is_expired</code>","text":"<p>Todos los cashflows tienen el m\u00e9todo de conveniencia <code>is_expired</code> que sirve para indicar si un flujo ya ocurri\u00f3 o est\u00e1 vencido.</p> <pre><code>simple_cashflow.is_expired(qcf.QCDate(\"2024-09-01\"))\n</code></pre> <pre><code>True\n</code></pre> <p>Notar que no se considera vencido si la fecha de referencia es menor o igual a la fecha de vencimiento.</p> <pre><code>simple_cashflow.is_expired(fecha1)\n</code></pre> <pre><code>False\n</code></pre> <pre><code>simple_cashflow.is_expired(qcf.QCDate(\"2024-01-01\"))\n</code></pre> <pre><code>False\n</code></pre>"},{"location":"2_Cashflows/#funcion-show","title":"Funci\u00f3n <code>show</code>","text":"<p>Esta funci\u00f3n envuelve de forma c\u00f3moda todo el flujo en un objeto <code>tuple</code>. La funci\u00f3n <code>show</code> est\u00e1 sobrecargada y admite todos los tipos de flujo de <code>qcfinancial</code>.</p> <pre><code>qcf.show(simple_cashflow)\n</code></pre> <pre><code>('2024-08-24', 1000000.0, 'CLP')\n</code></pre>"},{"location":"2_Cashflows/#funcion-get_column_names","title":"Funci\u00f3n <code>get_column_names</code>","text":"<p>Para nombrar los elementos de la tupla anterior, se puede utilizar la funci\u00f3n <code>get_column_names</code>.</p> <pre><code>qcf.get_column_names('SimpleCashflow')\n</code></pre> <pre><code>('fecha_pago', 'monto', 'moneda')\n</code></pre> <p>Con ella podemos, por ejemplo, estructurar a\u00fan m\u00e1s el output de <code>show</code> utilizando un <code>pandas.DataFrame</code>.</p> <pre><code>df = pd.DataFrame([qcf.show(simple_cashflow)])\ndf.columns = list(qcf.get_column_names('SimpleCashflow'))\ndf.style.format({'monto':'{:,.0f}'})\n</code></pre> fecha_pago monto moneda 0 2024-08-24 1,000,000 CLP"},{"location":"2_Cashflows/#simple-multicurrency-cashflow","title":"Simple Multicurrency Cashflow","text":"<p>Un objeto de tipo <code>SimpleMultiCurrencyCashflow</code> representa un flujo de caja cierto en una fecha y moneda, el cual, sin embargo, se liquidar\u00e1 en una segunda moneda utilizando el valor de un \u00edndice de tipo de cambio a una fecha futura. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha final</li> <li><code>float</code>: monto nominal</li> <li><code>QCCurrency</code>: la moneda del monto nominal</li> <li><code>QCDate</code>: la fecha de publicaci\u00f3n del <code>FXRateIndex</code> que se usar\u00e1 en la conversi\u00f3n</li> <li><code>QCCurrency</code>: la moneda final del flujo</li> <li><code>FXRateIndex</code>: el \u00edndice de tipo de cambio a utilizar</li> <li><code>float</code>: el valor del \u00edndice de tipo de cambio</li> </ul>"},{"location":"2_Cashflows/#ejemplo-1","title":"Ejemplo 1","text":"<p>Se da de alta los objetos que el constructor del \u00edndice de tipo de cambio necesita.</p> <pre><code># moneda\nusd = qcf.QCUSD()\n\n# tipo de cambio\nusdclp = qcf.FXRate(usd, clp)\n\n# tenor\n_1d = qcf.Tenor('1D')\n</code></pre> <p>Aqu\u00ed utilizamos <code>aux.get_business_calendar</code> para apoyarnos en la librer\u00eda <code>holidays</code> y obtener el calendario de Santiago.</p> <pre><code># calendario Santiago\nscl = aux.get_business_calendar(\"CL\", range(2024, 2035))\n\n# d\u00f3lar observado\nusdclp_obs = qcf.FXRateIndex(usdclp, \"USDOBS\", _1d, _1d, scl)\n\n# valor del \u00edndice\nfx_rate_value = 900.0\n</code></pre> <p>Se da de alta el cashflow.</p> <pre><code>simple_mccy_cashflow = qcf.SimpleMultiCurrencyCashflow(\n    fecha1, \n    monto, \n    clp,  # nominal en CLP\n    fecha1, \n    usd,  # pago en USD\n    usdclp_obs, \n    fx_rate_value\n)\n</code></pre> <p>Este objeto hereda de <code>SimpleCashflow</code> y por lo tanto, los m\u00e9todos <code>amount</code>, <code>date</code> y <code>ccy</code> siguen disponibles.</p> <pre><code>print(f\"Monto: {simple_mccy_cashflow.amount():,.2f}\")\nprint(f\"Fecha: {simple_mccy_cashflow.date()}\")\nprint(f\"Moneda: {simple_mccy_cashflow.ccy()}\")\n</code></pre> <pre><code>Monto: 1,000,000.00\nFecha: 2024-08-24\nMoneda: CLP\n</code></pre> <p>Para obtener el monto en la moneda de pago y la moneda de pago est\u00e1n los m\u00e9todos <code>settlement_amount</code> y <code>settlement_ccy</code>.</p> <pre><code>print(f\"Monto de pago: {simple_mccy_cashflow.settlement_amount():,.0f}\")\n</code></pre> <pre><code>Monto de pago: 1,111\n</code></pre> <pre><code>print(f\"Moneda de pago: {simple_mccy_cashflow.settlement_ccy()}\")\n</code></pre> <pre><code>Moneda de pago: USD\n</code></pre> <p>El valor del \u00edndice de tipo de cambio se puede alterar con el m\u00e9todo <code>set_fx_rate_index_value</code>.</p> <pre><code>simple_mccy_cashflow.set_fx_rate_index_value(800.00)\nprint(f\"Flujo: {simple_mccy_cashflow.settlement_amount():,.2f} {simple_mccy_cashflow.settlement_ccy()}\")\n</code></pre> <pre><code>Flujo: 1,250.00 USD\n</code></pre>"},{"location":"2_Cashflows/#ejemplo-2","title":"Ejemplo 2","text":"<p>Aqu\u00ed, las monedas est\u00e1n invertidas respecto al caso anterior. El valor del \u00edndice se usa de la forma correcta.</p> <pre><code>simple_mccy_cashflow = qcf.SimpleMultiCurrencyCashflow(\n    fecha1, \n    1_000_000, \n    usd,  # nominal en USD\n    fecha1, \n    clp,  # pago en CLP\n    usdclp_obs, \n    fx_rate_value,\n)\n</code></pre> <p>Se repite los c\u00e1lculos del ejemplo anterior.</p> <pre><code>print(f\"Fecha: {simple_mccy_cashflow.date()}\")\nprint(f\"Nominal: {simple_mccy_cashflow.nominal():,.2f}\")\nprint(f\"Moneda nominal: {simple_mccy_cashflow.ccy().get_iso_code()}\")\nprint(f\"Flujo: {simple_mccy_cashflow.settlement_amount():,.0f}\")\nprint(f\"Moneda flujo: {simple_mccy_cashflow.settlement_ccy().get_iso_code()}\")\n</code></pre> <pre><code>Fecha: 2024-08-24\nNominal: 1,000,000.00\nMoneda nominal: USD\nFlujo: 900,000,000\nMoneda flujo: CLP\n</code></pre>"},{"location":"2_Cashflows/#ejemplo-3","title":"Ejemplo 3","text":"<p>En este caso, hay inconsistencia entre las monedas y el tipo de cambio del \u00edndice y vemos que se produce un error.</p> <pre><code>eur = qcf.QCEUR()\ntry:\n    simple_mccy_cashflow = qcf.SimpleMultiCurrencyCashflow(\n        fecha1,\n        1_000_000,\n        usd,         # nominal en USD\n        fecha1,\n        eur,         # pago en EUR\n        usdclp_obs,  # \u00a1usamos el d\u00f3lar observado!\n        fx_rate_value,\n    )\nexcept ValueError as e:\n    print(\"Error:\", e)\n</code></pre> <pre><code>Error: Fx Rate Index provided is not compatible with nominal and settlement currency.\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_columns","title":"Funciones <code>show</code> y <code>get_columns</code>","text":"<pre><code>qcf.show(simple_mccy_cashflow)\n</code></pre> <pre><code>('2024-08-24',\n 1000000.0,\n 'USD',\n '2024-08-24',\n 'CLP',\n 'USDOBS',\n 900.0,\n 900000000.0)\n</code></pre> <pre><code>qcf.get_column_names('SimpleMultiCurrencyCashflow')\n</code></pre> <pre><code>('fecha_pago',\n 'monto_nominal',\n 'moneda_nominal',\n 'fecha_fixing_fx',\n 'moneda_pago',\n 'codigo_indice_fx',\n 'valor_indice_fx',\n 'monto_moneda_pago')\n</code></pre> <p>Nuevamente, usando estas funciones podemos visualizar el flujo utilizando un <code>pandas.DataFrame</code>.</p> <pre><code>df = pd.DataFrame([qcf.show(simple_mccy_cashflow)])\ndf.columns = list(qcf.get_column_names('SimpleMultiCurrencyCashflow'))\ndf.style.format({\n    'monto_nominal':'{:,.0f}',\n    'monto_moneda_pago':'{:,.0f}',\n    'valor_indice_fx':'{:,.2f}'\n})\n</code></pre> fecha_pago monto_nominal moneda_nominal fecha_fixing_fx moneda_pago codigo_indice_fx valor_indice_fx monto_moneda_pago 0 2024-08-24 1,000,000 USD 2024-08-24 CLP USDOBS 900.00 900,000,000"},{"location":"2_Cashflows/#fixed-rate-cashflow","title":"Fixed Rate Cashflow","text":"<p>Un objeto de tipo <code>FixedRateCashflow</code> representa un flujo de caja calculado a partir de la aplicaci\u00f3n de una tasa prefijada, entre dos fechas prefijadas a un nominal prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCInterestRate</code>: la tasa de inter\u00e9s a aplicar (su valor y convenciones)</li> <li><code>QCCurrency</code>: moneda del nominal y del flujo de caja</li> </ul>"},{"location":"2_Cashflows/#construccion","title":"Construcci\u00f3n","text":"<p>Se define los par\u00e1metros requeridos.</p> <pre><code>fecha_inicio = qcf.QCDate(20, 5, 2024)\nfecha_final = qcf.QCDate(20, 5, 2025)\nfecha_pago = qcf.QCDate(22, 5, 2025)\nnominal = 1_000_000_000.0\namortizacion = 100_000_000.0\namort_is_cashflow = False\n</code></pre> <p>Se define la yearFraction, wealthFunction el valor de la tasa y finalmente la tasa de inter\u00e9s.</p> <pre><code>act360 = qcf.QCAct360()\nlin_wf = qcf.QCLinearWf()\nvalor_tasa_fija = .1\ntasa = qcf.QCInterestRate(valor_tasa_fija, act360, lin_wf)\n</code></pre> <p>Se instancia el cashflow.</p> <pre><code>fixed_rate_cashflow = qcf.FixedRateCashflow(\n    fecha_inicio, \n    fecha_final, \n    fecha_pago, \n    nominal, \n    amortizacion, \n    amort_is_cashflow, \n    tasa, \n    clp,\n)\n</code></pre>"},{"location":"2_Cashflows/#getters","title":"Getters","text":"<pre><code>print(f\"Tipo de flujo: {fixed_rate_cashflow.get_type()}\")\nprint(f\"Fecha Inicio: {fixed_rate_cashflow.get_start_date()}\")\nprint(f\"Fecha Final: {fixed_rate_cashflow.get_end_date()}\")\nprint(f\"Fecha Pago: {fixed_rate_cashflow.get_settlement_date()}\")\nprint(f\"Moneda: {fixed_rate_cashflow.ccy()}\") # __str__ devuelve el ISO Code de la moneda\nprint(f\"Nominal: {fixed_rate_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {fixed_rate_cashflow.get_amortization():,.0f}\")\nprint(f\"Tasa de inter\u00e9s: {fixed_rate_cashflow.get_rate()}\")\n</code></pre> <pre><code>Tipo de flujo: FixedRateCashflow\nFecha Inicio: 2024-05-20\nFecha Final: 2025-05-20\nFecha Pago: 2025-05-22\nMoneda: CLP\nNominal: 1,000,000,000\nAmortizaci\u00f3n: 100,000,000\nTasa de inter\u00e9s: 0.100000 Act360 Lin\n</code></pre> <p>Para obtener el valor de la tasa fija, se usa adem\u00e1s un getter de <code>QCInterestRate</code>.</p> <pre><code>print(f\"Tasa de inter\u00e9s: {fixed_rate_cashflow.get_rate().get_value():.2%}\")\n</code></pre> <pre><code>Tasa de inter\u00e9s: 10.00%\n</code></pre>"},{"location":"2_Cashflows/#setters","title":"Setters","text":"<p>Cambiar el nominal.</p> <pre><code>nuevo_nominal = 2_000_000_000.0\nfixed_rate_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nuevo nominal: {fixed_rate_cashflow.get_nominal():,.0f}\")\n</code></pre> <pre><code>Nuevo nominal: 2,000,000,000\n</code></pre> <p>Cambiar la amortizaci\u00f3n.</p> <pre><code>nueva_amortizacion = 200_000_000.0\nfixed_rate_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Nueva amortizaci\u00f3n: {fixed_rate_cashflow.get_amortization():,.0f}\")\n</code></pre> <pre><code>Nueva amortizaci\u00f3n: 200,000,000\n</code></pre> <p>Cambiar el valor de la tasa.</p> <pre><code>fixed_rate_cashflow.set_rate_value(new_rate_value:=.12)\nprint(f\"Nuevo valor de la tasa: {fixed_rate_cashflow.get_rate().get_value():.2%}\")\n</code></pre> <pre><code>Nuevo valor de la tasa: 12.00%\n</code></pre>"},{"location":"2_Cashflows/#calculos","title":"C\u00e1lculos","text":"<p>Se devuelve el valor de la tasa fija al original.</p> <pre><code>fixed_rate_cashflow.set_rate_value(valor_tasa_fija)\n</code></pre> <p>M\u00e9todo <code>amount</code>.</p> <pre><code>print(f\"Flujo Total: {fixed_rate_cashflow.amount():,.0f}\")\n</code></pre> <pre><code>Flujo Total: 202,777,778\n</code></pre> <p>Vemos que el flujo incluye los intereses, pero no la amortizaci\u00f3n (<code>amort_is_cashflow = False</code>). Podemos verificar a mano este resultado.</p> <pre><code>dias_devengo = fecha_inicio.day_diff(fecha_final)\nprint(f\"D\u00edas de devengo: {dias_devengo}\")\nprint(f\"Check: {fixed_rate_cashflow.get_nominal() * valor_tasa_fija * dias_devengo / 360:,.0f}\")\n</code></pre> <pre><code>D\u00edas de devengo: 365\nCheck: 202,777,778\n</code></pre> <p>M\u00e9todo <code>accrued_interest</code>. Calcula el inter\u00e9s devengado a una cierta fecha.</p> <pre><code>fecha_intermedia = qcf.QCDate(15, 1, 2025)\nprint(f\"Inter\u00e9s Devengado: {fixed_rate_cashflow.accrued_interest(fecha_intermedia):,.0f}\")\ndias_devengo = fecha_inicio.day_diff(fecha_intermedia)\nprint(f\"D\u00edas de devengo: {dias_devengo}\")\nprint(f\"Check: {fixed_rate_cashflow.get_nominal() * valor_tasa_fija * dias_devengo / 360.0:,.0f}\")\n</code></pre> <pre><code>Inter\u00e9s Devengado: 133,333,333\nD\u00edas de devengo: 240\nCheck: 133,333,333\n</code></pre> <p>Con este m\u00e9todo, utilizando la fecha final del flujo se puede obtener el inter\u00e9s total.</p> <pre><code>print(f\"Inter\u00e9s total: al {fixed_rate_cashflow.accrued_interest(fixed_rate_cashflow.get_end_date()):,.0f}\")\n</code></pre> <pre><code>Inter\u00e9s total: al 202,777,778\n</code></pre>"},{"location":"2_Cashflows/#funcion-show_1","title":"Funci\u00f3n <code>show</code>","text":"<pre><code>print(qcf.show(fixed_rate_cashflow))\n</code></pre> <pre><code>('2024-05-20', '2025-05-20', '2025-05-22', 2000000000.0, 200000000.0, 202777777.77777794, False, 202777777.77777794, 'CLP', 0.1, 'LinAct360')\n</code></pre>"},{"location":"2_Cashflows/#funcion-get_column_names_1","title":"Funci\u00f3n <code>get_column_names</code>","text":"<pre><code>qcf.get_column_names(fixed_rate_cashflow.get_type())\n</code></pre> <pre><code>('fecha_inicial',\n 'fecha_final',\n 'fecha_pago',\n 'nocional',\n 'amortizacion',\n 'interes',\n 'amort_es_flujo',\n 'flujo',\n 'moneda_nocional',\n 'valor_tasa',\n 'tipo_tasa')\n</code></pre> <p>Nuevamente, juntando las \u00faltimas dos funciones se obtiene una representaci\u00f3n tabular del flujo usando <code>pandas.DataFrame</code>.</p> <pre><code>df = pd.DataFrame(\n    [qcf.show(fixed_rate_cashflow)], \n    columns=qcf.get_column_names(fixed_rate_cashflow.get_type())\n)\ndf.style.format({\n    'nominal':'{:,.0f}', \n    'amortizacion':'{:,.0f}', \n    'interes':'{:,.0f}', \n    'flujo':'{:,.0f}',\n    'valor_tasa':'{:.2%}'\n})\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-05-20 2025-05-20 2025-05-22 2000000000.000000 200,000,000 202,777,778 False 202,777,778 CLP 10.00% LinAct360"},{"location":"2_Cashflows/#fixed-rate-multi-currency-cashflow","title":"Fixed Rate Multi Currency Cashflow","text":"<p>Un objeto de tipo <code>FixedRateMultiCurrencyCashflow</code> representa un flujo de caja a tasa fija (<code>FixedRateCashflow</code>) que se liquidar\u00e1 en una moneda distinta de la moneda del nominal utilizando el valor a una cierta fecha de un \u00edndice de tipo de cambio prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCInterestRate</code>: la tasa de inter\u00e9s a aplicar (su valor y convenciones)</li> <li><code>QCCurrency</code>: moneda del nominal</li> <li><code>QCDate</code>: fecha de fijaci\u00f3n del \u00edndice de tipo de cambio</li> <li><code>QCCurrency</code>: moneda en la que se liquida el flujo</li> <li><code>FXRateIndex</code>: \u00edndice de tipo de cambio a utilizar</li> <li><code>float</code>: valor del \u00edndice de tipo de cambio</li> </ul>"},{"location":"2_Cashflows/#construccion_1","title":"Construcci\u00f3n","text":"<p>Cuando coinciden, se usan los mismos par\u00e1metros que en el ejemplo anterior y agregamos los nuevos par\u00e1metros requeridos.</p> <pre><code>fecha_fijacion = fecha_final\nusd = qcf.QCUSD()\nindice = usdclp_obs\nvalor_indice = 900.0\nnominal = 1_000_000.0\namort = 100_000.0\namort_is_cashflow = True\n</code></pre> <p>Se instancia el objeto.</p> <pre><code>fixed_rate_mccy_cashflow = qcf.FixedRateMultiCurrencyCashflow(\n    fecha_inicio,\n    fecha_final,\n    fecha_pago,\n    nominal,\n    amort,\n    amort_is_cashflow,\n    tasa,\n    usd,\n    fecha_fijacion,\n    clp,\n    indice,\n    valor_indice,\n)\n</code></pre>"},{"location":"2_Cashflows/#getters_1","title":"Getters","text":"<p>La clase <code>FixedRateMultiCurrencyCashflow</code> es una subclase de <code>FixedRateCashflow</code> y por lo tanto, hereda todos sus m\u00e9todos y variables.</p> <pre><code>print(f\"Tipo de flujo: {fixed_rate_mccy_cashflow.get_type()}\")\nprint(f\"Fecha Inicio: {fixed_rate_mccy_cashflow.get_start_date()}\")\nprint(f\"Fecha Final: {fixed_rate_mccy_cashflow.get_end_date()}\")\nprint(f\"Fecha Pago: {fixed_rate_mccy_cashflow.get_settlement_date()}\")\nprint(f\"Fecha Fijaci\u00f3n \u00cdndice FX: {fixed_rate_mccy_cashflow.get_fx_fixing_date()}\")\nprint(f\"Moneda del Nominal: {fixed_rate_mccy_cashflow.ccy()}\")\nprint(f\"Nominal: {fixed_rate_mccy_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {fixed_rate_mccy_cashflow.get_amortization():,.0f}\")\nprint(f\"Moneda de Liquidaci\u00f3n: {fixed_rate_mccy_cashflow.settlement_currency()}\")\n\n# Aqu\u00ed se usa un getter de QCInterestRate\nprint(f\"Tasa de inter\u00e9s: {fixed_rate_mccy_cashflow.get_rate().get_value():.2%}\")\n</code></pre> <pre><code>Tipo de flujo: FixedRateMultiCurrencyCashflow\nFecha Inicio: 2024-05-20\nFecha Final: 2025-05-20\nFecha Pago: 2025-05-22\nFecha Fijaci\u00f3n \u00cdndice FX: 2025-05-20\nMoneda del Nominal: USD\nNominal: 1,000,000\nAmortizaci\u00f3n: 100,000\nMoneda de Liquidaci\u00f3n: CLP\nTasa de inter\u00e9s: 10.00%\n</code></pre>"},{"location":"2_Cashflows/#setters_1","title":"Setters","text":"<p>Nuevo nominal.</p> <pre><code>nuevo_nominal = 100.0\nfixed_rate_mccy_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nuevo nominal: {fixed_rate_mccy_cashflow.get_nominal():,.1f}\")\n</code></pre> <pre><code>Nuevo nominal: 100.0\n</code></pre> <p>Nueva amortizaci\u00f3n.</p> <pre><code>nueva_amortizacion = 10.0\nfixed_rate_mccy_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Nueva amortizaci\u00f3n: {fixed_rate_mccy_cashflow.get_amortization():,.1f}\")\n</code></pre> <pre><code>Nueva amortizaci\u00f3n: 10.0\n</code></pre> <p>Cambiar el valor de la tasa.</p> <pre><code>fixed_rate_mccy_cashflow.set_rate_value(new_rate_value)\nprint(f\"Nuevo valor de la tasa: {fixed_rate_mccy_cashflow.get_rate().get_value():.2%}\")\n</code></pre> <pre><code>Nuevo valor de la tasa: 12.00%\n</code></pre>"},{"location":"2_Cashflows/#calculos_1","title":"C\u00e1lculos","text":"<p>Se vuelve al nominal, amortizaci\u00f3n y valor de la tasa iniciales.</p> <pre><code>fixed_rate_mccy_cashflow.set_nominal(nominal)\nfixed_rate_mccy_cashflow.set_amortization(amort)\nfixed_rate_mccy_cashflow.set_rate_value(valor_tasa_fija)\n</code></pre> <p>M\u00e9todo <code>amount</code>. En este caso s\u00ed se incluye la amortizaci\u00f3n (<code>amort_is_cashflow = True</code>).</p> <pre><code>print(f\"Flujo Total: {fixed_rate_mccy_cashflow.amount():,.2f}\")\ndias_devengo = fecha_inicio.day_diff(fecha_final)\nprint(\n    f\"Check: {fixed_rate_mccy_cashflow.get_nominal() * valor_tasa_fija * dias_devengo / 360 + fixed_rate_mccy_cashflow.get_amortization():,.2f}\"\n)\n</code></pre> <pre><code>Flujo Total: 201,388.89\nCheck: 201,388.89\n</code></pre> <p>M\u00e9todo <code>accrued_interest</code>.</p> <pre><code>fecha_intermedia = qcf.QCDate(15, 1, 2025)\nprint(f\"Inter\u00e9s Devengado: {(interes_devengado:=fixed_rate_mccy_cashflow.accrued_interest(fecha_intermedia)):,.02f}\")\nprint(f\"Check: {fixed_rate_mccy_cashflow.get_nominal() * valor_tasa_fija * fecha_inicio.day_diff(fecha_intermedia) / 360.0:,.02f}\")\n</code></pre> <pre><code>Inter\u00e9s Devengado: 66,666.67\nCheck: 66,666.67\n</code></pre> <p>M\u00e9todo <code>accrued_interest_in_sett_currency</code>. Retorna el inter\u00e9s devengado en moneda de pago. Para esto requiere de un objeto de tipo <code>time_series</code> que contenga el valor del \u00edndice a la fecha de devengo solicitada.</p> <pre><code>ts = qcf.time_series()\nts[fecha_inicio] = 900\nts[fecha_intermedia] = 950\n</code></pre> <pre><code>print(f\"Inter\u00e9s devengado en moneda de pago: {fixed_rate_mccy_cashflow.accrued_interest_in_sett_ccy(fecha_intermedia, ts):,.2f}\")\nprint(f\"Check: {interes_devengado * ts[fecha_intermedia]:,.2f}\")\n</code></pre> <pre><code>Inter\u00e9s devengado en moneda de pago: 63,333,333.33\nCheck: 63,333,333.33\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_column_names","title":"Funciones <code>show</code> y <code>get_column_names</code>","text":"<p>Juntando estas dos funciones se obtiene una representaci\u00f3n tabular del flujo usando <code>pandas.DataFrame</code>.</p> <pre><code>df = pd.DataFrame(\n    [qcf.show(fixed_rate_mccy_cashflow)], \n    columns=qcf.get_column_names(fixed_rate_mccy_cashflow.get_type())\n)\ndf.style.format({\n    'nominal':'{:,.2f}', \n    'amortizacion':'{:,.2f}', \n    'amortizacion_moneda_pago':'{:,.0f}', \n    'interes':'{:,.2f}', \n    'interes_moneda_pago':'{:,.0f}', \n    'flujo':'{:,.2f}',\n    'valor_tasa':'{:.2%}',\n    'valor_indice_fx':'{:.2f}'\n})\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa fecha_fixing_fx moneda_pago indice_fx valor_indice_fx amortizacion_moneda_pago interes_moneda_pago 0 2024-05-20 2025-05-20 2025-05-22 1000000.000000 100,000.00 101,388.89 True 201,388.89 USD 10.00% LinAct360 2025-05-20 CLP USDOBS 900.00 90,000,000 91,250,000"},{"location":"2_Cashflows/#ibor-cashflow","title":"Ibor Cashflow","text":"<p>Un objeto de tipo <code>IborCashflow</code> representa un flujo de caja calculado a partir de la aplicaci\u00f3n de una tasa flotante fijada en una cierta fecha (TERMSOFR, Euribor, ...) , entre dos fechas prefijadas a un nominal prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de fijaci\u00f3n del \u00edndice de tasa de inter\u00e9s </li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nominal y del flujo de caja</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n del \u00edndice</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n del \u00edndice</li> </ul> <p>Para dar de alta un <code>InterestRateIndex</code> se requiere:</p> <ul> <li><code>str</code>: c\u00f3digo del \u00edndice</li> <li><code>QCInterestRate</code>: un objeto tasa de inter\u00e9s que contenga las convenciones del \u00edndice</li> <li><code>Tenor</code>: el lag de inicio del \u00edndice respecto a la fecha de fixing (por ejemplo 2d para Libor USD)</li> <li><code>Tenor</code>: el tenor del \u00edndice (3M por ejemplo para Libor USD 3M)</li> <li><code>QCBusinessCalendar</code>: el calendario de fixing</li> <li><code>QCBusinessCalendar</code>: el calendario de pago</li> <li><code>QCCurrency</code>: la moneda a la que corresponde el \u00edndice (por ejemplo EUR para EURIBOR 3M)</li> </ul>"},{"location":"2_Cashflows/#construccion_2","title":"Construcci\u00f3n","text":"<p>Se define primero el \u00edndice de tasa de inter\u00e9s.</p> <pre><code>codigo = \"TERMSOFR6M\"\nlin_act360 = qcf.QCInterestRate(0.0, act360, lin_wf)\nfixing_lag = qcf.Tenor(\"2D\")\ntenor = qcf.Tenor(\"6M\")\nfixing_calendar = aux.get_business_calendar('US', range(2024, 2035))\nsettlement_calendar = fixing_calendar\nterm_sofr_6m = qcf.InterestRateIndex(\n    codigo, \n    lin_act360, \n    fixing_lag, \n    tenor, \n    fixing_calendar, \n    settlement_calendar, \n    usd\n)\n</code></pre> <p>Getters del objeto <code>InterestRateIndex</code>.</p> <pre><code>print(f\"Code: {term_sofr_6m.get_code()}\")\nprint(f\"Tenor: {term_sofr_6m.get_tenor()}\")\nprint(f\"Tasa: {term_sofr_6m.get_rate()}\")\n</code></pre> <pre><code>Code: TERMSOFR6M\nTenor: 6M\nTasa: 0.000000 Act360 Lin\n</code></pre> <p>Para fijar el valor del \u00edndice en una fecha en particular.</p> <pre><code>term_sofr_6m.set_rate_value(0.01)\nprint(f\"Fixing Tasa: {term_sofr_6m.get_rate().get_value():.2%}\")\n</code></pre> <pre><code>Fixing Tasa: 1.00%\n</code></pre> <pre><code>fecha_fixing = qcf.QCDate(20, 9, 2018)\nprint(f\"Fecha Inicio: {term_sofr_6m.get_start_date(fecha_fixing)}\")\nprint(f\"Fecha Final: {term_sofr_6m.get_end_date(fecha_fixing)}\")\n</code></pre> <pre><code>Fecha Inicio: 2018-09-24\nFecha Final: 2019-03-25\n</code></pre> <p>Con esto, veamos un ejemplo de construcci\u00f3n y uso de un <code>IborCashflow</code>.</p> <pre><code>fecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\nfecha_fixing = qcf.QCDate(18, 9, 2018)\nnominal = 1_000_000.0\namort = 100_000.0\namort_is_cashflow = True\nspread = 0.0\ngearing = 1.0\n\nibor_cashflow = qcf.IborCashflow(\n    term_sofr_6m,\n    fecha_inicio,\n    fecha_final,\n    fecha_fixing,\n    fecha_pago,\n    nominal,\n    amort,\n    amort_is_cashflow,\n    usd,\n    spread,\n    gearing,\n)\n</code></pre>"},{"location":"2_Cashflows/#getters_2","title":"Getters","text":"<pre><code>print(f\"Tipo Cashflow:\\t{ibor_cashflow.get_type()}\")\nprint(f\"Fecha Fixing:\\t{ibor_cashflow.get_fixing_date()}\")\nprint(f\"Fecha Inicio:\\t{ibor_cashflow.get_start_date()}\")\nprint(f\"Fecha Final:\\t{ibor_cashflow.get_end_date()}\")\nprint(f\"Fecha Pago:\\t{ibor_cashflow.get_settlement_date()}\")\nprint(f\"Nominal:\\t{ibor_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n:\\t{ibor_cashflow.get_amortization():,.0f}\")\nprint(f\"Moneda:\\t\\t{ibor_cashflow.ccy()}\")\nprint(f\"Valor Tasa:\\t{ibor_cashflow.get_interest_rate_value():.2%}\")\nprint(f\"Valor Spread:\\t{ibor_cashflow.get_spread():.2%}\")\nprint(f\"Valor Gearing:\\t{ibor_cashflow.get_gearing():.2f}\")\n</code></pre> <pre><code>Tipo Cashflow:  IborCashflow\nFecha Fixing:   2018-09-18\nFecha Inicio:   2018-09-20\nFecha Final:    2019-09-20\nFecha Pago: 2019-09-23\nNominal:    1,000,000\nAmortizaci\u00f3n:   100,000\nMoneda:     USD\nValor Tasa: 1.00%\nValor Spread:   0.00%\nValor Gearing:  1.00\n</code></pre>"},{"location":"2_Cashflows/#setters_2","title":"Setters","text":"<p>Nuevo nominal.</p> <pre><code>nuevo_nominal = 2_000_000.0\nibor_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nominal: {ibor_cashflow.get_nominal():,.0f}\")\n</code></pre> <pre><code>Nominal: 2,000,000\n</code></pre> <p>Nueva amortizaci\u00f3n.</p> <pre><code>nueva_amortizacion = 200_000.0\nibor_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Amortizaci\u00f3n: {ibor_cashflow.get_amortization():,.0f}\")\n</code></pre> <pre><code>Amortizaci\u00f3n: 200,000\n</code></pre> <p>Cambia el valor del \u00edndice.</p> <pre><code>ibor_cashflow.set_interest_rate_value(nuevo_valor_indice:=.02)\nprint(f\"Valor Tasa: {ibor_cashflow.get_interest_rate_value():.2%}\")\n</code></pre> <pre><code>Valor Tasa: 2.00%\n</code></pre> <p>Cambia el valor del spread.</p> <pre><code>ibor_cashflow.set_spread(.01)\nprint(f\"Valor Spread: {ibor_cashflow.get_spread():.2%}\")\n</code></pre> <pre><code>Valor Spread: 1.00%\n</code></pre> <p>Cambia el valor del gearing.</p> <pre><code>ibor_cashflow.set_gearing(1.2)\nprint(f\"Valor Spread: {ibor_cashflow.get_gearing():.2}\")\n</code></pre> <pre><code>Valor Spread: 1.2\n</code></pre>"},{"location":"2_Cashflows/#calculos_2","title":"C\u00e1lculos","text":"<p>M\u00e9todo <code>amount</code>. Retorna el flujo total incluyendo la amortizaci\u00f3n si corresponde.</p> <pre><code>print(f\"Flujo: {ibor_cashflow.amount():,.2f}\")\n</code></pre> <pre><code>Flujo: 268,944.44\n</code></pre> <p>M\u00e9todo <code>accrued_interest</code>. Retorna el inter\u00e9s devengado a una cierta fecha.</p> <pre><code>fecha_devengo = qcf.QCDate(20, 7, 2019)\nprint(f\"Inter\u00e9s Devengado al {fecha_devengo}: {ibor_cashflow.accrued_interest(fecha_devengo):,.2f}\")\n\n# La tasa es el valor del \u00edndice m\u00e1s el spread\ntasa = ibor_cashflow.get_interest_rate_value() * ibor_cashflow.get_gearing() + ibor_cashflow.get_spread()\n\ncheck = tasa * fecha_inicio.day_diff(fecha_devengo) / 360.0 * ibor_cashflow.get_nominal()\nprint(f\"Check: {check:,.2f}\")\n</code></pre> <pre><code>Inter\u00e9s Devengado al 2019-07-20: 57,233.33\nCheck: 57,233.33\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_column_names_1","title":"Funciones <code>show</code> y <code>get_column_names</code>","text":"<p>Al igual que en casos anteriores, juntando estas dos funciones se obtiene una representaci\u00f3n tabular del flujo usando <code>pandas.DataFrame</code>.</p> <pre><code>df = pd.DataFrame(\n    [qcf.show(ibor_cashflow)], \n    columns=qcf.get_column_names(ibor_cashflow.get_type())\n)\ndf.style.format({\n    'nominal':'{:,.2f}', \n    'amortizacion':'{:,.2f}', \n    'interes':'{:,.2f}', \n    'flujo':'{:,.2f}',\n    'valor_tasa':'{:.2%}',\n    'spread':'{:.2%}',\n    'gearing':'{:.2f}',\n})\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2018-09-20 2019-09-20 2018-09-18 2019-09-23 2000000.000000 200,000.00 40,555.56 True 268,944.44 USD TERMSOFR6M 2.00% 1.00% 1.20 LinAct360"},{"location":"2_Cashflows/#ibor-multi-currency-cashflow","title":"Ibor Multi Currency Cashflow","text":"<p>Un objeto de tipo <code>IborMultiCurrencyCashflow</code> representa un flujo de caja a tasa variable (<code>IborCashflow</code>) que se liquidar\u00e1 en una moneda distinta de la moneda del nominal utilizando el valor a una cierta fecha de un \u00edndice de tipo de cambio prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de fijaci\u00f3n del \u00edndice de tasa de inter\u00e9s </li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nominal y del flujo de caja</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n del \u00edndice</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n del \u00edndice</li> <li><code>QCDate</code>: fecha de publicaci\u00f3n del \u00edndice de tipo de cambio</li> <li><code>QCCurrency</code>: moneda en la que se liquida el flujo</li> <li><code>FXRateIndex</code>: \u00edndice de tipo de cambio a utilizar</li> <li><code>float</code>: valor del \u00edndice de tipo de cambio</li> </ul>"},{"location":"2_Cashflows/#construccion_3","title":"Construcci\u00f3n","text":"<p>Par\u00e1metros iniciales, s\u00f3lo agregamos los par\u00e1metros relacionados al MultiCurrency y fijamos el valor del \u00edndice de tasa de inter\u00e9s en 1.00%.</p> <pre><code>valor_indice_fx = 900.0\nfecha_publicacion = qcf.QCDate(20, 9, 2019)\nterm_sofr_6m.set_rate_value(0.01)\n</code></pre> <p>Se da de alta el objeto.</p> <pre><code>ibor_mccy_cashflow = qcf.IborMultiCurrencyCashflow(\n    term_sofr_6m,\n    fecha_inicio,\n    fecha_final,\n    fecha_fixing,\n    fecha_pago,\n    nominal,\n    amort,\n    amort_is_cashflow,\n    usd,\n    spread,\n    gearing,\n    fecha_publicacion,\n    clp,\n    indice,\n    valor_indice,\n)\n</code></pre>"},{"location":"2_Cashflows/#getters_3","title":"Getters","text":"<p>El objeto <code>IborMultiCurrencyCashflow</code> es una subclase de <code>IborCashflow</code> y por lo tanto, hereda todos sus m\u00e9todos y variables.</p> <pre><code>print(f\"Tipo Cashflow:\\t {ibor_mccy_cashflow.get_type()}\")\nprint(f\"Fecha Fixing:\\t {ibor_mccy_cashflow.get_fixing_date()}\")\nprint(f\"Fecha Inicio:\\t {ibor_mccy_cashflow.get_start_date()}\")\nprint(f\"Fecha Final:\\t {ibor_mccy_cashflow.get_end_date()}\")\nprint(f\"Fecha Pago:\\t {ibor_mccy_cashflow.get_settlement_date()}\")\nprint(f\"Nominal:\\t {ibor_mccy_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n:\\t {ibor_mccy_cashflow.get_amortization():,.0f}\")\nprint(f\"Moneda:\\t\\t {ibor_mccy_cashflow.ccy()}\")\nprint(f\"Valor Tasa:\\t {ibor_mccy_cashflow.get_interest_rate_value():.2%}\")\nprint(f\"Valor Spread:\\t {ibor_mccy_cashflow.get_spread():.2%}\")\nprint(f\"Valor Gearing:\\t {ibor_mccy_cashflow.get_gearing():.2f}\")\n</code></pre> <pre><code>Tipo Cashflow:   IborMultiCurrencyCashflow\nFecha Fixing:    2018-09-18\nFecha Inicio:    2018-09-20\nFecha Final:     2019-09-20\nFecha Pago:  2019-09-23\nNominal:     1,000,000\nAmortizaci\u00f3n:    100,000\nMoneda:      USD\nValor Tasa:  1.00%\nValor Spread:    0.00%\nValor Gearing:   1.00\n</code></pre> <p>Adicionalmente tenemos:</p> <pre><code>print(f\"Fecha Fixing FX: {ibor_mccy_cashflow.get_fx_fixing_date()}\")\nprint(f\"Valor \u00cdndice FX: {ibor_mccy_cashflow.get_fx_rate_index_value():,.2f}\")\n</code></pre> <pre><code>Fecha Fixing FX: 2019-09-20\nValor \u00cdndice FX: 900.00\n</code></pre>"},{"location":"2_Cashflows/#setters_3","title":"Setters","text":"<p>Nuevo nominal.</p> <pre><code>nuevo_nominal = 2_000_000.0\nibor_mccy_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nominal: {ibor_mccy_cashflow.get_nominal():,.0f}\")\n</code></pre> <pre><code>Nominal: 2,000,000\n</code></pre> <p>Nueva amortizaci\u00f3n.</p> <pre><code>nueva_amortizacion = 200_000.0\nibor_mccy_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Amortizaci\u00f3n: {ibor_mccy_cashflow.get_amortization():,.0f}\")\n</code></pre> <pre><code>Amortizaci\u00f3n: 200,000\n</code></pre> <p>Cambia el valor del \u00edndice de tasa de inter\u00e9s.</p> <pre><code>ibor_mccy_cashflow.set_interest_rate_value(nuevo_valor_indice:=.02)\nprint(f\"Valor Tasa: {ibor_mccy_cashflow.get_interest_rate_value():.2%}\")\n</code></pre> <pre><code>Valor Tasa: 2.00%\n</code></pre> <p>Nuevo valor para el \u00edndice FX.</p> <pre><code>ibor_mccy_cashflow.set_fx_rate_index_value(950.0)\nprint(f\"Valor \u00cdndice FX: {ibor_mccy_cashflow.get_fx_rate_index_value():,.2f}\")\n</code></pre> <pre><code>Valor \u00cdndice FX: 950.00\n</code></pre>"},{"location":"2_Cashflows/#calculos_3","title":"C\u00e1lculos","text":"<p>M\u00e9todo <code>amount</code>. Retorna el flujo total incluyendo la amortizaci\u00f3n si corresponde.</p> <pre><code>print(f\"Flujo: {ibor_mccy_cashflow.amount():,.2f}\")\ncheck = ibor_mccy_cashflow.get_nominal() * fecha_inicio.day_diff(fecha_final) / 360.0 * (\n    ibor_mccy_cashflow.get_interest_rate_value() * ibor_mccy_cashflow.get_gearing() + spread) + ibor_mccy_cashflow.get_amortization()\nprint(f\"Check: {check:,.2f}\")\n</code></pre> <pre><code>Flujo: 240,555.56\nCheck: 240,555.56\n</code></pre> <p>M\u00e9todo <code>accrued_interest</code>. Retorna el inter\u00e9s devengado a una cierta fecha.</p> <pre><code>fecha_devengo = qcf.QCDate(20, 7, 2019)\nprint(f\"Inter\u00e9s Devengado al {fecha_devengo}: {ibor_mccy_cashflow.accrued_interest(fecha_devengo):,.2f}\")\n\ntasa = ibor_mccy_cashflow.get_interest_rate_value() * ibor_mccy_cashflow.get_gearing() + ibor_mccy_cashflow.get_spread()\n\ncheck = tasa * fecha_inicio.day_diff(fecha_devengo) / 360.0 * ibor_cashflow.get_nominal()\nprint(f\"Check: {check:,.2f}\")\n</code></pre> <pre><code>Inter\u00e9s Devengado al 2019-07-20: 33,666.67\nCheck: 33,666.67\n</code></pre> <p>Se agrega el m\u00e9todo <code>accrued_interest_in_sett_ccy</code> que retorna el inter\u00e9s devengado en moneda de pago. Para utilizarlo se requiere un objeto de tipo <code>time_series</code>.</p> <pre><code>ts[fecha_inicio] = 800.0\nts[fecha_devengo] = 950.0\n</code></pre> <pre><code>print(f\"Inter\u00e9s devengado en moneda de pago: {ibor_mccy_cashflow.accrued_interest_in_sett_ccy(fecha_devengo, ts):,.0f}\")\nprint(f\"Check: {check * 950.0:,.0f}\")\n</code></pre> <pre><code>Inter\u00e9s devengado en moneda de pago: 31,983,333\nCheck: 31,983,333\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_column_names_2","title":"Funciones <code>show</code> y <code>get_column_names</code>","text":"<p>Al igual que en casos anteriores, juntando estas dos funciones se obtiene una representaci\u00f3n tabular del flujo usando <code>pandas.DataFrame</code>.</p> <pre><code>df = pd.DataFrame(\n    [qcf.show(ibor_mccy_cashflow)], \n    columns=qcf.get_column_names(ibor_mccy_cashflow.get_type())\n)\ndf.style.format({\n    'nocional':'{:,.2f}', \n    'amortizacion':'{:,.2f}', \n    'amortizacion_moneda_pago':'{:,.2f}', \n    'interes':'{:,.2f}',\n    'interes_moneda_pago':'{:,.2f}',\n    'flujo':'{:,.2f}',\n    'flujo_moneda_pago':'{:,.2f}',\n    'valor_tasa':'{:.2%}',\n    'spread':'{:.2%}',\n    'valor_indice_fx':'{:,.2f}',\n})\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa spread gearing valor_tasa tipo_tasa fecha_fixing_fx moneda_pago codigo_indice_fx valor_indice_fx amortizacion_moneda_pago interes_moneda_pago flujo_moneda_pago 0 2018-09-20 2019-09-20 2018-09-18 2019-09-23 2,000,000.00 200,000.00 40,555.56 True 240,555.56 USD TERMSOFR6M 0.00% 1.000000 2.00% LinAct360 2019-09-20 CLP USDOBS 950.00 190,000,000.00 38,527,777.78 228,527,777.78"},{"location":"2_Cashflows/#overnight-index-cashflow","title":"Overnight Index Cashflow","text":"<p>Un objeto de tipo <code>OvernightIndexCashflow</code> representa un flujo de caja del tipo de la pata flotante de un swap ICPCLP (c\u00e1mara promedio) de Chile usando cualquier tipo de \u00edndice similar (por ejemplo SOFRINDX) y cualquier moneda. Adicionalmente, permite definir en forma independiente a <code>start_date</code> y <code>end_date</code> las fechas inicial y final utilizadas para los valores del \u00edndice. Esto puede resultar \u00fatil cuando una de estas operaciones se utiliza para cubrir cr\u00e9ditos o bonos a tasa fija y tiene, por lo tanto, vencimientos en fechas inh\u00e1biles. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio devengo (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final devengo (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha inicio \u00edndice (para el valor del \u00edndice)</li> <li><code>QCDate</code>: fecha final \u00edndice (para el valor del \u00edndice)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>float</code>: nocional (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la tasa equivalente (TNA en el caso de un ICPCLP)</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la tasa equivalente</li> <li><code>QCInterestRate</code>: con este objeto se especifica en qu\u00e9 convenci\u00f3n se calcula la tasa equivalente</li> <li><code>string</code>: nombre del \u00edndice overnight a utilizar</li> <li><code>unsigned int</code>: n\u00famero de decimales a utilizar para determinar la tasa equivalente</li> <li><code>DatesForEquivalentRate</code>: enum que indica qu\u00e9 fechas se utilizan en el c\u00e1lculo de la tasa equivalente.</li> </ul>"},{"location":"2_Cashflows/#construccion_4","title":"Construcci\u00f3n","text":"<p>Alta de par\u00e1metros iniciales.</p> <pre><code># Fecha inicio de devengo es un domingo\nfecha_inicio_devengo = qcf.QCDate(12, 11, 2023)\n\n# Fecha final de devengo es s\u00e1bado\nfecha_final_devengo = qcf.QCDate(18, 11, 2023)\n\n# Estas fechas deben corresponder a d\u00edas h\u00e1biles\n# En ambos casos vamos a la fecha h\u00e1bil siguiente\nfecha_inicio_indice = qcf.QCDate(13, 11, 2023)\nfecha_final_indice = qcf.QCDate(20, 11, 2023)\n\n# La fecha de pago es el lunes siguiente\nfecha_pago = qcf.QCDate(20, 11, 2023)\n\n# Se usan las fechas de inicio y fin de devengo para\n# el c\u00e1lculo de la tasa equivalente\ndates_for_eq_rate = qcf.DatesForEquivalentRate.ACCRUAL\n\nmoneda_nocional = qcf.QCUSD()\nnocional = 1_000_000_000.0\namort = 100_000_000.0\namort_es_flujo = True\nspread = 0.0\ngearing = 1.0\ntasa = qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\nnombre_indice = 'INDICE'\nnum_decimales = 8 # decimales como n\u00famero &lt;-&gt; 6 decimales como porcentaje\n</code></pre> <p>Se da de alta el objeto.</p> <pre><code>overnight_index_cashflow = qcf.OvernightIndexCashflow(\n    fecha_inicio_devengo,\n    fecha_final_devengo,\n    fecha_inicio_indice,\n    fecha_final_indice,\n    fecha_pago,\n    moneda_nocional,\n    nocional,\n    amort,\n    amort_es_flujo,\n    spread,\n    gearing,\n    tasa,\n    nombre_indice,\n    num_decimales,\n    dates_for_eq_rate,\n)\n</code></pre>"},{"location":"2_Cashflows/#getters_4","title":"Getters","text":"<pre><code>print(f\"Tipo Cashflow:\\t\\t\\t{overnight_index_cashflow.get_type()}\")\nprint(f\"Nominal:\\t\\t\\t{overnight_index_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n:\\t\\t\\t{overnight_index_cashflow.get_amortization():,.0f}\")\nprint(f\"Fecha Inicio Devengo:\\t\\t{overnight_index_cashflow.get_start_date()}\")\nprint(f\"Fecha Final Devengo:\\t\\t{overnight_index_cashflow.get_end_date()}\")\nprint(f\"Fecha Inicio \u00cdndice:\\t\\t{overnight_index_cashflow.get_index_start_date()}\")\nprint(f\"Fecha Final \u00cdndice:\\t\\t{overnight_index_cashflow.get_index_end_date()}\")\nprint(f\"Fecha Pago:\\t\\t\\t{overnight_index_cashflow.get_settlement_date()}\")\nprint(f\"Valor \u00cdndice Fecha Inicio:\\t{overnight_index_cashflow.get_start_date_index():,.8f}\")\nprint(f\"Valor \u00cdndice Fecha Final:\\t{overnight_index_cashflow.get_end_date_index():,.8f}\")\nprint(f\"Valor Tasa Eq:\\t\\t\\t{overnight_index_cashflow.get_rate_value():.4%}\")\nprint(f\"Tipo de Tasa:\\t\\t\\t{overnight_index_cashflow.get_type_of_rate()}\")\nprint(f\"Moneda:\\t\\t\\t\\t{overnight_index_cashflow.ccy()}\")\n</code></pre> <pre><code>Tipo Cashflow:          OvernightIndexCashflow\nNominal:            1,000,000,000\nAmortizaci\u00f3n:           100,000,000\nFecha Inicio Devengo:       2023-11-12\nFecha Final Devengo:        2023-11-18\nFecha Inicio \u00cdndice:        2023-11-13\nFecha Final \u00cdndice:     2023-11-20\nFecha Pago:         2023-11-20\nValor \u00cdndice Fecha Inicio:  1.00000000\nValor \u00cdndice Fecha Final:   1.00000000\nValor Tasa Eq:          0.0000%\nTipo de Tasa:           LinAct360\nMoneda:             USD\n</code></pre>"},{"location":"2_Cashflows/#setters_4","title":"Setters","text":"<p>Se fijan los valores inicial y final del \u00edndice.</p> <pre><code>valor_indice_inicio = 10_000.0\novernight_index_cashflow.set_start_date_index(valor_indice_inicio)\nprint(f\"Valor \u00cdndice Fecha Inicio: {overnight_index_cashflow.get_start_date_index():,.2f}\")\n</code></pre> <pre><code>Valor \u00cdndice Fecha Inicio: 10,000.00\n</code></pre> <pre><code>valor_indice_final = valor_indice_inicio * (1 + .051234 * 7 / 360.0)\novernight_index_cashflow.set_end_date_index(valor_indice_final)\nprint(f\"Valor \u00cdndice Fecha Final: {overnight_index_cashflow.get_end_date_index():,.8f}\")\n</code></pre> <pre><code>Valor \u00cdndice Fecha Final: 10,009.96216667\n</code></pre> <p>Decimales para el c\u00e1lculo de la tasa equivalente.</p> <pre><code>decimales_para_tasa_eq = 4\novernight_index_cashflow.set_eq_rate_decimal_places(decimales_para_tasa_eq)\nprint(f\"Nueva Tasa Eq: {overnight_index_cashflow.get_rate_value():.4%}\")\n</code></pre> <pre><code>Nueva Tasa Eq: 5.9800%\n</code></pre> <pre><code>decimales_para_tasa_eq = 6\novernight_index_cashflow.set_eq_rate_decimal_places(decimales_para_tasa_eq)\nprint(f\"Nueva Tasa Eq: {overnight_index_cashflow.get_rate_value():.4%}\")\n</code></pre> <pre><code>Nueva Tasa Eq: 5.9773%\n</code></pre> <p>Nuevo nocional.</p> <pre><code>new_notional = 123_456\novernight_index_cashflow.set_nominal(new_notional)\nprint(f\"Nuevo Nocional: {overnight_index_cashflow.get_nominal():,.2f}\")\n</code></pre> <pre><code>Nuevo Nocional: 123,456.00\n</code></pre> <p>Nueva amortizaci\u00f3n.</p> <pre><code>new_amortization = 100_000\novernight_index_cashflow.set_amortization(new_amortization)\nprint(f\"Nueva Amortizaci\u00f3n: {overnight_index_cashflow.get_amortization():,.2f}\")\n</code></pre> <pre><code>Nueva Amortizaci\u00f3n: 100,000.00\n</code></pre>"},{"location":"2_Cashflows/#calculos_4","title":"C\u00e1lculos","text":"<p>Tasa equivalente del per\u00edodo.</p> <pre><code>print(f\"Valor Tasa Equivalente Todo el Per\u00edodo: {overnight_index_cashflow.get_rate_value():.4%}\")\ncheck = round((\n    valor_indice_final / valor_indice_inicio - 1\n) * 360.0 / fecha_inicio_devengo.day_diff(fecha_final_devengo), decimales_para_tasa_eq)\nprint(f\"Check: {check:.4%}\")\n</code></pre> <pre><code>Valor Tasa Equivalente Todo el Per\u00edodo: 5.9773%\nCheck: 5.9773%\n</code></pre> <p>Se cambian las fechas utilizadas para el c\u00e1lculo de la tasa equivalente.</p> <pre><code>overnight_index_cashflow.set_dates_for_eq_rate(qcf.DatesForEquivalentRate.INDEX)\nprint(f\"Valor Tasa Equivalente Todo el Per\u00edodo: {overnight_index_cashflow.get_rate_value():.4%}\")\ncheck = round((\n    valor_indice_final / valor_indice_inicio - 1\n) * 360.0 / fecha_inicio_indice.day_diff(fecha_final_indice), decimales_para_tasa_eq)\nprint(f\"Check: {check:.4%}\")\n</code></pre> <pre><code>Valor Tasa Equivalente Todo el Per\u00edodo: 5.1234%\nCheck: 5.1234%\n</code></pre> <p>M\u00e9todo <code>accrued_interest</code>. Este m\u00e9todo tiene dos sobrecargas. En la primera, el valor del \u00edndice se entrega expl\u00edcitamente. En el ejemplo se utilizan las dos opciones para el par\u00e1metro <code>dates_for_eq_rate</code>.</p> <pre><code># Volvemos el nocional y la amortizaci\u00f3n al valor inicial\novernight_index_cashflow.set_nominal(nocional)\novernight_index_cashflow.set_amortization(amort)\n</code></pre> <pre><code>fecha_devengo = qcf.QCDate(17, 11, 2023)\nvalor_indice_devengo = 10_000.0 * (1 + .051234 * 4 / 360)\n</code></pre> <pre><code>overnight_index_cashflow.set_dates_for_eq_rate(qcf.DatesForEquivalentRate.ACCRUAL)\nprint(f\"Inter\u00e9s devengado (dates_for_eq_rate = ACCRUAL): {overnight_index_cashflow.accrued_interest(fecha_devengo, valor_indice_devengo): ,.4f}\")\ntasa = round((\n    valor_indice_devengo / valor_indice_inicio - 1\n) * 360.0 / fecha_inicio_devengo.day_diff(fecha_devengo), decimales_para_tasa_eq)\nprint(f\"Check: {nocional * fecha_inicio_devengo.day_diff(fecha_devengo) * tasa / 360.0:,.4f}\\n\")\n</code></pre> <pre><code>Inter\u00e9s devengado (dates_for_eq_rate = ACCRUAL):  569,263.8889\nCheck: 569,263.8889\n</code></pre> <pre><code>overnight_index_cashflow.set_dates_for_eq_rate(qcf.DatesForEquivalentRate.INDEX)\nprint(f\"Inter\u00e9s devengado (dates_for_eq_rate = INDEX): {overnight_index_cashflow.accrued_interest(fecha_devengo, valor_indice_devengo): ,.4f}\")\ntasa = round((\n    valor_indice_devengo / valor_indice_inicio - 1\n) * 360.0 / fecha_inicio_indice.day_diff(fecha_devengo), decimales_para_tasa_eq)\nprint(f\"Check: {nocional * fecha_inicio_devengo.day_diff(fecha_devengo) * tasa / 360.0:,.4f}\")\n</code></pre> <pre><code>Inter\u00e9s devengado (dates_for_eq_rate = INDEX):  711,583.3333\nCheck: 711,583.3333\n</code></pre> <p>La segunda sobrecarga de <code>accrued_interest</code> permite empaquetar el valor del \u00edndice a fecha de devengo en un objeto de tipo <code>time_series</code>.</p> <pre><code>data = qcf.time_series()\ndata[fecha_devengo] = valor_indice_devengo\n\novernight_index_cashflow.set_dates_for_eq_rate(qcf.DatesForEquivalentRate.ACCRUAL)\n</code></pre> <pre><code># El segundo par\u00e1metro de accrued_interest es ahora data\nprint(f\"Inter\u00e9s devengado (dates_for_eq_rate = ACCRUAL): {overnight_index_cashflow.accrued_interest(fecha_devengo, data): ,.4f}\")\n\n# En este caso, en los dias para el c\u00e1lculo de la tasa equivalente\n# coinciden con los d\u00edas de devengo, aunque cualquiera de las dos\n# fechas de devengo sea inh\u00e1bil.\ndias_calculo_tasa_eq = fecha_inicio_devengo.day_diff(fecha_devengo)\ntasa = (valor_indice_devengo / valor_indice_inicio - 1) * 360.0 / dias_calculo_tasa_eq\ntasa = round(tasa, decimales_para_tasa_eq)\n\ndias_devengo = dias_calculo_tasa_eq\nprint(f\"Check: {nocional * tasa * dias_devengo / 360.0:,.4f}\\n\")\n\novernight_index_cashflow.set_dates_for_eq_rate(qcf.DatesForEquivalentRate.INDEX)\n</code></pre> <pre><code>Inter\u00e9s devengado (dates_for_eq_rate = ACCRUAL):  569,263.8889\nCheck: 569,263.8889\n</code></pre> <pre><code># El segundo par\u00e1metro de accrued_interest es ahora data\nprint(f\"Inter\u00e9s devengado (dates_for_eq_rate = INDEX): {overnight_index_cashflow.accrued_interest(fecha_devengo, data): ,.4f}\")\n\n# En este caso, en los d\u00edas para el c\u00e1lculo de la tasa equivalente \n# se utiliza las fecha de inicio del \u00edndice.\ndias_calculo_tasa_eq = fecha_inicio_indice.day_diff(fecha_devengo)\ntasa = (valor_indice_devengo / valor_indice_inicio - 1) * 360.0 / dias_calculo_tasa_eq\ntasa = round(tasa, decimales_para_tasa_eq)\n\n# Para el devengo siempre se utiliza, los d\u00edas de devengo\nprint(f\"Check: {nocional * tasa * dias_devengo / 360.0:,.4f}\\n\")\n</code></pre> <pre><code>Inter\u00e9s devengado (dates_for_eq_rate = INDEX):  711,583.3333\nCheck: 711,583.3333\n</code></pre> <p>M\u00e9todo <code>amount</code></p> <pre><code>overnight_index_cashflow.set_dates_for_eq_rate(qcf.DatesForEquivalentRate.ACCRUAL)\nprint(f\"Amount (ACCRUAL): {overnight_index_cashflow.amount():,.4f}\")\ndias_calculo_tasa_eq = fecha_inicio_devengo.day_diff(fecha_final_devengo)\ntasa = (valor_indice_final / valor_indice_inicio - 1) * 360.0 / dias_calculo_tasa_eq\ndias_devengo = dias_calculo_tasa_eq\nprint(f\"Check: {nocional * (1 + tasa * dias_devengo / 360.0):,.4f}\\n\")\n</code></pre> <pre><code>Amount (ACCRUAL): 100,996,216.6667\nCheck: 1,000,996,216.6667\n</code></pre> <pre><code>overnight_index_cashflow.set_dates_for_eq_rate(qcf.DatesForEquivalentRate.INDEX)\nprint(f\"Amount (INDEX): {overnight_index_cashflow.amount():,.4f}\")\ndias_calculo_tasa_eq = fecha_inicio_indice.day_diff(fecha_final_indice)\ntasa = (valor_indice_final / valor_indice_inicio - 1) * 360.0 / dias_calculo_tasa_eq\nprint(f\"Check: {nocional * (1 + tasa * dias_devengo / 360.0):,.4f}\\n\")\n</code></pre> <pre><code>Amount (INDEX): 100,853,900.0000\nCheck: 1,000,853,900.0000\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_column_names_3","title":"Funciones <code>show</code> y <code>get_column_names</code>","text":"<p>Al igual que en casos anteriores, juntando estas dos funciones se obtiene una representaci\u00f3n tabular del flujo usando <code>pandas.DataFrame</code>.</p> <pre><code>df = pd.DataFrame(\n    [qcf.show(overnight_index_cashflow)], \n    columns=qcf.get_column_names(overnight_index_cashflow.get_type())\n)\ndf.style.format({\n    'nocional':'{:,.2f}', \n    'amortizacion':'{:,.2f}', \n    'amortizacion_moneda_pago':'{:,.2f}', \n    'interes':'{:,.2f}',\n    'interes_moneda_pago':'{:,.2f}',\n    'flujo':'{:,.2f}',\n    'flujo_moneda_pago':'{:,.2f}',\n    'valor_tasa_equivalente':'{:.6%}',\n    'spread':'{:.2%}',\n    'valor_indice_inicial':'{:,.2f}',\n    'valor_indice_final':'{:,.2f}',\n})\n</code></pre> fecha_inicial fecha_final fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa tipo_tasa interes flujo spread gearing 0 2023-11-12 2023-11-18 2023-11-13 2023-11-20 2023-11-20 1,000,000,000.00 100,000,000.00 True USD INDICE 10,000.00 10,009.96 0.051234 LinAct360 1,195,466.67 101,195,466.67 0.00% 1.000000"},{"location":"2_Cashflows/#overnight-index-multi-currency-cashflow","title":"Overnight Index Multi Currency Cashflow","text":"<p>Un objeto de tipo <code>OvernightIndexMultiCurrencyCashflow</code> hereda de <code>OvernightIndexCashflow</code> y representa un flujo de caja del tipo de la pata flotante de un swap ICPCLP (c\u00e1mara promedio) de Chile usando cualquier tipo de \u00edndice similar (por ejemplo SOFRINDX), cualquier moneda de nocional, pero con flujos de caja en una moneda distinta a la del nocional, por ejemplo un ICPCLP con contraparte en USA que compensa en USD. Al heredar de <code>OvernightIndexCashflow</code>, tambi\u00e9n permite definir en forma independiente a <code>start_date</code> y <code>end_date</code> las fechas inicial y final utilizadas para los valores del \u00edndice. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio devengo (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final devengo (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha inicio \u00edndice (para el valor del \u00edndice)</li> <li><code>QCDate</code>: fecha final \u00edndice (para el valor del \u00edndice)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>float</code>: nocional (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la tasa equivalente (TNA en el caso de un ICPCLP)</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la tasa equivalente</li> <li><code>QCInterestRate</code>: con este objeto se especifica en qu\u00e9 convenci\u00f3n se calcula la tasa equivalente</li> <li><code>string</code>: nombre del \u00edndice overnight a utilizar</li> <li><code>unsigned int</code>: n\u00famero de decimales a utilizar para determinar la tasa equivalente</li> <li><code>DatesForEquivalentRate</code>: enum que indica qu\u00e9 fechas se utilizan en el c\u00e1lculo de la tasa equivalente.</li> </ul> <p>Hasta ac\u00e1 son los mismos argumentos necesarios para construir un <code>OvernightIndexCashflow</code>. Se a\u00f1aden los siguientes argumentos: - <code>QCDate</code>: fecha de fixing del \u00edndice de tipo de cambio. Esta fecha se refiere a la fecha de publicaci\u00f3n del \u00edndice, no a la fecha de fixing en sentido financiero. - <code>QCCurrency</code>: moneda de pago de los flujos de caja - <code>FXRateIndex</code>: \u00edndice de tipo de cambio utilizado para la conversi\u00f3n de los flujos a moneda de pago</p>"},{"location":"2_Cashflows/#ejemplo","title":"Ejemplo","text":"<pre><code>fecha_inicio_devengo = qcf.QCDate(13, 11, 2023)\n\n# Notar que la fecha final de devengo es s\u00e1bado\nfecha_final_devengo = qcf.QCDate(18, 11, 2023)\n\nfecha_inicio_indice = qcf.QCDate(13, 11, 2023)\n\n# Notar que la fecha final de \u00edndice es el viernes\nfecha_final_indice = qcf.QCDate(17, 11, 2023)\n\n# La fecha de pago es el lunes siguiente\nfecha_pago = qcf.QCDate(20, 11, 2023)\n\nmoneda_nocional = qcf.QCUSD()\nnocional = 10_000_000.0\namort = 1_000_000.0\namort_es_flujo = True\nspread = 0.0\ngearing = 1.0\ntasa = qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\nnombre_indice = 'INDICE'\nnum_decimales = 8\ndates_for_eq_rate = qcf.DatesForEquivalentRate.ACCRUAL\n</code></pre> <p>Par\u00e1metros para la parte MultiCurrency.</p> <pre><code>fecha_fixing_fx_index = fecha_final_devengo\nmoneda_pago = qcf.QCCLP()\nindice_fx = usdclp_obs\n</code></pre> <pre><code>overnight_index_mccy_cashflow = qcf.OvernightIndexMultiCurrencyCashflow(\n    fecha_inicio_devengo,\n    fecha_final_devengo,\n    fecha_inicio_indice,\n    fecha_final_indice,\n    fecha_pago,\n    moneda_nocional,\n    nocional,\n    amort,\n    amort_es_flujo,\n    spread,\n    gearing,\n    tasa,\n    nombre_indice,\n    num_decimales,\n    dates_for_eq_rate,\n    fecha_fixing_fx_index,\n    moneda_pago,\n    indice_fx,\n)\n</code></pre>"},{"location":"2_Cashflows/#nuevos-getters","title":"Nuevos Getters","text":"<pre><code>print(f\"Tipo de flujo: {overnight_index_mccy_cashflow.get_type()}\")\n</code></pre> <pre><code>Tipo de flujo: OvernightIndexMultiCurrencyCashflow\n</code></pre> <p>Este getter retorna todo el objeto <code>FXRateIndex</code>.</p> <pre><code>overnight_index_mccy_cashflow.get_fx_rate_index()\n</code></pre> <pre><code>&lt;qcfinancial.FXRateIndex at 0x115c6bdf0&gt;\n</code></pre> <pre><code>print(f\"C\u00f3digo del \u00edndice FX: {overnight_index_mccy_cashflow.get_fx_rate_index_code()}\")\n</code></pre> <pre><code>C\u00f3digo del \u00edndice FX: USDOBS\n</code></pre> <pre><code>print(f\"Valor del \u00edndice FX: {overnight_index_mccy_cashflow.get_fx_rate_index_value():,.2f}\")\n</code></pre> <pre><code>Valor del \u00edndice FX: 1.00\n</code></pre>"},{"location":"2_Cashflows/#nuevos-calculos","title":"Nuevos C\u00e1lculos","text":"<p>Primero se fijan los valores del \u00edndice overnight.</p> <pre><code>valor_indice_inicio = 1.0\nvalor_indice_final = 1 + .1234 * 4 / 360 # Suponemos un valor constante de 12.34% por 4 d\u00edas del \u00edndice\n</code></pre> <pre><code>overnight_index_mccy_cashflow.set_start_date_index(valor_indice_inicio)\novernight_index_mccy_cashflow.set_end_date_index(valor_indice_final)\n</code></pre> <pre><code>print(f\"Amount: {overnight_index_mccy_cashflow.amount():,.2f}\")\n</code></pre> <pre><code>Amount: 1,013,711.11\n</code></pre> <pre><code>print(f\"Inter\u00e9s en moneda de pago: {overnight_index_mccy_cashflow.settlement_ccy_interest():,.0f}\")\n</code></pre> <pre><code>Inter\u00e9s en moneda de pago: 13,711\n</code></pre> <pre><code>print(f\"Amortizaci\u00f3n en moneda de pago {overnight_index_mccy_cashflow.settlement_ccy_amortization():,.0f}\")\n</code></pre> <pre><code>Amortizaci\u00f3n en moneda de pago 1,000,000\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_column_names_4","title":"Funciones <code>show</code> y <code>get_column_names</code>","text":"<p>Se envuelve el resultado de la funci\u00f3n <code>show</code> en un <code>pd.DataFrame</code>.</p> <pre><code>df = pd.DataFrame(\n    [qcf.show(overnight_index_mccy_cashflow),],\n    columns=qcf.get_column_names(\"OvernightIndexMultiCurrencyCashflow\", \"\")\n)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa tipo_tasa interes flujo spread gearing moneda_pago indice_fx fecha_fixing_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2023-11-13 2023-11-18 2023-11-13 2023-11-17 2023-11-20 10,000,000.00 1,000,000.00 True USD INDICE 1.000000 1.001371 9.8720% LinAct360 13,711.00 1,013,711.00 0.0000% 1.00 CLP USDOBS 2023-11-18 1.00 13,711.00 1,000,000.00 1,013,711.00"},{"location":"2_Cashflows/#nuevo-setter","title":"Nuevo Setter","text":"<p>Valor del \u00edndice de tipo de cambio.</p> <pre><code>overnight_index_mccy_cashflow.set_fx_rate_index_value(900.0)\n</code></pre> <p>Ver el efecto en las \u00faltimas dos columnas.</p> <pre><code>pd.DataFrame(\n    [qcf.show(overnight_index_mccy_cashflow),],\n    columns=qcf.get_column_names(\"OvernightIndexMultiCurrencyCashflow\", \"\")\n).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa tipo_tasa interes flujo spread gearing moneda_pago indice_fx fecha_fixing_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2023-11-13 2023-11-18 2023-11-13 2023-11-17 2023-11-20 10,000,000.00 1,000,000.00 True USD INDICE 1.000000 1.001371 9.8720% LinAct360 911,339,999.00 912,339,999.00 0.0000% 1.00 CLP USDOBS 2023-11-18 900.00 12,339,999.00 900,000,000.00 912,339,999.00"},{"location":"2_Cashflows/#compounded-overnight-rate-cashflow-2","title":"Compounded Overnight Rate Cashflow 2","text":"<p>Un objeto de tipo <code>CompoundedOvernightRateCashflow2</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un OIS sobre cualquier \u00edndice overnight (SOFR, FF, ESTR). Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>DateList</code>: fechas de fixing del \u00edndice</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nocional de la operaci\u00f3n</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la tasa equivalente</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la tasa equivalente</li> <li><code>QCInterestRate</code>: permite especificar cu\u00e1l es la convenci\u00f3n de c\u00e1lculo de la tasa equivalente</li> <li><code>unsigned int</code>: n\u00famero de decimales a usar en el c\u00e1lculo de la tasa equivalente. Por ejemplo para 0.12345678% este valor debe ser 10.</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lookback</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lockout</li> </ul> <p>El efecto de lookback y lockout a\u00fan no est\u00e1 implementado.</p>"},{"location":"2_Cashflows/#constructor","title":"Constructor","text":"<p>Se da de alta un \u00edndice overnight ficiticio de test.</p> <pre><code>codigo = \"OITEST\"\nlin_act360 = qcf.QCInterestRate(0.0, act360, lin_wf)\nfixing_lag = qcf.Tenor(\"0d\")\ntenor = qcf.Tenor(\"1d\")\nfixing_calendar = aux.get_business_calendar(\"US\", range(2024, 2035))\nsettlement_calendar = fixing_calendar\noitest = qcf.InterestRateIndex(\n    codigo, \n    lin_act360, \n    fixing_lag, \n    tenor, \n    fixing_calendar, \n    settlement_calendar, \n    usd\n)\n</code></pre> <p>Al dar de alta directamente este cashflow es necesario entregar expl\u00edcitamente las fechas de fijaci\u00f3n. En el cap\u00edtulo relacionado a construcci\u00f3n de <code>qcf.Leg</code> veremos c\u00f3mo este proceso se simplifica.</p> <pre><code>fixing_dates = qcf.DateList()\n</code></pre> <pre><code>fixing_dates.append(qcf.QCDate(27, 12, 2021))\nfixing_dates.append(qcf.QCDate(28, 12, 2021))\nfixing_dates.append(qcf.QCDate(29, 12, 2021))\nfixing_dates.append(qcf.QCDate(30, 12, 2021))\n</code></pre> <p>Damos de alta las variables que faltan.</p> <pre><code>fecha_inicio = qcf.QCDate(27, 12, 2021)\nfecha_final = qcf.QCDate(31, 12, 2021)\nfecha_pago = qcf.QCDate(2, 1, 2022)\nnocional = 10_000_000.0\namortizacion = 100_000.0\namort_is_cashflow = True\nnotional_currency = qcf.QCUSD()\nspread = 0.001\ngearing = 1.5\ninterest_rate = qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\neq_rate_decimal_places = 8\n</code></pre> <p>Se da de alta el cashflow.</p> <pre><code>cor_cashflow_2 = qcf.CompoundedOvernightRateCashflow2(\n    oitest,\n    fecha_inicio,\n    fecha_final,\n    fecha_pago,\n    fixing_dates,\n    nocional,\n    amortizacion,\n    amort_is_cashflow,\n    notional_currency,\n    spread,\n    gearing,\n    interest_rate,\n    eq_rate_decimal_places,\n    lookback := 0,\n    lockout := 0,\n)\n</code></pre>"},{"location":"2_Cashflows/#getters_5","title":"Getters","text":"<pre><code>print(f\"Type of cashflow:\\t\\t{cor_cashflow_2.get_type()}\")\nprint(f\"Fecha Inicio:\\t\\t\\t{cor_cashflow_2.get_start_date()}\")\nprint(f\"Fecha Final:\\t\\t\\t{cor_cashflow_2.get_end_date()}\")\nprint(f\"Fecha Pago:\\t\\t\\t{cor_cashflow_2.get_settlement_date()}\")\nprint(f\"Nocional:\\t\\t\\t{cor_cashflow_2.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n:\\t\\t\\t{cor_cashflow_2.get_amortization():,.0f}\")\nprint(f\"Moneda del nocional:\\t\\t{cor_cashflow_2.ccy()}\")\nprint(f\"Spread:\\t\\t\\t\\t{cor_cashflow_2.get_spread():.2%}\")\nprint(f\"Gearing:\\t\\t\\t{cor_cashflow_2.get_gearing():.2f}\")\nprint(f\"N\u00famero de decimales de tasa:\\t{cor_cashflow_2.get_eq_rate_decimal_places()}\")\n</code></pre> <pre><code>Type of cashflow:       CompoundedOvernightRateCashflow2\nFecha Inicio:           2021-12-27\nFecha Final:            2021-12-31\nFecha Pago:         2022-01-02\nNocional:           10,000,000\nAmortizaci\u00f3n:           100,000\nMoneda del nocional:        USD\nSpread:             0.10%\nGearing:            1.50\nN\u00famero de decimales de tasa:    8\n</code></pre> <pre><code>print(\"Fechas de fijaci\u00f3n:\")\nfor d in cor_cashflow_2.get_fixing_dates():\n    print(d)\n</code></pre> <pre><code>Fechas de fijaci\u00f3n:\n2021-12-27\n2021-12-28\n2021-12-29\n2021-12-30\n</code></pre>"},{"location":"2_Cashflows/#setters_5","title":"Setters","text":"<pre><code>cor_cashflow_2.set_notional(1_000)\nprint(f\"Nocional: {cor_cashflow_2.get_nominal():,.0f}\")\n</code></pre> <pre><code>Nocional: 1,000\n</code></pre> <pre><code>cor_cashflow_2.set_amortization(0)\nprint(f\"Amortizaci\u00f3n: {cor_cashflow_2.get_amortization()}\")\n</code></pre> <pre><code>Amortizaci\u00f3n: 0.0\n</code></pre> <p>Se reversa el ejemplo.</p> <pre><code>cor_cashflow_2.set_notional(nocional)\ncor_cashflow_2.set_amortization(amortizacion)\n</code></pre>"},{"location":"2_Cashflows/#calculos_5","title":"C\u00e1lculos","text":"<p>El <code>accrued_fixing</code> corresponde a la fijaci\u00f3n de tasa equivalente en una fecha anterior a la fecha final del cashflow. Para el c\u00e1lculo de <code>accrued_fixing</code> se requiere un objeto de tipo <code>TimeSeries</code> que contenga los datos hist\u00f3ricos del \u00edndice overnight.</p> <pre><code>ts = qcf.time_series()\n</code></pre> <pre><code>ts[qcf.QCDate(27, 12, 2021)] = 0.01\nts[qcf.QCDate(28, 12, 2021)] = 0.02\nts[qcf.QCDate(29, 12, 2021)] = 0.03\nts[qcf.QCDate(30, 12, 2021)] = 0.04\n</code></pre> <pre><code>print(f\"Accrued fixing: {cor_cashflow_2.accrued_fixing(qcf.QCDate(29, 12, 2021), ts):.6%}\")\n</code></pre> <pre><code>Accrued fixing: 1.500028%\n</code></pre> <pre><code>check = ((1 + 0.01 / 360) * (1 + 0.02 / 360.0) - 1) * 360 / 2.0\nprint(f\"Check: {check:.6%}\")\n</code></pre> <pre><code>Check: 1.500028%\n</code></pre> <p>El <code>accrued_interest</code> corresponde a los intereses devengados en una fecha anterior a la fecha final del cashflow. Para el c\u00e1lculo de <code>accrued_interest</code> tambi\u00e9n se requiere un objeto de tipo <code>TimeSeries</code> que contenga los datos hist\u00f3ricos del \u00edndice overnight.</p> <pre><code>print(f\"Accrued interest: {cor_cashflow_2.accrued_interest(qcf.QCDate(29, 12, 2021), ts):,.2f}\")\n</code></pre> <pre><code>Accrued interest: 1,305.58\n</code></pre> <pre><code>check = (\n    cor_cashflow_2.get_nominal()\n    * (cor_cashflow_2.accrued_fixing(qcf.QCDate(29, 12, 2021), ts) * gearing + spread) * 2 / 360.0\n)\nprint(f\"Check: {check:,.2f}\")\n</code></pre> <pre><code>Check: 1,305.58\n</code></pre> <p>Para que el m\u00e9todo <code>amount</code> retorne el resultado correcto, es necesario ejecutar primero el m\u00e9todo <code>fixings</code> que realiza la fijaci\u00f3n de todas las tasas overnight necesarias.</p> <pre><code>fixing = cor_cashflow_2.fixing(ts)\nprint(f\"Fixing: {fixing:.6%}\")\n</code></pre> <pre><code>Fixing: 2.500243%\n</code></pre> <p>De esa forma.</p> <pre><code>print(f\"Amount: {cor_cashflow_2.amount():,.2f}\")\n</code></pre> <pre><code>Amount: 104,278.18\n</code></pre> <pre><code>check = ((1 + 0.01 / 360) * (1 + 0.02 / 360.0) * (1 + 0.03 / 360.0) * (1 + 0.04 / 360.0) - 1) * 360 / 4.0\nprint(f\"Check: {nocional * (check * gearing + spread) * 4 / 360 + amortizacion:,.2f}\")\n</code></pre> <pre><code>Check: 104,278.18\n</code></pre> <p>Se puede calcular el inter\u00e9s que depende del spread.</p> <pre><code>print(f\"Inter\u00e9s del spread: {cor_cashflow_2.interest_from_spread():,.2f}\")\n</code></pre> <pre><code>Inter\u00e9s del spread: 111.11\n</code></pre> <pre><code>print(f\"Check: {nocional * spread * 4 / 360:,.2f}\")\n</code></pre> <pre><code>Check: 111.11\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_column_names_5","title":"Funciones <code>show</code> y <code>get_column_names</code>","text":"<pre><code>df = pd.DataFrame(\n    [qcf.show(cor_cashflow_2)], \n    columns=qcf.get_column_names(\"CompoundedOvernightRateCashflow2\", \"\")\n)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa tipo_tasa valor_tasa spread gearing 0 2021-12-27 2021-12-31 2022-01-02 10,000,000.00 100,000.00 4,278.18 True 104,278.18 USD OITEST LinAct360 2.5002% 0.1000% 1.50"},{"location":"2_Cashflows/#compounded-overnight-rate-multi-currency-cashflow-2","title":"Compounded Overnight Rate Multi Currency Cashflow 2","text":"<p>Un objeto de tipo <code>CompoundedOvernightRateMultiCurrencyCashflow2</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un OIS sobre cualquier \u00edndice overnight (SOFR, FF, EONIA) con la caracter\u00edstica adicional de liquidar sus flujos en una moneda distina a la del nocional. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>DateList</code>: fechas de fixing del \u00edndice</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nocional de la operaci\u00f3n</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la tasa equivalente</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la tasa equivalente</li> <li><code>QCInterestRate</code>: permite especificar cu\u00e1l es la convenci\u00f3n de c\u00e1lculo de la tasa equivalente</li> <li><code>unsigned int</code>: n\u00famero de decimales a usar en el c\u00e1lculo de la tasa equivalente. Por ejemplo para 0.12345678% este valor debe ser 10.</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lookback</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lockout</li> </ul> <p>Estos argumentos son los heredados de un <code>CompoundedOvernightRateCashflow</code>. Tambi\u00e9n en este caso, el efecto de lookback y lockout a\u00fan no est\u00e1 implementado.</p> <p>A estos argumentos se debe agregar:</p> <ul> <li><code>QCDate</code>: fecha de fixing del \u00edndice de tipo de cambio. Esta fecha se refiere a la fecha de publicaci\u00f3n del \u00edndice, no a la fecha de fixing en sentido financiero.</li> <li><code>QCCurrency</code>: moneda de pago de los flujos de caja</li> <li><code>FXRateIndex</code>: \u00edndice de tipo de cambio utilizado para la conversi\u00f3n de los flujos a moneda de pago</li> </ul>"},{"location":"2_Cashflows/#constructor_1","title":"Constructor","text":"<p>Se da de alta un \u00edndice overnight ficiticio de test.</p> <pre><code>codigo = \"OITEST\"\nlin_act360 = qcf.QCInterestRate(0.0, act360, lin_wf)\nfixing_lag = qcf.Tenor(\"0d\")\ntenor = qcf.Tenor(\"1d\")\nfixing_calendar = scl\nsettlement_calendar = scl\noitest = qcf.InterestRateIndex(\n    codigo, \n    lin_act360, \n    fixing_lag, \n    tenor, \n    fixing_calendar, \n    settlement_calendar, \n    usd\n)\n</code></pre> <p>Al dar de alta directamente este cashflow es necesario entregar expl\u00edcitamente las fechas de fijaci\u00f3n. En el cap\u00edtulo relacionado a construcci\u00f3n de <code>qcf.Leg</code> veremos c\u00f3mo este proceso se simplifica.</p> <pre><code>fixing_dates = qcf.DateList()\n</code></pre> <pre><code>fixing_dates.append(qcf.QCDate(27, 12, 2021))\nfixing_dates.append(qcf.QCDate(28, 12, 2021))\nfixing_dates.append(qcf.QCDate(29, 12, 2021))\nfixing_dates.append(qcf.QCDate(30, 12, 2021))\n</code></pre> <p>Damos de alta las variables que faltan.</p> <pre><code>fecha_inicio = qcf.QCDate(27, 12, 2021)\nfecha_final = qcf.QCDate(31, 12, 2021)\nfecha_pago = qcf.QCDate(2, 1, 2022)\nnocional = 10_000_000.0\namortizacion = 100_000.0\namort_is_cashflow = True\nnotional_currency = qcf.QCUSD()\nspread = 0.001\ngearing = 1.5\ninterest_rate = qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\neq_rate_decimal_places = 8\n# ---------------------Para el MultiCurrency ----------------------------\nfecha_fixing_fx = fecha_pago\nmoneda_pago = qcf.QCCLP()\n</code></pre> <p>Se da de alta el objeto.</p> <pre><code>cor_cashflow_mccy_2 = qcf.CompoundedOvernightRateMultiCurrencyCashflow2(\n    oitest,\n    fecha_inicio,\n    fecha_final,\n    fecha_pago,\n    fixing_dates,\n    nocional,\n    amortizacion,\n    amort_is_cashflow,\n    notional_currency,\n    spread,\n    gearing,\n    interest_rate,\n    eq_rate_decimal_places,\n    lookback,\n    lockout,\n    fecha_fixing_fx,\n    moneda_pago,\n    usdclp_obs,\n)\n</code></pre>"},{"location":"2_Cashflows/#nuevos-getters_1","title":"Nuevos Getters","text":"<pre><code>print(f\"Fx Rate Index: {cor_cashflow_mccy_2.get_fx_rate_index()}\")\nprint(f\"Fx Rate Index Value: {cor_cashflow_mccy_2.get_fx_rate_index_value()}\")\nprint(f\"Fx Rate Index Code: {cor_cashflow_mccy_2.get_fx_rate_index_code()}\")\nprint(f\"Fx Rate Index Fxing Date: {cor_cashflow_mccy_2.get_fx_rate_index_fixing_date()}\")\n</code></pre> <pre><code>Fx Rate Index: &lt;qcfinancial.FXRateIndex object at 0x115c6bdf0&gt;\nFx Rate Index Value: 1.0\nFx Rate Index Code: USDOBS\nFx Rate Index Fxing Date: 2022-01-02\n</code></pre>"},{"location":"2_Cashflows/#nuevo-setter_1","title":"Nuevo Setter","text":"<pre><code>cor_cashflow_mccy_2.set_fx_rate_index_value(900.0)\nprint(f\"Fx Rate Index Value: {cor_cashflow_mccy_2.get_fx_rate_index_value()}\")\n</code></pre> <pre><code>Fx Rate Index Value: 900.0\n</code></pre>"},{"location":"2_Cashflows/#nuevos-calculos_1","title":"Nuevos C\u00e1lculos","text":"<pre><code>print(f\"Interest: {cor_cashflow_mccy_2.interest(ts):,.2f}\")\n</code></pre> <pre><code>Interest: 4,278.18\n</code></pre> <pre><code>print(f\"To settlement currency: {cor_cashflow_mccy_2.to_settlement_currency(cor_cashflow_mccy_2.interest(ts)):,.0f}\")\n</code></pre> <pre><code>To settlement currency: 3,850,364\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_column_names_6","title":"Funciones <code>show</code> y <code>get_column_names</code>","text":"<pre><code>df = pd.DataFrame(\n    [qcf.show(cor_cashflow_mccy_2)],\n    columns=qcf.get_column_names(\"CompoundedOvernightRateMultiCurrencyCashflow2\", \"\")\n)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa tipo_tasa spread gearing valor_tasa moneda_pago fx_rate_index fecha_fixing_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2021-12-27 2021-12-31 2022-01-02 10,000,000.00 100,000.00 4,278.18 True 104,278.18 USD OITEST LinAct360 0.1000% 1.50 2.5002% CLP USDOBS 2022-01-02 900.00 3,850,364.60 90,000,000.00 93,850,364.50"},{"location":"2_Cashflows/#icp-clf-cashflow","title":"Icp Clf Cashflow","text":"<p>Un objeto de tipo <code>IcpClfCashflow</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un swap ICP (c\u00e1mara promedio) en UF de Chile. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>vector&lt;float&gt;</code>: objeto <code>double_vec</code> (en Python) que contiene ICP Inicio, ICP Final, UF Inicio, UF Final (se debe respetar el orden)</li> </ul> <p>Recordar que TRA significa Tasa Real Anual y se determina utilizando los valores del \u00edndice ICP y los valores de la UF en la fecha de inicio y fecha final del <code>IcpClfCashflow</code>.</p>"},{"location":"2_Cashflows/#constructor_2","title":"Constructor","text":"<p>Par\u00e1metros iniciales.</p> <pre><code>fecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\nnominal = 300_000.0\namort = 100_000.0\nspread = 0.0\ngearing = 1.0\n\nicp_uf = qcf.double_vec()\n# Los primeros dos valores corresponden a icp_inicial e icp_final.\n# Los segundos dos valores corresponden a uf_inicial y uf_final\nicp_uf.append(10_000.0)\nicp_uf.append(10_250.0)\nicp_uf.append(35_000.0)\nicp_uf.append(35_500.0)\n</code></pre> <p>Alta del objeto.</p> <pre><code>icp_clf_cashflow = qcf.IcpClfCashflow(\n    fecha_inicio, \n    fecha_final, \n    fecha_pago, \n    nominal, \n    amort, \n    True, \n    spread, \n    gearing, \n    icp_uf\n)\n</code></pre>"},{"location":"2_Cashflows/#getters_6","title":"Getters","text":"<pre><code>print(\"Fecha Inicio:\", icp_clf_cashflow.get_start_date())\nprint(\"Fecha Final:\", icp_clf_cashflow.get_end_date())\n\nprint(f\"ICP Fecha Inicio: {icp_clf_cashflow.get_start_date_icp():,.2f}\")\nprint(f\"ICP Fecha Final: {icp_clf_cashflow.get_end_date_icp():,.2f}\")\n\nprint(f\"UF Fecha Inicio: {icp_clf_cashflow.get_start_date_uf():,.2f}\")\nprint(f\"UF Fecha Final: {icp_clf_cashflow.get_end_date_uf():,.2f}\")\n\nprint(f\"Valor TRA Todo el Per\u00edodo: {icp_clf_cashflow.get_rate_value():.4%}\")\ntna = icp_clf_cashflow.get_tna(fecha_final, 10_250.0)\ndias = fecha_inicio.day_diff(fecha_final)\ntra = ((1 + tna * dias / 360.0) * icp_uf[2]/ icp_uf[3] - 1) * 360.0 / dias\nprint(f\"Check TRA: {round(tra, 6):.4%}\")\n\nprint(f\"Nominal: {icp_clf_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {icp_clf_cashflow.get_amortization():,.0f}\")\nprint(\"Tipo de Tasa:\", icp_clf_cashflow.get_type_of_rate())\nprint(\"Moneda:\", icp_clf_cashflow.ccy())\n</code></pre> <pre><code>Fecha Inicio: 2018-09-20\nFecha Final: 2019-09-20\nICP Fecha Inicio: 10,000.00\nICP Fecha Final: 10,250.00\nUF Fecha Inicio: 35,000.00\nUF Fecha Final: 35,500.00\nValor TRA Todo el Per\u00edodo: 1.0461%\nCheck TRA: 1.0461%\nNominal: 300,000\nAmortizaci\u00f3n: 100,000\nTipo de Tasa: LinAct360\nMoneda: CLF\n</code></pre>"},{"location":"2_Cashflows/#setters_6","title":"Setters","text":"<pre><code>decimales_para_tra = 8\nicp_clf_cashflow.set_tra_decimal_places(decimales_para_tra)\nprint(f\"Nueva TRA: {icp_clf_cashflow.get_rate_value():.6%}\")\n\nnuevo_nominal = 100_000.0\nicp_clf_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nuevo Nominal: {icp_clf_cashflow.get_nominal():,.0f}\")\n\nnueva_amortizacion = 10_000.0\nicp_clf_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Nueva Amortizaci\u00f3n: {icp_clf_cashflow.get_amortization():,.0f}\")\n\nnuevo_icp_inicio = 20_000.0\nicp_clf_cashflow.set_start_date_icp(nuevo_icp_inicio)\nprint(f\"Nuevo ICP Inicio: {icp_clf_cashflow.get_start_date_icp():,.2f}\")\n\nnuevo_icp_final = 20_500.0\nicp_clf_cashflow.set_end_date_icp(nuevo_icp_final)\nprint(f\"Nuevo ICP Final: {icp_clf_cashflow.get_end_date_icp():,.2f}\")\nprint(f\"Check TNA Final: {icp_clf_cashflow.get_tna(fecha_final, nuevo_icp_final):.6%}\")\n</code></pre> <pre><code>Nueva TRA: 1.046054%\nNuevo Nominal: 100,000\nNueva Amortizaci\u00f3n: 10,000\nNuevo ICP Inicio: 20,000.00\nNuevo ICP Final: 20,500.00\nCheck TNA Final: 2.470000%\n</code></pre>"},{"location":"2_Cashflows/#funciones-show-y-get_column_names_7","title":"Funciones <code>show</code> y <code>get_column_names</code>","text":"<pre><code>df = pd.DataFrame([qcf.show(icp_clf_cashflow)], columns=qcf.get_column_names(\"IcpClfCashflow\", \"\"))\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion amort_es_flujo flujo moneda_nocional icp_inicial icp_final uf_inicial uf_final valor_tasa interes spread gearing tipo_tasa flujo_en_clp 0 2018-09-20 2019-09-20 2019-09-23 100,000.00 10,000.00 True 11,060.58 CLF 20,000.00 20,500.00 35,000.00 35,500.00 1.0461% 1,060.58 0.0000% 1.00 LinAct360 392,650,680.00"},{"location":"3_Construccion_Operaciones/","title":"Construcci\u00f3n de Operaciones","text":"<p>Para ejecutar todos los ejemplos se debe importar la librer\u00eda. Se sugiere utilizar siempre el alias <code>qcf</code>. </p> <pre><code>import qcfinancial as qcf\nfrom qcfinancial import FxFixingLagAppliesTo\n\nimport aux_functions as aux\nimport pandas as pd\n</code></pre> <pre><code>qcf.id()\n</code></pre> <pre><code>'version: 1.6.1, build: 2025-06-06 09:09'\n</code></pre>"},{"location":"3_Construccion_Operaciones/#legs","title":"Legs","text":"<p>Los objetos de tipo <code>Leg</code> son una lista (o vector) de objetos <code>Cashflow</code> y representan una pata de un instrumento financiero. Un objeto de tipo <code>Leg</code> puede construirse a mano es decir, dando de alta cashflows y agreg\u00e1ndolos uno a uno o con algunos m\u00e9todos de conveniencia cuyo funcionamiento se mostrar\u00e1.</p>"},{"location":"3_Construccion_Operaciones/#construccion-manual","title":"Construcci\u00f3n Manual","text":"<p>Se ver\u00e1 como construir un <code>Leg</code> con 2 <code>SimpleCashflow</code> de forma manual. En particular, este objeto <code>Leg</code> podr\u00eda representar una operaci\u00f3n FX por entrega f\u00edsica.</p> <p>Primero se construye dos objetos de tipo <code>SimpleCashflow</code>:</p> <pre><code>fecha_vencimiento = qcf.QCDate(23, 9, 2024)\n\nsimple_cashflow_1 = qcf.SimpleCashflow(\n    fecha_vencimiento,    # fecha del flujo\n    1_000,         # monto\n    qcf.QCUSD()    # moneda\n) \n\nsimple_cashflow_2 = qcf.SimpleCashflow(\n    fecha_vencimiento,    # fecha del flujo\n    -900_000,      # monto\n    qcf.QCCLP())   # moneda\n</code></pre> <p>Con esto, se construye un objeto de tipo <code>Leg</code>. En este momento el objeto est\u00e1 vac\u00edo.</p> <pre><code>leg = qcf.Leg()\n</code></pre> <pre><code>leg.size()\n</code></pre> <pre><code>0\n</code></pre> <p>Agregamos los dos cashflows.</p> <pre><code>leg.append_cashflow(simple_cashflow_1)\nleg.append_cashflow(simple_cashflow_2)\n</code></pre> <p>Se observa el resultado (usamos la funci\u00f3n del m\u00f3dulo <code>aux_functions</code> que a su vez depende del m\u00e9todo <code>show</code>).</p> <pre><code>df = aux.leg_as_dataframe(leg)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_pago monto moneda 0 2024-09-23 1,000.00 USD 1 2024-09-23 -900,000.00 CLP <p>Agregar todo tipo de cashflows a un mismo objeto <code>Leg</code> entrega mucha flexibilidad para construir operaciones con estructuras complicadas. Partiremos, sin embargo, explicando como construir objetos <code>Leg</code> a partir de cashflows del mismo tipo.</p>"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-fixedrateleg","title":"Construcci\u00f3n Asistida de un <code>FixedRateLeg</code>","text":"<p>Se ver\u00e1 como construir objetos <code>Leg</code> donde cada <code>Cashflow</code> es un objeto de tipo <code>FixedRateCashflow</code>, todos con la misma tasa fija. En el primer ejemplo se construye un <code>Leg</code> de tipo bullet: una \u00fanica amortizaci\u00f3n igual al capital vigente de todos los <code>FixedRateCasflow</code> en el \u00faltimo flujo.</p> <p>Se requieren los siguientes par\u00e1metros, los cuales permitir\u00e1n construir las variedades m\u00e1s comunes de <code>FixedRateLeg</code>, entre las cuales est\u00e1n las utilizadas en las operaciones est\u00e1ndar de mercado.</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados (FOLLOW, MOD_FOLLOW)</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para los ajustes de fechas y fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal inicial</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal y de los flujos</li> <li><code>bool</code>: si es <code>True</code> fuerza a que las fechas de pago coincidan con las fechas finales. Esto para lograr una valorizaci\u00f3n acorde a las convenciones de los mercados de renta fija, en caso que la <code>Leg</code> represente un bono a tasa fija.</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo y no se ha definido un ajuste en las fechas finales. Las alternativas son dos, se calcula sumando el <code>settlement_lag</code> desde <code>end_date</code> o se calcula sumando <code>settlement_lag</code> a partir de la primera fecha h\u00e1bil posterior a <code>end_date</code>.</li> </ul> <p>El par\u00e1metro <code>SettLagBehaviour</code> se agreg\u00f3 en la versi\u00f3n 0.11.0 .</p> <p>Vamos a un ejemplo.</p> <p>Se da de alta los par\u00e1metros requeridos</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(29, 7, 2024)\nfecha_final = qcf.QCDate(29, 7, 2026)\nbus_adj_rule = qcf.BusyAdjRules.FOLLOW\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\ncalendario = aux.get_business_calendar('CL', range(2024, 2027))  # Se apoya en holidays\nlag_pago = 0\nnominal = 100_000_000.0\namort_es_flujo = True\nvalor_tasa = .05\ntasa_cupon = qcf.QCInterestRate(valor_tasa, qcf.QCAct360(), qcf.QCLinearWf())\nmoneda = qcf.QCCLP()\nes_bono = False\n</code></pre> <p>Este argumento tiene como valor por default <code>qcf.SettLagBehaviour.DONT_MOVE</code>. Aqu\u00ed, por claridad, se define expl\u00edcitamente.</p> <pre><code>sett_lag_behaviour = qcf.SettLagBehaviour.DONT_MOVE\n</code></pre> <p>Se da de alta el objeto.</p> <pre><code>fixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <p>Como en el cap\u00edtulo anterior, se puede lograr una muy buena visualizaci\u00f3n del resultado utilizando un <code>pandas.Dataframe</code> de pandas y el m\u00e9todo <code>show</code>.</p> <pre><code>df = aux.leg_as_dataframe(fixed_rate_leg)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-07-29 2025-01-29 2025-01-29 100,000,000.00 0.00 2,555,555.56 True 2,555,555.56 CLP 5.0000% LinAct360 1 2025-01-29 2025-07-29 2025-07-29 100,000,000.00 0.00 2,513,888.89 True 2,513,888.89 CLP 5.0000% LinAct360 2 2025-07-29 2026-01-29 2026-01-29 100,000,000.00 0.00 2,555,555.56 True 2,555,555.56 CLP 5.0000% LinAct360 3 2026-01-29 2026-07-29 2026-07-29 100,000,000.00 100,000,000.00 2,513,888.89 True 102,513,888.89 CLP 5.0000% LinAct360"},{"location":"3_Construccion_Operaciones/#otros-stubperiod","title":"Otros <code>StubPeriod</code>","text":"<p>Per\u00edodo irregular corto al inicio (<code>qcf.StubPeriod.SHORTFRONT</code>)</p> <pre><code>fecha_final = fecha_inicio.add_months(27)\nperiodo_irregular = qcf.StubPeriod.SHORTFRONT\n\nfixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <pre><code>df = aux.leg_as_dataframe(fixed_rate_leg)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-07-29 2024-10-29 2024-10-29 100,000,000.00 0.00 1,277,777.78 True 1,277,777.78 CLP 5.0000% LinAct360 1 2024-10-29 2025-04-29 2025-04-29 100,000,000.00 0.00 2,527,777.78 True 2,527,777.78 CLP 5.0000% LinAct360 2 2025-04-29 2025-10-29 2025-10-29 100,000,000.00 0.00 2,541,666.67 True 2,541,666.67 CLP 5.0000% LinAct360 3 2025-10-29 2026-04-29 2026-04-29 100,000,000.00 0.00 2,527,777.78 True 2,527,777.78 CLP 5.0000% LinAct360 4 2026-04-29 2026-10-29 2026-10-29 100,000,000.00 100,000,000.00 2,541,666.67 True 102,541,666.67 CLP 5.0000% LinAct360 <p>Per\u00edodo irregular corto al final (<code>qcf.StubPeriod.SHORTBACK</code>)</p> <pre><code>periodo_irregular = qcf.StubPeriod.SHORTBACK\n\nfixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <pre><code>df = aux.leg_as_dataframe(fixed_rate_leg)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-07-29 2025-01-29 2025-01-29 100,000,000.00 0.00 2,555,555.56 True 2,555,555.56 CLP 5.0000% LinAct360 1 2025-01-29 2025-07-29 2025-07-29 100,000,000.00 0.00 2,513,888.89 True 2,513,888.89 CLP 5.0000% LinAct360 2 2025-07-29 2026-01-29 2026-01-29 100,000,000.00 0.00 2,555,555.56 True 2,555,555.56 CLP 5.0000% LinAct360 3 2026-01-29 2026-07-29 2026-07-29 100,000,000.00 0.00 2,513,888.89 True 2,513,888.89 CLP 5.0000% LinAct360 4 2026-07-29 2026-10-29 2026-10-29 100,000,000.00 100,000,000.00 1,277,777.78 True 101,277,777.78 CLP 5.0000% LinAct360 <p>Per\u00edodo irregular largo al principio (<code>qcf.StubPeriod.LONGFRONT</code>)</p> <pre><code>periodo_irregular = qcf.StubPeriod.LONGFRONT\n\nfixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <pre><code>df = aux.leg_as_dataframe(fixed_rate_leg)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-07-29 2025-04-29 2025-04-29 100,000,000.00 0.00 3,805,555.56 True 3,805,555.56 CLP 5.0000% LinAct360 1 2025-04-29 2025-10-29 2025-10-29 100,000,000.00 0.00 2,541,666.67 True 2,541,666.67 CLP 5.0000% LinAct360 2 2025-10-29 2026-04-29 2026-04-29 100,000,000.00 0.00 2,527,777.78 True 2,527,777.78 CLP 5.0000% LinAct360 3 2026-04-29 2026-10-29 2026-10-29 100,000,000.00 100,000,000.00 2,541,666.67 True 102,541,666.67 CLP 5.0000% LinAct360 <p>Per\u00edodo irregular largo al final (<code>qcf.StubPeriod.LONGBACK</code>)</p> <pre><code>periodo_irregular = qcf.StubPeriod.LONGBACK\n\nfixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <pre><code>df = aux.leg_as_dataframe(fixed_rate_leg)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-07-29 2025-01-29 2025-01-29 100,000,000.00 0.00 2,555,555.56 True 2,555,555.56 CLP 5.0000% LinAct360 1 2025-01-29 2025-07-29 2025-07-29 100,000,000.00 0.00 2,513,888.89 True 2,513,888.89 CLP 5.0000% LinAct360 2 2025-07-29 2026-01-29 2026-01-29 100,000,000.00 0.00 2,555,555.56 True 2,555,555.56 CLP 5.0000% LinAct360 3 2026-01-29 2026-10-29 2026-10-29 100,000,000.00 100,000,000.00 3,791,666.67 True 103,791,666.67 CLP 5.0000% LinAct360 <p>Per\u00edodo de gracia, usual en la cobertura de cr\u00e9ditos (<code>qcf.StubPeriod.LONGFRONT3</code>)</p> <pre><code>fecha_final = fecha_inicio.add_months(12 * 5)  # Swap de 5Y\nperiodo_irregular = qcf.StubPeriod.LONGFRONT3  # Una de varias opciones parecidas para alargar el primer per\u00edodo de intereses\n\nfixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <pre><code>df = aux.leg_as_dataframe(fixed_rate_leg)\ndf.style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-07-29 2026-01-29 2026-01-29 100,000,000.00 0.00 7,625,000.00 True 7,625,000.00 CLP 5.0000% LinAct360 1 2026-01-29 2026-07-29 2026-07-29 100,000,000.00 0.00 2,513,888.89 True 2,513,888.89 CLP 5.0000% LinAct360 2 2026-07-29 2027-01-29 2027-01-29 100,000,000.00 0.00 2,555,555.56 True 2,555,555.56 CLP 5.0000% LinAct360 3 2027-01-29 2027-07-29 2027-07-29 100,000,000.00 0.00 2,513,888.89 True 2,513,888.89 CLP 5.0000% LinAct360 4 2027-07-29 2028-01-31 2028-01-31 100,000,000.00 0.00 2,583,333.33 True 2,583,333.33 CLP 5.0000% LinAct360 5 2028-01-31 2028-07-31 2028-07-31 100,000,000.00 0.00 2,527,777.78 True 2,527,777.78 CLP 5.0000% LinAct360 6 2028-07-31 2029-01-29 2029-01-29 100,000,000.00 0.00 2,527,777.78 True 2,527,777.78 CLP 5.0000% LinAct360 7 2029-01-29 2029-07-30 2029-07-30 100,000,000.00 100,000,000.00 2,527,777.78 True 102,527,777.78 CLP 5.0000% LinAct360"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-customamortfixedrateleg","title":"Construcci\u00f3n Asistida de un <code>CustomAmortFixedRateLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con cashflows a tasa fija donde la estructura de amortizaciones es customizada. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>CustomNotionalAndAmort</code>: vector de capital vigente y amortizaciones customizado</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal y de los flujos</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> </ul> <p>Notar que este tipo de <code>Leg</code> no admite el par\u00e1metro <code>is_bond</code>. Se puede lograr el mismo efecto construyendo una pata bullet y luego customizando su amortizaci\u00f3n.</p> <p>Vamos a un ejemplo.</p> <p>Primero se da de alta los par\u00e1metros requeridos</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 2024)\nfecha_final = qcf.QCDate(31, 1, 2028) \n\ncalendario = aux.get_business_calendar('US', range(2024, 2027))\nbus_adj_rule = qcf.BusyAdjRules.NO\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\nlag_pago = 1\n\namort_es_flujo = True\nvalor_tasa = .05\ntasa_cupon = qcf.QCInterestRate(\n    valor_tasa, \n    qcf.QC30360(), \n    qcf.QCLinearWf()\n)\n\nmoneda = qcf.QCCLP()\nsett_lag_behaviour = qcf.SettLagBehaviour.DONT_MOVE\n</code></pre> <p>Aqu\u00ed se da de alta el vector de capitales vigentes y amortizaciones. Cada elemento del vector es una tupla que continen el capital vigente y amortizaci\u00f3n del correspondiente cup\u00f3n.</p> <pre><code>custom_notional_amort = qcf.CustomNotionalAmort()\ncustom_notional_amort.set_size(8)  # De la fecha inicio, fecha final y periodicidad se deduce que ser\u00e1n 8 cupones\nfor i in range(0, 8):\n    custom_notional_amort.set_notional_amort_at(i, 800.0 - i * 100.0, 100.0)\n</code></pre> <p>Se da de alta el objeto.</p> <pre><code>fixed_rate_custom_leg = qcf.LegFactory.build_custom_amort_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    notional_and_amort=custom_notional_amort,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <pre><code>df = aux.leg_as_dataframe(fixed_rate_custom_leg)\ndf.style.format(aux.format_dict).set_properties(\n    **{'background-color': '#FFCFC9', 'color':'black'},\n    subset=['nocional','amortizacion', 'flujo']\n).set_properties(\n    **{'background-color': '#FFCFA9', 'color':'black'},\n    subset=['flujo']\n)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-01-31 2024-07-31 2024-08-01 800.00 100.00 20.00 True 120.00 CLP 5.0000% Lin30360 1 2024-07-31 2025-01-31 2025-02-03 700.00 100.00 17.50 True 117.50 CLP 5.0000% Lin30360 2 2025-01-31 2025-07-31 2025-08-01 600.00 100.00 15.00 True 115.00 CLP 5.0000% Lin30360 3 2025-07-31 2026-01-31 2026-02-02 500.00 100.00 12.50 True 112.50 CLP 5.0000% Lin30360 4 2026-01-31 2026-07-31 2026-08-03 400.00 100.00 10.00 True 110.00 CLP 5.0000% Lin30360 5 2026-07-31 2027-01-31 2027-02-01 300.00 100.00 7.50 True 107.50 CLP 5.0000% Lin30360 6 2027-01-31 2027-07-31 2027-08-02 200.00 100.00 5.00 True 105.00 CLP 5.0000% Lin30360 7 2027-07-31 2028-01-31 2028-02-01 100.00 100.00 2.50 True 102.50 CLP 5.0000% Lin30360"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-fixedratemulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>FixedRateMultiCurrencyLeg</code>","text":"<p>Se ver\u00e1 como construir objetos <code>Leg</code> donde cada <code>Cashflow</code> es un objeto de tipo <code>FixedRateMultiCurrencyCashflow</code>, todos con la misma tasa fija. En el primer ejemplo se construye un <code>Leg</code> de tipo bullet: una \u00fanica amortizaci\u00f3n igual al capital vigente de todos los <code>FixedRateMultiCurrencyCasflow</code> en el \u00faltimo flujo. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal inicial</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal</li> <li><code>bool</code>: si es <code>True</code> fuerza a que las fechas de pago coincidan con las fechas finales. Esto para lograr una valorizaci\u00f3n acorde a las convenciones de los mercados de renta fija, en caso que la <code>Leg</code> represente un bono a tasa fija.</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> </ul> <p>MultiCurrency - <code>QCCurrency</code>: moneda de los flujos - <code>FXRateIndex</code>: \u00edndice con el cual se transforma cada flujo a la moneda de pago. - <code>unsigned int</code>: lag de fijaci\u00f3n del valor del \u00edndice de tipo de cambio. - <code>FxFixingLagPivot</code>: este par\u00e1metro indica si el lag de fijaci\u00f3n del \u00edndice FX se aplica sobre <code>end_date</code> o sobre <code>settlement_date</code>. - <code>FxFixingLagAppliesTo</code>: indica si el lag se refiere a <code>FIXING_DATE</code> o <code>PUBISHING_DATE</code> del \u00edndice.</p> <p>Vamos a un ejemplo.</p> <p>Primero se debe dar de alta un FXRateIndex</p> <pre><code>scl = aux.get_business_calendar('CL', range(2024, 2031))\nny = aux.get_business_calendar('US', range(2024, 2031))\nscl_ny = scl + ny\n\nusd = qcf.QCUSD()\nclp = qcf.QCCLP()\nusdclp = qcf.FXRate(usd, clp)\none_d = qcf.Tenor('1D')\nusdclp_obs = qcf.FXRateIndex(\n    usdclp, \n    'USDOBS', # Vamos a suponer que es el D\u00f3lar Observado\n    one_d, \n    one_d, \n    scl,  # Es Santiago\n)\n</code></pre> <p>Luego se dan de alta los otros par\u00e1metros requeridos para la construcci\u00f3n</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(17, 7, 2024)\n</code></pre> <p>Vamos a aplicar un truco para el c\u00e1lculo de la fecha final. Se define el plazo de la pata con un objeto de tipo <code>qcf.Tenor</code>.</p> <pre><code>plazo = qcf.Tenor(\"6Y\")\nfecha_final = fecha_inicio.add_months(plazo.get_years() * 12 + plazo.get_months())\nprint(f\"Fecha final: {fecha_final}\")\n</code></pre> <pre><code>Fecha final: 2030-07-17\n</code></pre> <p>Vamos con el resto de par\u00e1metros.</p> <pre><code>bus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\nlag_pago = 1\n\nvalor_tasa = .03\ntasa_cupon = qcf.QCInterestRate(\n    valor_tasa, \n    qcf.QC30360(), \n    qcf.QCLinearWf()\n)\nes_bono = False\nlag_pago = 0\nsett_lag_behaviour = qcf.SettLagBehaviour.DONT_MOVE\n\nfx_rate_index_fixing_lag = 2  # lag de fijaci\u00f3n del \u00edndice FX\nfx_fixing_lag_pivot = qcf.FxFixingLagPivot.END_DATE\nfx_fixing_lag_applies_to = qcf.FxFixingLagAppliesTo.FIXING_DATE\n</code></pre> <p>Finalmente, se da de alta el objeto.</p> <pre><code>fixed_rate_mccy_leg = qcf.LegFactory.build_bullet_fixed_rate_mccy_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=scl_ny,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=usd,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n    # Par\u00e1metros MultiCurrency\n    settlement_currency=clp,\n    fx_rate_index=usdclp_obs,\n    fx_rate_index_fixing_lag=fx_rate_index_fixing_lag,\n    fx_fixing_lag_pivot=fx_fixing_lag_pivot,\n    fx_fixing_lag_applies_to=fx_fixing_lag_applies_to\n)\n</code></pre> <pre><code>scl_ny.shift(qcf.QCDate(\"2025-07-17\"), -fx_rate_index_fixing_lag)\n</code></pre> <pre><code>2025-07-14\n</code></pre> <p>Visualizaci\u00f3n.</p> <pre><code>df = aux.leg_as_dataframe(fixed_rate_mccy_leg)\ndf.style.format(aux.format_dict).set_properties(\n    **{'background-color': '#FFCFC9', 'color':'black'},\n    subset=['fecha_pago',]\n).set_properties(\n    **{'background-color': '#FFCFA9', 'color':'black'},\n    subset=['fecha_fixing_fx']\n)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa fecha_fixing_fx moneda_pago indice_fx valor_indice_fx amortizacion_moneda_pago interes_moneda_pago 0 2024-07-17 2025-01-17 2025-01-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2025-01-16 CLP USDOBS 1.00 0.00 1,500,000.00 1 2025-01-17 2025-07-17 2025-07-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2025-07-15 CLP USDOBS 1.00 0.00 1,500,000.00 2 2025-07-17 2026-01-20 2026-01-20 100,000,000.00 0.00 1,525,000.00 True 1,525,000.00 USD 3.0000% Lin30360 2026-01-16 CLP USDOBS 1.00 0.00 1,525,000.00 3 2026-01-20 2026-07-17 2026-07-17 100,000,000.00 0.00 1,475,000.00 True 1,475,000.00 USD 3.0000% Lin30360 2026-07-15 CLP USDOBS 1.00 0.00 1,475,000.00 4 2026-07-17 2027-01-19 2027-01-19 100,000,000.00 0.00 1,516,666.67 True 1,516,666.67 USD 3.0000% Lin30360 2027-01-15 CLP USDOBS 1.00 0.00 1,516,666.67 5 2027-01-19 2027-07-19 2027-07-19 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2027-07-15 CLP USDOBS 1.00 0.00 1,500,000.00 6 2027-07-19 2028-01-18 2028-01-18 100,000,000.00 0.00 1,491,666.67 True 1,491,666.67 USD 3.0000% Lin30360 2028-01-14 CLP USDOBS 1.00 0.00 1,491,666.67 7 2028-01-18 2028-07-17 2028-07-17 100,000,000.00 0.00 1,491,666.67 True 1,491,666.67 USD 3.0000% Lin30360 2028-07-14 CLP USDOBS 1.00 0.00 1,491,666.67 8 2028-07-17 2029-01-17 2029-01-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2029-01-15 CLP USDOBS 1.00 0.00 1,500,000.00 9 2029-01-17 2029-07-17 2029-07-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2029-07-13 CLP USDOBS 1.00 0.00 1,500,000.00 10 2029-07-17 2030-01-17 2030-01-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2030-01-16 CLP USDOBS 1.00 0.00 1,500,000.00 11 2030-01-17 2030-07-17 2030-07-17 100,000,000.00 100,000,000.00 1,500,000.00 True 101,500,000.00 USD 3.0000% Lin30360 2030-07-15 CLP USDOBS 1.00 100,000,000.00 1,500,000.00 <p>Veamos el efecto de cambiar la opci\u00f3n <code>fix_fixing_lag_pivot</code>.</p> <pre><code>fx_fixing_lag_pivot = qcf.FxFixingLagPivot.END_DATE\n\nfixed_rate_mccy_leg = qcf.LegFactory.build_bullet_fixed_rate_mccy_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=usd,\n    settlement_currency=clp,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n    # Par\u00e1metros MultiCurrency\n    fx_rate_index=usdclp_obs,\n    fx_rate_index_fixing_lag=fx_rate_index_fixing_lag,\n    fx_fixing_lag_pivot=fx_fixing_lag_pivot,\n)\n</code></pre> <pre><code>df = aux.leg_as_dataframe(fixed_rate_mccy_leg)\ndf.style.format(aux.format_dict).set_properties(\n    **{'background-color': '#FFCFC9', 'color':'black'},\n    subset=['fecha_final',]\n).set_properties(\n    **{'background-color': '#FFCFA9', 'color':'black'},\n    subset=['fecha_fixing_fx']\n)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa fecha_fixing_fx moneda_pago indice_fx valor_indice_fx amortizacion_moneda_pago interes_moneda_pago 0 2024-07-17 2025-01-17 2025-01-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2025-01-15 CLP USDOBS 1.00 0.00 1,500,000.00 1 2025-01-17 2025-07-17 2025-07-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2025-07-15 CLP USDOBS 1.00 0.00 1,500,000.00 2 2025-07-17 2026-01-20 2026-01-20 100,000,000.00 0.00 1,525,000.00 True 1,525,000.00 USD 3.0000% Lin30360 2026-01-15 CLP USDOBS 1.00 0.00 1,525,000.00 3 2026-01-20 2026-07-17 2026-07-17 100,000,000.00 0.00 1,475,000.00 True 1,475,000.00 USD 3.0000% Lin30360 2026-07-15 CLP USDOBS 1.00 0.00 1,475,000.00 4 2026-07-17 2027-01-18 2027-01-18 100,000,000.00 0.00 1,508,333.33 True 1,508,333.33 USD 3.0000% Lin30360 2027-01-14 CLP USDOBS 1.00 0.00 1,508,333.33 5 2027-01-18 2027-07-19 2027-07-19 100,000,000.00 0.00 1,508,333.33 True 1,508,333.33 USD 3.0000% Lin30360 2027-07-15 CLP USDOBS 1.00 0.00 1,508,333.33 6 2027-07-19 2028-01-17 2028-01-17 100,000,000.00 0.00 1,483,333.33 True 1,483,333.33 USD 3.0000% Lin30360 2028-01-13 CLP USDOBS 1.00 0.00 1,483,333.33 7 2028-01-17 2028-07-17 2028-07-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2028-07-13 CLP USDOBS 1.00 0.00 1,500,000.00 8 2028-07-17 2029-01-17 2029-01-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2029-01-15 CLP USDOBS 1.00 0.00 1,500,000.00 9 2029-01-17 2029-07-17 2029-07-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2029-07-13 CLP USDOBS 1.00 0.00 1,500,000.00 10 2029-07-17 2030-01-17 2030-01-17 100,000,000.00 0.00 1,500,000.00 True 1,500,000.00 USD 3.0000% Lin30360 2030-01-15 CLP USDOBS 1.00 0.00 1,500,000.00 11 2030-01-17 2030-07-17 2030-07-17 100,000,000.00 100,000,000.00 1,500,000.00 True 101,500,000.00 USD 3.0000% Lin30360 2030-07-15 CLP USDOBS 1.00 100,000,000.00 1,500,000.00"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-customamortfixedratemulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>CustomAmortFixedRateMultiCurrencyLeg</code>","text":"<p>Se ver\u00e1 como construir objetos <code>Leg</code> donde cada <code>Cashflow</code> es un objeto de tipo <code>FixedRateMultiCurrencyCashflow</code>, todos con la misma tasa fija. En este ejemplo se construye un <code>Leg</code> de tipo custom_amort: amortizaciones irregulares en cada <code>FixedRateMultiCurrencyCasflow</code>. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal inicial</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal</li> <li><code>QCCurrency</code>: moneda de los flujos</li> <li><code>FXRateIndex</code>: \u00edndice con el cual se transforma cada flujo a la moneda de pago.</li> <li><code>bool</code>: si es <code>True</code> fuerza a que las fechas de pago coincidan con las fechas finales. Esto para lograr una valorizaci\u00f3n acorde a las convenciones de los mercados de renta fija, en caso que la <code>Leg</code> represente un bono a tasa fija.</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> <li><code>FxFixingLagPivot</code>: este par\u00e1metro indica si el lag de fijaci\u00f3n del \u00edndice FX se aplica sobre <code>end_date</code> o sobre <code>settlement_date</code>.</li> </ul> <p>Vamos a un ejemplo</p> <p>Primero se debe dar de alta un FXRateIndex</p> <pre><code>usd = qcf.QCUSD()\nclp = qcf.QCCLP()\nusdclp = qcf.FXRate(usd, clp)\none_d = qcf.Tenor('1D')\nusdclp_obs = qcf.FXRateIndex(\n    usdclp, \n    'USDOBS', \n    one_d, \n    one_d, \n    calendario\n)\n</code></pre> <p>Luego se dan de alta los otros par\u00e1metros requeridos para la construcci\u00f3n</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(12, 7, 1968)\nfecha_final = qcf.QCDate(12, 7, 1974) \nbus_adj_rule = qcf.BusyAdjRules.NO\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\nlag_pago = 1\nes_bono = False\nfx_rate_index_fixing_lag = 1\nfx_fixing_lag_pivot = qcf.FxFixingLagPivot.SETTLEMENT_DATE\nsett_lag_behaviour = qcf.SettLagBehaviour.DONT_MOVE\n</code></pre> <p>Se da de alta el vector de capitales vigentes y amortizaciones. Cada elemento del vector es el capital vigente y amortizaci\u00f3n del correspondiente cup\u00f3n.</p> <pre><code>custom_notional_amort = qcf.CustomNotionalAmort()\ncustom_notional_amort.set_size(12)  # De la fecha inicio y fecha final se deduce que ser\u00e1n 8 cupones\nfor i in range(0, 12):\n    custom_notional_amort.set_notional_amort_at(i, 1200.0 - i * 100.0, 100.0)\n</code></pre> <p>Finalmente, se da de alta el objeto.</p> <pre><code>fixed_rate_mccy_leg = qcf.LegFactory.build_custom_amort_fixed_rate_mccy_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    settlement_stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    notional_and_amort=custom_notional_amort,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=usd,\n    is_bond=es_bono,\n    sett_lag_behaviour=sett_lag_behaviour,\n    # Par\u00e1metros MultiCurrency\n    settlement_currency=clp,\n    fx_rate_index=usdclp_obs,\n    fx_rate_index_fixing_lag=fx_rate_index_fixing_lag,\n    fx_fixing_lag_pivot=fx_fixing_lag_pivot,\n)\n</code></pre> <p>Visualizaci\u00f3n.</p> <pre><code>aux.leg_as_dataframe(fixed_rate_mccy_leg).style.format(aux.format_dict).set_properties(\n    **{'background-color': '#FFCFC9', 'color':'black'},\n    subset=['nominal','amortizacion', 'flujo']\n).set_properties(\n    **{'background-color': '#FFCFA9', 'color':'black'},\n    subset=['flujo']\n)\n</code></pre> <pre><code>---------------------------------------------------------------------------\n\nKeyError                                  Traceback (most recent call last)\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/IPython/core/formatters.py:406, in BaseFormatter.__call__(self, obj)\n    404     method = get_real_method(obj, self.print_method)\n    405     if method is not None:\n--&gt; 406         return method()\n    407     return None\n    408 else:\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/io/formats/style.py:405, in Styler._repr_html_(self)\n    400 \"\"\"\n    401 Hooks into Jupyter notebook rich display system, which calls _repr_html_ by\n    402 default if an object is returned at the end of a cell.\n    403 \"\"\"\n    404 if get_option(\"styler.render.repr\") == \"html\":\n--&gt; 405     return self.to_html()\n    406 return None\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/io/formats/style.py:1345, in Styler.to_html(self, buf, table_uuid, table_attributes, sparse_index, sparse_columns, bold_headers, caption, max_rows, max_columns, encoding, doctype_html, exclude_styles, **kwargs)\n   1342     obj.set_caption(caption)\n   1344 # Build HTML string..\n-&gt; 1345 html = obj._render_html(\n   1346     sparse_index=sparse_index,\n   1347     sparse_columns=sparse_columns,\n   1348     max_rows=max_rows,\n   1349     max_cols=max_columns,\n   1350     exclude_styles=exclude_styles,\n   1351     encoding=encoding or get_option(\"styler.render.encoding\"),\n   1352     doctype_html=doctype_html,\n   1353     **kwargs,\n   1354 )\n   1356 return save_to_buffer(\n   1357     html, buf=buf, encoding=(encoding if buf is not None else None)\n   1358 )\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/io/formats/style_render.py:204, in StylerRenderer._render_html(self, sparse_index, sparse_columns, max_rows, max_cols, **kwargs)\n    192 def _render_html(\n    193     self,\n    194     sparse_index: bool,\n   (...)    198     **kwargs,\n    199 ) -&gt; str:\n    200     \"\"\"\n    201     Renders the ``Styler`` including all applied styles to HTML.\n    202     Generates a dict with necessary kwargs passed to jinja2 template.\n    203     \"\"\"\n--&gt; 204     d = self._render(sparse_index, sparse_columns, max_rows, max_cols, \"&amp;nbsp;\")\n    205     d.update(kwargs)\n    206     return self.template_html.render(\n    207         **d,\n    208         html_table_tpl=self.template_html_table,\n    209         html_style_tpl=self.template_html_style,\n    210     )\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/io/formats/style_render.py:161, in StylerRenderer._render(self, sparse_index, sparse_columns, max_rows, max_cols, blank)\n    147 def _render(\n    148     self,\n    149     sparse_index: bool,\n   (...)    153     blank: str = \"\",\n    154 ):\n    155     \"\"\"\n    156     Computes and applies styles and then generates the general render dicts.\n    157 \n    158     Also extends the `ctx` and `ctx_index` attributes with those of concatenated\n    159     stylers for use within `_translate_latex`\n    160     \"\"\"\n--&gt; 161     self._compute()\n    162     dxs = []\n    163     ctx_len = len(self.index)\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/io/formats/style_render.py:256, in StylerRenderer._compute(self)\n    254 r = self\n    255 for func, args, kwargs in self._todo:\n--&gt; 256     r = func(self)(*args, **kwargs)\n    257 return r\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/io/formats/style.py:2027, in Styler._map(self, func, subset, **kwargs)\n   2025     subset = IndexSlice[:]\n   2026 subset = non_reducing_slice(subset)\n-&gt; 2027 result = self.data.loc[subset].map(func)\n   2028 self._update_ctx(result)\n   2029 return self\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n   1182     if self._is_scalar_access(key):\n   1183         return self.obj._get_value(*key, takeable=self._takeable)\n-&gt; 1184     return self._getitem_tuple(key)\n   1185 else:\n   1186     # we by definition only have the 0th axis\n   1187     axis = self.axis or 0\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)\n   1374 if self._multi_take_opportunity(tup):\n   1375     return self._multi_take(tup)\n-&gt; 1377 return self._getitem_tuple_same_dim(tup)\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)\n   1017 if com.is_null_slice(key):\n   1018     continue\n-&gt; 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n   1021 # We should never have retval.ndim &lt; self.ndim, as that should\n   1022 #  be handled by the _getitem_lowerdim call above.\n   1023 assert retval.ndim == self.ndim\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/core/indexing.py:1420, in _LocIndexer._getitem_axis(self, key, axis)\n   1417     if hasattr(key, \"ndim\") and key.ndim &gt; 1:\n   1418         raise ValueError(\"Cannot index with multidimensional key\")\n-&gt; 1420     return self._getitem_iterable(key, axis=axis)\n   1422 # nested tuple slicing\n   1423 if is_nested_tuple(key, labels):\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/core/indexing.py:1360, in _LocIndexer._getitem_iterable(self, key, axis)\n   1357 self._validate_key(key, axis)\n   1359 # A collection of keys\n-&gt; 1360 keyarr, indexer = self._get_listlike_indexer(key, axis)\n   1361 return self.obj._reindex_with_indexers(\n   1362     {axis: [keyarr, indexer]}, copy=True, allow_dups=True\n   1363 )\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/core/indexing.py:1558, in _LocIndexer._get_listlike_indexer(self, key, axis)\n   1555 ax = self.obj._get_axis(axis)\n   1556 axis_name = self.obj._get_axis_name(axis)\n-&gt; 1558 keyarr, indexer = ax._get_indexer_strict(key, axis_name)\n   1560 return keyarr, indexer\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/core/indexes/base.py:6212, in Index._get_indexer_strict(self, key, axis_name)\n   6209 else:\n   6210     keyarr, indexer, new_indexer = self._reindex_non_unique(keyarr)\n-&gt; 6212 self._raise_if_missing(keyarr, indexer, axis_name)\n   6214 keyarr = self.take(indexer)\n   6215 if isinstance(key, Index):\n   6216     # GH 42790 - Preserve name from an Index\n\n\nFile ~/qcf_repos/qcfinancial-docs/.venv/lib/python3.12/site-packages/pandas/core/indexes/base.py:6264, in Index._raise_if_missing(self, key, indexer, axis_name)\n   6261     raise KeyError(f\"None of [{key}] are in the [{axis_name}]\")\n   6263 not_found = list(ensure_index(key)[missing_mask.nonzero()[0]].unique())\n-&gt; 6264 raise KeyError(f\"{not_found} not in index\")\n\n\nKeyError: \"['nominal'] not in index\"\n\n\n\n\n\n&lt;pandas.io.formats.style.Styler at 0x112f76480&gt;\n</code></pre>"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-bulletiborleg","title":"Construcci\u00f3n Asistida de un <code>BulletIborLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>IborCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>Tenor</code>: periodicidad de fijaci\u00f3n</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular para el calendario de fijaciones</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n</li> <li><code>unsigned int</code>: lag de fijaci\u00f3n expresado en d\u00edas</li> <li><code>InterestRateIndex</code>: \u00edndice de tasa de inter\u00e9s utilizado en cada <code>IborCashflow</code></li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>QCCurrency</code>: moneda del nominal y de los flujos</li> <li><code>float</code>: spread aditivo</li> <li><code>gearing</code>: spread multiplicativo (tasa * gearing + spread)</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> </ul> <p>NOTA: para construir un <code>Leg</code> con <code>IborCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_ibor_leg(...)</code>.</p> <p>Vamos a un ejemplo. Primero, se da de alta los par\u00e1metros requeridos. </p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(15, 2, 2024)\nfecha_final = qcf.QCDate(15, 2, 2026) \nbus_adj_rule = qcf.BusyAdjRules.NO\nperiodicidad_pago = qcf.Tenor('3M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = aux.get_business_calendar('US', range(2024, 2035))\nlag_pago = 1\nperiodicidad_fijacion = qcf.Tenor('3M')\nperiodo_irregular_fijacion = qcf.StubPeriod.NO\nsett_lag_behaviour = qcf.SettLagBehaviour.MOVE_TO_WORKING_DAY\n\n# Se utilizar\u00e1 el mismo calendario para pago y fijaciones\nlag_de_fijacion = 2\n\nnominal = 1_000_000.0\namort_es_flujo = True \nmoneda = usd\nspread = .01\ngearing = 1.0\n</code></pre> <p>Se define el \u00edndice de tasa de inter\u00e9s.</p> <pre><code>codigo = 'TERMSOFR3M'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('2d')\ntenor = qcf.Tenor('3m')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\ntermsofr_3m = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    calendario,\n    calendario,\n    usd\n)\n</code></pre> <p>Se da de alta el objeto, pero antes almacenaremos los par\u00e1metros en un <code>dict</code>. Esto permitir\u00e1 una sintaxis un poco m\u00e1s liviana.</p> <pre><code>params = dict(\n    rec_pay=rp, \n    start_date=fecha_inicio, \n    end_date=fecha_final, \n    bus_adj_rule=bus_adj_rule, \n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago, \n    settlement_calendar=calendario, \n    settlement_lag=lag_pago,\n    fixing_periodicity=periodicidad_fijacion, \n    fixing_stub_period=periodo_irregular_fijacion,\n    fixing_calendar=calendario, \n    fixing_lag=lag_de_fijacion, \n    interest_rate_index=termsofr_3m,\n    initial_notional=nominal, \n    amort_is_cashflow=amort_es_flujo, \n    notional_currency=moneda, \n    spread=spread, \n    gearing=gearing,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <pre><code>ibor_leg = qcf.LegFactory.build_bullet_ibor_leg(**params)\n</code></pre> <p>Visualizaci\u00f3n. Notar que los flujos de intereses corresponden al spread de 1%. No est\u00e1n fijados los valores del \u00edndice en cada cup\u00f3n.</p> <pre><code>aux.leg_as_dataframe(ibor_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2024-02-15 2024-05-15 2024-02-13 2024-05-16 1,000,000.00 0.00 2,500.00 True 2,500.00 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 1 2024-05-15 2024-08-15 2024-05-13 2024-08-16 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 2 2024-08-15 2024-11-15 2024-08-13 2024-11-18 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 3 2024-11-15 2025-02-15 2024-11-13 2025-02-19 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 4 2025-02-15 2025-05-15 2025-02-12 2025-05-16 1,000,000.00 0.00 2,472.22 True 2,472.22 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 5 2025-05-15 2025-08-15 2025-05-13 2025-08-18 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 6 2025-08-15 2025-11-15 2025-08-13 2025-11-18 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 7 2025-11-15 2026-02-15 2025-11-12 2026-02-18 1,000,000.00 1,000,000.00 2,555.56 True 1,002,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360"},{"location":"3_Construccion_Operaciones/#otras-combinaciones-de-periodos-irregulares","title":"Otras Combinaciones de Per\u00edodos Irregulares","text":"<p>Las distintas combinaciones de per\u00edodos irregulares (de pago y fijaci\u00f3n) permiten obtener tablas de desarrollo con muchas caracter\u00edsticas.</p>"},{"location":"3_Construccion_Operaciones/#shortfront-con-shortfront","title":"<code>SHORTFRONT</code> con <code>SHORTFRONT</code>","text":"<pre><code>params[\"start_date\"] = qcf.QCDate(15, 3, 2024)\nparams[\"settlement_stub_period\"] = qcf.StubPeriod.SHORTFRONT\nparams[\"fixing_stub_period\"] = qcf.StubPeriod.SHORTFRONT\n</code></pre> <pre><code>ibor_leg = qcf.LegFactory.build_bullet_ibor_leg(**params)\n</code></pre> <p>En este caso, las fechas de fijaci\u00f3n se sincronizan con las fechas de inicio de los cupones. Notar adem\u00e1s que el primer cup\u00f3n es de dos meses mientras que el \u00edndice es de 3M.</p> <pre><code>aux.leg_as_dataframe(ibor_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2024-03-15 2024-05-15 2024-03-13 2024-05-16 1,000,000.00 0.00 1,694.44 True 1,694.44 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 1 2024-05-15 2024-08-15 2024-05-13 2024-08-16 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 2 2024-08-15 2024-11-15 2024-08-13 2024-11-18 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 3 2024-11-15 2025-02-15 2024-11-13 2025-02-19 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 4 2025-02-15 2025-05-15 2025-02-12 2025-05-16 1,000,000.00 0.00 2,472.22 True 2,472.22 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 5 2025-05-15 2025-08-15 2025-05-13 2025-08-18 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 6 2025-08-15 2025-11-15 2025-08-13 2025-11-18 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 7 2025-11-15 2026-02-15 2025-11-12 2026-02-18 1,000,000.00 1,000,000.00 2,555.56 True 1,002,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360"},{"location":"3_Construccion_Operaciones/#shortfront-con-longback","title":"<code>SHORTFRONT</code> con <code>LONGBACK</code>","text":"<pre><code>params[\"start_date\"] = qcf.QCDate(31, 1, 2024)\nparams[\"end_date\"] = qcf.QCDate(31, 3, 2026) \nparams[\"settlement_stub_period\"] = qcf.StubPeriod.SHORTFRONT\nparams[\"fixing_stub_period\"] = qcf.StubPeriod.LONGBACK\n\nibor_leg = qcf.LegFactory.build_bullet_ibor_leg(**params)\n</code></pre> <p>En este caso, las fechas de fijaci\u00f3n tambi\u00e9n se desfasan respecto a las fechas de inicio de los cupones. Ahora las fechas de fijaci\u00f3n de los primeros dos cupones coinciden.</p> <pre><code>aux.leg_as_dataframe(ibor_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2024-01-31 2024-03-31 2024-01-29 2024-04-02 1,000,000.00 0.00 1,666.67 True 1,666.67 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 1 2024-03-31 2024-06-30 2024-01-29 2024-07-02 1,000,000.00 0.00 2,527.78 True 2,527.78 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 2 2024-06-30 2024-09-30 2024-04-26 2024-10-01 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 3 2024-09-30 2024-12-31 2024-07-29 2025-01-02 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 4 2024-12-31 2025-03-31 2024-10-29 2025-04-01 1,000,000.00 0.00 2,500.00 True 2,500.00 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 5 2025-03-31 2025-06-30 2025-01-29 2025-07-01 1,000,000.00 0.00 2,527.78 True 2,527.78 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 6 2025-06-30 2025-09-30 2025-04-28 2025-10-01 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 7 2025-09-30 2025-12-31 2025-07-29 2026-01-02 1,000,000.00 0.00 2,555.56 True 2,555.56 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360 8 2025-12-31 2026-03-31 2025-10-29 2026-04-01 1,000,000.00 1,000,000.00 2,500.00 True 1,002,500.00 USD TERMSOFR3M 0.0000% 1.0000% 1.00 LinAct360"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-bulletibormulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>BulletIborMultiCurrencyLeg</code>","text":"<p>Se construye un <code>Leg</code> con <code>IborMultiCurrencyCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>Tenor</code>: periodicidad de fijaci\u00f3n</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular para el calendario de fijaciones</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n</li> <li><code>unsigned int</code>: lag de fijaci\u00f3n expresado en d\u00edas</li> <li><code>InterestRateIndex</code>: \u00edndice de tasa de inter\u00e9s utilizado en cada <code>IborCashflow</code></li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>QCCurrency</code>: moneda del nominal y de los flujos</li> <li><code>float</code>: spread aditivo</li> <li><code>gearing</code>: spread multiplicativo (tasa * gearing + spread)</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> </ul> <p>MultiCurrency - <code>QCCurrency</code>: moneda de pago los flujos - <code>FXRateIndex</code>: \u00edndice con el cual se transforma cada flujo a la moneda de pago - <code>int</code>: lag de fijaci\u00f3n del <code>FXRateIndex</code>. - <code>FxFixingLagPivot</code>: este par\u00e1metro indica si el lag de fijaci\u00f3n del \u00edndice FX se aplica sobre <code>end_date</code> o sobre <code>settlement_date</code>. - <code>FxFixingLagAppliesTo</code>: indica si el lag se refiere a <code>FIXING_DATE</code> o <code>PUBISHING_DATE</code> del \u00edndice.</p> <p>Vamos a un ejemplo.</p> <pre><code>ibor_mccy_leg = qcf.LegFactory.build_bullet_ibor_mccy_leg(\n    rec_pay=rp, \n    start_date=fecha_inicio, \n    end_date=fecha_final, \n    bus_adj_rule=bus_adj_rule, \n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago, \n    settlement_calendar=calendario, \n    settlement_lag=lag_pago,\n    fixing_periodicity=periodicidad_fijacion, \n    fixing_stub_period=periodo_irregular_fijacion,\n    fixing_calendar=calendario, \n    fixing_lag=lag_de_fijacion, \n    interest_rate_index=termsofr_3m,\n    initial_notional=nominal, \n    amort_is_cashflow=amort_es_flujo, \n    notional_currency=clp, \n    spread=spread, \n    gearing=gearing,\n    sett_lag_behaviour=sett_lag_behaviour,\n    # Par\u00e1metros MultiCurrency\n    settlement_currency=usd, \n    fx_rate_index=usdclp_obs, \n    fx_rate_index_fixing_lag=fx_rate_index_fixing_lag,\n    fx_fixing_lag_pivot=fx_fixing_lag_pivot,\n    fx_fixing_lag_applies_to=qcf.FxFixingLagAppliesTo.PUBLISHING_DATE,\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(ibor_mccy_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa spread gearing valor_tasa tipo_tasa fecha_fixing_fx moneda_pago codigo_indice_fx valor_indice_fx amortizacion_moneda_pago interes_moneda_pago flujo_moneda_pago 0 2024-02-15 2024-05-15 2024-02-13 2024-05-16 1,000,000.00 0.00 2,500.00 True 2,500.00 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2024-05-15 USD USDOBS 1.00 0.00 2,500.00 2,500.00 1 2024-05-15 2024-08-15 2024-05-13 2024-08-16 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2024-08-15 USD USDOBS 1.00 0.00 2,555.56 2,555.56 2 2024-08-15 2024-11-15 2024-08-13 2024-11-18 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2024-11-15 USD USDOBS 1.00 0.00 2,555.56 2,555.56 3 2024-11-15 2025-02-15 2024-11-13 2025-02-19 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2025-02-18 USD USDOBS 1.00 0.00 2,555.56 2,555.56 4 2025-02-15 2025-05-15 2025-02-12 2025-05-16 1,000,000.00 0.00 2,472.22 True 2,472.22 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2025-05-15 USD USDOBS 1.00 0.00 2,472.22 2,472.22 5 2025-05-15 2025-08-15 2025-05-13 2025-08-18 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2025-08-15 USD USDOBS 1.00 0.00 2,555.56 2,555.56 6 2025-08-15 2025-11-15 2025-08-13 2025-11-18 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2025-11-17 USD USDOBS 1.00 0.00 2,555.56 2,555.56 7 2025-11-15 2026-02-15 2025-11-12 2026-02-18 1,000,000.00 1,000,000.00 2,555.56 True 1,002,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2026-02-17 USD USDOBS 1.00 1,000,000.00 2,555.56 1,002,555.56 <p>Fijemos el valor del tipo de cambio en los cashflows para ver el efecto en las \u00faltimas dos columnas.</p> <pre><code>for cashflow in ibor_mccy_leg.get_cashflows():\n    cashflow.set_fx_rate_index_value(900.0)\n</code></pre> <pre><code>aux.leg_as_dataframe(ibor_mccy_leg).style.format(aux.format_dict).set_properties(\n    **{'background-color': '#FFCFC9', 'color':'black'},\n    subset=['valor_indice_fx','amortizacion_moneda_pago', 'interes_moneda_pago'],\n)\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa spread gearing valor_tasa tipo_tasa fecha_fixing_fx moneda_pago codigo_indice_fx valor_indice_fx amortizacion_moneda_pago interes_moneda_pago flujo_moneda_pago 0 2024-02-15 2024-05-15 2024-02-13 2024-05-16 1,000,000.00 0.00 2,500.00 True 2,500.00 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2024-05-15 USD USDOBS 900.00 0.00 2.78 2.78 1 2024-05-15 2024-08-15 2024-05-13 2024-08-16 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2024-08-15 USD USDOBS 900.00 0.00 2.84 2.84 2 2024-08-15 2024-11-15 2024-08-13 2024-11-18 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2024-11-15 USD USDOBS 900.00 0.00 2.84 2.84 3 2024-11-15 2025-02-15 2024-11-13 2025-02-19 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2025-02-18 USD USDOBS 900.00 0.00 2.84 2.84 4 2025-02-15 2025-05-15 2025-02-12 2025-05-16 1,000,000.00 0.00 2,472.22 True 2,472.22 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2025-05-15 USD USDOBS 900.00 0.00 2.75 2.75 5 2025-05-15 2025-08-15 2025-05-13 2025-08-18 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2025-08-15 USD USDOBS 900.00 0.00 2.84 2.84 6 2025-08-15 2025-11-15 2025-08-13 2025-11-18 1,000,000.00 0.00 2,555.56 True 2,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2025-11-17 USD USDOBS 900.00 0.00 2.84 2.84 7 2025-11-15 2026-02-15 2025-11-12 2026-02-18 1,000,000.00 1,000,000.00 2,555.56 True 1,002,555.56 CLP TERMSOFR3M 1.0000% 1.00 0.0000% LinAct360 2026-02-17 USD USDOBS 900.00 1,111.11 2.84 1,113.95"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-overnightindexleg","title":"Construcci\u00f3n Asistida de un <code>OvernightIndexLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>OvernightIndexCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>BusyAdRules</code>: tipo de ajuste en la fecha de fijaci\u00f3n de los valores inicial y final del \u00edndice en cada cup\u00f3n</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n del \u00edndice</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>float</code>: spread aditivo</li> <li><code>float</code>: spread multiplicativo o gearing (tasa * gearing + spread)</li> <li><code>QCInterestRate</code>: representa el tipo de tasa que se usar\u00e1 que se usar\u00e1 para la tasa equivalente</li> <li><code>string</code>: nombre del \u00edndice overnight a utilizar</li> <li><code>unsigned int</code>: n\u00famero de decimales de la tasa equivalente</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>DatesForEquivalentRate</code>: enum que indica qu\u00e9 fechas se utilizan en el c\u00e1lculo de la tasa equivalente (fechas de devengo o de \u00edndice)</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> </ul> <p>NOTA: para construir un <code>Leg</code> con <code>OvernightIndexCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_overnight_index_leg(...)</code>.</p> <p>Vamos al ejemplo. Primeramente, se da de alta los par\u00e1metros requeridos</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 2024)\nfecha_final = qcf.QCDate(31, 1, 2029) \nbus_adj_rule = qcf.BusyAdjRules.NO\nindex_adj_rule = qcf.BusyAdjRules.FOLLOW\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = aux.get_business_calendar('CL', range(2024, 2035))\nnum_decimales_tasa_eq = 8\nlag_pago = 0\nnominal = 100_000_000.0\namort_es_flujo = True \nspread = .01\ngearing = 1.0\ninterest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\nnombre_indice = 'ICPCLP'\ndates_for_eq_rate = qcf.DatesForEquivalentRate.ACCRUAL\nsett_lag_behaviour = qcf.SettLagBehaviour.MOVE_TO_WORKING_DAY\n</code></pre> <p>Finalmente, se da de alta el objeto.</p> <pre><code>on_index_leg = qcf.LegFactory.build_bullet_overnight_index_leg(\n    rec_pay=rp, \n    start_date=fecha_inicio,\n    end_date=fecha_final, \n    bus_adj_rule=bus_adj_rule, \n    fix_adj_rule=index_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago, \n    settlement_calendar=calendario, \n    fixing_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal, \n    amort_is_cashflow=amort_es_flujo, \n    spread=spread, \n    gearing=gearing,\n    interest_rate=interest_rate,\n    index_name=nombre_indice,\n    eq_rate_decimal_places=num_decimales_tasa_eq,\n    notional_currency=clp,\n    dates_for_eq_rate=dates_for_eq_rate,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <p>Se visualiza.</p> <pre><code>aux.leg_as_dataframe(on_index_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa tipo_tasa interes flujo spread gearing 0 2024-01-31 2024-07-31 2024-01-31 2024-07-31 2024-07-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 505,556.00 505,556.00 1.0000% 1.00 1 2024-07-31 2025-01-31 2024-07-31 2025-01-31 2025-01-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 511,111.00 1.0000% 1.00 2 2025-01-31 2025-07-31 2025-01-31 2025-07-31 2025-07-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 502,778.00 502,778.00 1.0000% 1.00 3 2025-07-31 2026-01-31 2025-07-31 2026-02-02 2026-02-02 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 511,111.00 1.0000% 1.00 4 2026-01-31 2026-07-31 2026-02-02 2026-07-31 2026-07-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 502,778.00 502,778.00 1.0000% 1.00 5 2026-07-31 2027-01-31 2026-07-31 2027-02-01 2027-02-01 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 511,111.00 1.0000% 1.00 6 2027-01-31 2027-07-31 2027-02-01 2027-08-02 2027-08-02 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 502,778.00 502,778.00 1.0000% 1.00 7 2027-07-31 2028-01-31 2027-08-02 2028-01-31 2028-01-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 511,111.00 1.0000% 1.00 8 2028-01-31 2028-07-31 2028-01-31 2028-07-31 2028-07-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 505,556.00 505,556.00 1.0000% 1.00 9 2028-07-31 2029-01-31 2028-07-31 2029-01-31 2029-01-31 100,000,000.00 100,000,000.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 100,511,111.00 1.0000% 1.00"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-overnightindexmulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>OvernightIndexMultiCurrencyLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>OvernightIndexMultiCurrencyCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>BusyAdRules</code>: tipo de ajuste en la fecha de fijaci\u00f3n de los valores inicial y final del \u00edndice en cada cup\u00f3n</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n del \u00edndice</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>float</code>: spread aditivo</li> <li><code>float</code>: spread multiplicativo</li> <li><code>QCInterestRate</code>: representa el tipo de tasa que se usar\u00e1 que se usar\u00e1 para la tasa equivalente</li> <li><code>string</code>: nombre del \u00edndice overnight a utilizar</li> <li><code>unsigned int</code>: n\u00famero de decimales de la tasa equivalente</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>DatesForEquivalentRate</code>: enum que indica qu\u00e9 fechas se utilizan en el c\u00e1lculo de la tasa equivalente (fechas de devengo o de \u00edndice)</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> </ul> <p>MultiCurrency - <code>QCCurrency</code>: moneda de pago los flujos - <code>FXRateIndex</code>: \u00edndice con el cual se transforma cada flujo a la moneda de pago - <code>int</code>: lag de fijaci\u00f3n del FXRateIndex (respecto a settlement date) - <code>FxFixingLagPivot</code>: este par\u00e1metro indica si el lag de fijaci\u00f3n del \u00edndice FX se aplica sobre <code>end_date</code> o sobre <code>settlement_date</code>. - <code>FxFixingLagAppliesTo</code>: indica si el lag se refiere a <code>FIXING_DATE</code> o <code>PUBISHING_DATE</code> del \u00edndice.</p> <p>NOTA: para construir un <code>Leg</code> con <code>OvernightIndexMultiCurrencyCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_overnight_index_multi_currency_leg(...)</code>.</p> <p>Vamos al ejemplo. Primeramente, se da de alta los par\u00e1metros requeridos.</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 2024)\nfecha_final = qcf.QCDate(31, 1, 2029) \nbus_adj_rule = qcf.BusyAdjRules.NO\nindex_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nnum_decimales_tasa_eq = 8\nlag_pago = 0\nnominal = 100_000_000.0\namort_es_flujo = True \nspread = .01\ngearing = 1.0\ninterest_rate = qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\ndates_for_eq_rate = qcf.DatesForEquivalentRate.ACCRUAL\nnombre_indice = 'ICPCLP'\nfx_rate_index_fixing_lag = 2\nsett_lag_behaviour = qcf.SettLagBehaviour.MOVE_TO_WORKING_DAY\nfx_fixing_lag_pivot = qcf.FxFixingLagPivot.SETTLEMENT_DATE\n</code></pre> <p>Finalmente, se da de alta el objeto.</p> <pre><code>on_index_mccy_leg = qcf.LegFactory.build_bullet_overnight_index_multi_currency_leg(\n    rec_pay=rp, \n    start_date=fecha_inicio,\n    end_date=fecha_final, \n    bus_adj_rule=bus_adj_rule, \n    fix_adj_rule=index_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago, \n    settlement_calendar=calendario, \n    fixing_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal, \n    amort_is_cashflow=amort_es_flujo, \n    spread=spread, \n    gearing=gearing,\n    interest_rate=interest_rate,\n    index_name=nombre_indice,\n    eq_rate_decimal_places=num_decimales_tasa_eq,\n    notional_currency=clp,\n    dates_for_eq_rate=dates_for_eq_rate,\n    sett_lag_behaviour=sett_lag_behaviour,\n    # Par\u00e1metros MultiCurrency\n    settlement_currency=usd,\n    fx_rate_index=usdclp_obs,\n    fx_rate_index_fixing_lag=fx_rate_index_fixing_lag,\n    fx_fixing_lag_pivot=fx_fixing_lag_pivot,\n    fx_fixing_lag_applies_to=qcf.FxFixingLagAppliesTo.PUBLISHING_DATE,\n)\n</code></pre> <p>Se visualiza.</p> <pre><code>aux.leg_as_dataframe(on_index_mccy_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa tipo_tasa interes flujo spread gearing moneda_pago indice_fx fecha_fixing_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2024-01-31 2024-07-31 2024-01-31 2024-07-31 2024-07-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 505,556.00 505,556.00 1.0000% 1.00 USD USDOBS 2024-07-29 1.00 505,556.00 0.00 505,556.00 1 2024-07-31 2025-01-31 2024-07-31 2025-01-31 2025-01-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 511,111.00 1.0000% 1.00 USD USDOBS 2025-01-29 1.00 511,111.00 0.00 511,111.00 2 2025-01-31 2025-07-31 2025-01-31 2025-07-31 2025-07-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 502,778.00 502,778.00 1.0000% 1.00 USD USDOBS 2025-07-29 1.00 502,778.00 0.00 502,778.00 3 2025-07-31 2026-01-31 2025-07-31 2026-01-30 2026-02-02 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 511,111.00 1.0000% 1.00 USD USDOBS 2026-01-29 1.00 511,111.00 0.00 511,111.00 4 2026-01-31 2026-07-31 2026-01-30 2026-07-31 2026-07-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 502,778.00 502,778.00 1.0000% 1.00 USD USDOBS 2026-07-29 1.00 502,778.00 0.00 502,778.00 5 2026-07-31 2027-01-31 2026-07-31 2027-01-29 2027-02-01 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 511,111.00 1.0000% 1.00 USD USDOBS 2027-01-28 1.00 511,111.00 0.00 511,111.00 6 2027-01-31 2027-07-31 2027-01-29 2027-07-30 2027-08-02 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 502,778.00 502,778.00 1.0000% 1.00 USD USDOBS 2027-07-29 1.00 502,778.00 0.00 502,778.00 7 2027-07-31 2028-01-31 2027-07-30 2028-01-31 2028-01-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 511,111.00 1.0000% 1.00 USD USDOBS 2028-01-27 1.00 511,111.00 0.00 511,111.00 8 2028-01-31 2028-07-31 2028-01-31 2028-07-31 2028-07-31 100,000,000.00 0.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 505,556.00 505,556.00 1.0000% 1.00 USD USDOBS 2028-07-27 1.00 505,556.00 0.00 505,556.00 9 2028-07-31 2029-01-31 2028-07-31 2029-01-31 2029-01-31 100,000,000.00 100,000,000.00 True CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 511,111.00 100,511,111.00 1.0000% 1.00 USD USDOBS 2029-01-29 1.00 511,111.00 100,000,000.00 100,511,111.00"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-compoundedovernightrateleg","title":"Construcci\u00f3n Asistida de un <code>CompoundedOvernightRateLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>CompoundedOvernightRateCashflow2</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n de la tasa overnight</li> <li><code>QCInterestRateIndex</code>: \u00edndice overnight a utilizar</li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>float</code>: spread aditivo</li> <li><code>float</code>: spread multiplicativo o gearing (tasa * gearing + spread)</li> <li><code>QCInterestRate</code>: representa el tipo de tasa que se usar\u00e1 que se usar\u00e1 para la tasa equivalente</li> <li><code>unsigned int</code>: n\u00famero de decimales de la tasa equivalente</li> <li><code>unsigned int</code>: lookback (no implementado)</li> <li><code>unsigned int</code>: lockout (no implementado)</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> </ul> <p>NOTA: para construir un <code>Leg</code> con <code>CompoundedOvernightRateCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_compounded_overnight_rate_leg_2(...)</code>.</p> <p>Vamos al ejemplo. Primeramente, se da de alta los par\u00e1metros requeridos</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 2024)\nfecha_final = qcf.QCDate(31, 1, 2028)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('1Y')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = aux.get_business_calendar('US', range(2024, 2035))\nlag_pago = 2\nnominal = 10_000_000.0\namort_es_flujo = True\nmoneda = usd\nspread = .01\ngearing = 1.0\neq_rate_decimal_places = 8\nlookback = 0 \nlockout = 0\nsett_lag_behaviour = qcf.SettLagBehaviour.MOVE_TO_WORKING_DAY\n</code></pre> <p>Se define el \u00edndice.</p> <pre><code>codigo = 'SOFRRATE'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('0d')\ntenor = qcf.Tenor('1d')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\noistest = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd\n)\n</code></pre> <p>Finalmente, se da de alta el objeto.</p> <pre><code>cor_leg = qcf.LegFactory.build_bullet_compounded_overnight_rate_leg_2(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    fixing_calendar=calendario,\n    interest_rate_index=oistest,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    notional_currency=usd,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=lin_act360,\n    eq_rate_decimal_places=8,\n    lookback=lookback,\n    lockout=lockout,\n    sett_lag_behaviour=sett_lag_behaviour,\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(cor_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa tipo_tasa valor_tasa spread gearing 0 2024-01-31 2025-01-31 2025-02-04 10,000,000.00 0.00 101,666.67 True 101,666.67 USD SOFRRATE LinAct360 0.0000% 1.0000% 1.00 1 2025-01-31 2026-01-30 2026-02-03 10,000,000.00 0.00 101,111.11 True 101,111.11 USD SOFRRATE LinAct360 0.0000% 1.0000% 1.00 2 2026-01-30 2027-01-29 2027-02-02 10,000,000.00 0.00 101,111.11 True 101,111.11 USD SOFRRATE LinAct360 0.0000% 1.0000% 1.00 3 2027-01-29 2028-01-31 2028-02-02 10,000,000.00 10,000,000.00 101,944.44 True 10,101,944.44 USD SOFRRATE LinAct360 0.0000% 1.0000% 1.00"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-compoundedovernightratemulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>CompoundedOvernightRateMultiCurrencyLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>CompoundedOvernightRateMultiCurrencyCashflow2</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n de la tasa overnight</li> <li><code>QCInterestRateIndex</code>: \u00edndice overnight a utilizar</li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>float</code>: spread aditivo</li> <li><code>float</code>: spread multiplicativo</li> <li><code>QCInterestRate</code>: representa el tipo de tasa que se usar\u00e1 que se usar\u00e1 para la tasa equivalente</li> <li><code>unsigned int</code>: n\u00famero de decimales de la tasa equivalente</li> <li><code>unsigned int</code>: lookback (no implementado)</li> <li><code>unsigned int</code>: lockout (no implementado)</li> <li><code>SettLagBehaviour</code>: este par\u00e1metro indica c\u00f3mo se calcula un <code>settlement_date</code> cuando un <code>end_date</code> cae en un d\u00eda festivo.</li> </ul> <p>MultiCurrency - <code>QCCurrency</code>: moneda de pago los flujos - <code>FXRateIndex</code>: \u00edndice con el cual se transforma cada flujo a la moneda de pago - <code>int</code>: lag de fijaci\u00f3n del FXRateIndex (respecto a settlement date) - <code>FxFixingLagPivot</code>: este par\u00e1metro indica si el lag de fijaci\u00f3n del \u00edndice FX se aplica sobre <code>end_date</code> o sobre <code>settlement_date</code>. - <code>FxFixingLagAppliesTo</code>: indica si el lag se refiere a <code>FIXING_DATE</code> o <code>PUBISHING_DATE</code> del \u00edndice.</p> <p>NOTA: para construir un <code>Leg</code> con <code>CompoundedOvernightRateMultiCurrencyCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_compounded_overnight_rate_multi_currency_leg_2(...)</code>.</p> <p>Vamos al ejemplo. Primeramente, se da de alta los par\u00e1metros requeridos</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 2024)\nfecha_final = qcf.QCDate(31, 1, 2028)\nbus_adj_rule = qcf.BusyAdjRules.NO\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 2\nnominal = 1000000.0\namort_es_flujo = True\nmoneda = usd\nspread = .01\ngearing = 1.0\neq_rate_decimal_places = 8\nlookback = 0\nlockout = 0\nfx_rate_index_fixing_lag = 1\nsett_lag_behaviour = qcf.SettLagBehaviour.MOVE_TO_WORKING_DAY\nfx_fixing_lag_pivot = qcf.FxFixingLagPivot.SETTLEMENT_DATE\n</code></pre> <p>Se define el \u00edndice.</p> <pre><code>codigo = 'OISTEST'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('0d')\ntenor = qcf.Tenor('1d')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\noistest = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd\n)\n</code></pre> <p>Finalmente, se da de alta el objeto.</p> <pre><code>cor_mccy_leg = qcf.LegFactory.build_bullet_compounded_overnight_rate_mccy_leg_2(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    fixing_calendar=calendario,\n    interest_rate_index=oistest,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    notional_currency=usd,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=lin_act360,\n    eq_rate_decimal_places=8,\n    lookback=lookback,\n    lockout=lockout,\n    sett_lag_behaviour=sett_lag_behaviour,\n    # Par\u00e1metros MultiCurrency\n    fx_rate_index_fixing_lag=fx_rate_index_fixing_lag,\n    settlement_currency=usd,\n    fx_rate_index=usdclp_obs,\n    fx_fixing_lag_pivot=fx_fixing_lag_pivot,\n    fx_fixing_lag_applies_to=qcf.FxFixingLagAppliesTo.FIXING_DATE,\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(cor_mccy_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa tipo_tasa spread gearing valor_tasa moneda_pago fx_rate_index fecha_fixing_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2024-01-31 2024-07-31 2024-08-02 1,000,000.00 0.00 5,055.56 True 5,055.56 USD OISTEST LinAct360 1.0000% 1.00 0.0000% USD USDOBS 2024-08-02 1.00 5,055.56 0.00 5,055.56 1 2024-07-31 2025-01-31 2025-02-04 1,000,000.00 0.00 5,111.11 True 5,111.11 USD OISTEST LinAct360 1.0000% 1.00 0.0000% USD USDOBS 2025-02-04 1.00 5,111.11 0.00 5,111.11 2 2025-01-31 2025-07-31 2025-08-04 1,000,000.00 0.00 5,027.78 True 5,027.78 USD OISTEST LinAct360 1.0000% 1.00 0.0000% USD USDOBS 2025-08-04 1.00 5,027.78 0.00 5,027.78 3 2025-07-31 2026-01-31 2026-02-04 1,000,000.00 0.00 5,111.11 True 5,111.11 USD OISTEST LinAct360 1.0000% 1.00 0.0000% USD USDOBS 2026-02-04 1.00 5,111.11 0.00 5,111.11 4 2026-01-31 2026-07-31 2026-08-04 1,000,000.00 0.00 5,027.78 True 5,027.78 USD OISTEST LinAct360 1.0000% 1.00 0.0000% USD USDOBS 2026-08-04 1.00 5,027.78 0.00 5,027.78 5 2026-07-31 2027-01-31 2027-02-03 1,000,000.00 0.00 5,111.11 True 5,111.11 USD OISTEST LinAct360 1.0000% 1.00 0.0000% USD USDOBS 2027-02-03 1.00 5,111.11 0.00 5,111.11 6 2027-01-31 2027-07-31 2027-08-04 1,000,000.00 0.00 5,027.78 True 5,027.78 USD OISTEST LinAct360 1.0000% 1.00 0.0000% USD USDOBS 2027-08-04 1.00 5,027.78 0.00 5,027.78 7 2027-07-31 2028-01-31 2028-02-02 1,000,000.00 1,000,000.00 5,111.11 True 1,005,111.11 USD OISTEST LinAct360 1.0000% 1.00 0.0000% USD USDOBS 2028-02-02 1.00 5,111.11 1,000,000.00 1,005,111.11"},{"location":"3_Construccion_Operaciones/#construccion-asistida-de-un-icpclfleg","title":"Construcci\u00f3n Asistida de un <code>IcpClfLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>IcpClfCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>float</code>: spread aditivo</li> <li><code>gearing</code>: spread multiplicativo o gearing (tasa * geraing + spread)</li> </ul> <p>NOTA: para construir un <code>Leg</code> con <code>IcpClfCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_icp_clf_leg(...)</code>.</p> <p>Vamos al ejemplo.</p> <p>Se da de alta los par\u00e1metros requeridos</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 2024)\nfecha_final = qcf.QCDate(31, 1, 2028)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 2\nnominal = 300_000.0\namort_es_flujo = True\nspread = .01\ngearing = 1.0\n</code></pre> <p>Se da de alta el objeto.</p> <pre><code>icp_clf_leg = qcf.LegFactory.build_bullet_icp_clf_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    spread=spread,\n    gearing=gearing\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(icp_clf_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion amort_es_flujo flujo moneda_nocional icp_inicial icp_final uf_inicial uf_final valor_tasa interes spread gearing tipo_tasa flujo_en_clp 0 2024-01-31 2024-07-31 2024-08-02 300,000.00 0.00 True 1,516.67 CLF 10,000.00 10,000.00 35,000.00 35,000.00 1.0000% 1,516.67 1.0000% 1.00 LinAct360 53,083,333.00 1 2024-07-31 2025-01-31 2025-02-04 300,000.00 0.00 True 1,533.33 CLF 10,000.00 10,000.00 35,000.00 35,000.00 1.0000% 1,533.33 1.0000% 1.00 LinAct360 53,666,667.00 2 2025-01-31 2025-07-31 2025-08-04 300,000.00 0.00 True 1,508.33 CLF 10,000.00 10,000.00 35,000.00 35,000.00 1.0000% 1,508.33 1.0000% 1.00 LinAct360 52,791,667.00 3 2025-07-31 2026-01-30 2026-02-03 300,000.00 0.00 True 1,525.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 1.0000% 1,525.00 1.0000% 1.00 LinAct360 53,375,000.00 4 2026-01-30 2026-07-31 2026-08-04 300,000.00 0.00 True 1,516.67 CLF 10,000.00 10,000.00 35,000.00 35,000.00 1.0000% 1,516.67 1.0000% 1.00 LinAct360 53,083,333.00 5 2026-07-31 2027-01-29 2027-02-02 300,000.00 0.00 True 1,516.67 CLF 10,000.00 10,000.00 35,000.00 35,000.00 1.0000% 1,516.67 1.0000% 1.00 LinAct360 53,083,333.00 6 2027-01-29 2027-07-30 2027-08-03 300,000.00 0.00 True 1,516.67 CLF 10,000.00 10,000.00 35,000.00 35,000.00 1.0000% 1,516.67 1.0000% 1.00 LinAct360 53,083,333.00 7 2027-07-30 2028-01-31 2028-02-02 300,000.00 300,000.00 True 301,541.67 CLF 10,000.00 10,000.00 35,000.00 35,000.00 1.0000% 1,541.67 1.0000% 1.00 LinAct360 10,553,958,333.00"},{"location":"4_Valorizacion_Sensibilidad/","title":"Valorizaci\u00f3n y Sensibilidad","text":""},{"location":"4_Valorizacion_Sensibilidad/#configuracion","title":"Configuraci\u00f3n","text":"<p>Para ejecutar todos los ejemplos se debe importar la librer\u00eda. Se sugiere utilizar siempre el alias <code>qcf</code>. </p> <pre><code>import qcfinancial as qcf\nimport pickle\n</code></pre> <pre><code>qcf.id()\n</code></pre> <pre><code>'version: 1.6.1, build: 2025-06-06 09:09'\n</code></pre> <p>Librer\u00edas adicionales.</p> <pre><code>import aux_functions as aux # Aqu\u00ed se guard\u00f3 la funci\u00f3n leg_as_dataframe del notebook 3\nfrom math import exp, log\nimport pandas as pd\nimport numpy as np\n</code></pre> <pre><code>pd.options.display.max_columns=300\n</code></pre> <p>Para formateo de <code>pandas.DataFrames</code>.</p> <pre><code>format_dict = {\n    'nominal': '{:,.2f}',\n    'amort': '{:,.2f}',\n    'interes': '{:,.2f}',\n    'flujo': '{:,.2f}',\n    'nocional': '{:,.2f}',\n    'amortizacion': '{:,.2f}',\n    'icp_inicial': '{:,.2f}',\n    'icp_final': '{:,.2f}',\n    'uf_inicial': '{:,.2f}',\n    'uf_final': '{:,.2f}',\n    'plazo': '{:,.0f}',\n    'tasa': '{:,.4%}',\n    'valor_tasa': '{:,.4%}',\n    'valor_tasa_equivalente': '{:,.4%}',\n    'spread': '{:,.4%}',\n    'gearing': '{:,.2f}',\n    'amort_moneda_pago': '{:,.2f}',\n    'interes_moneda_pago': '{:,.2f}',\n    'valor_indice_inicial': '{:,.2f}',\n    'valor_indice_final': '{:,.2f}',\n    'valor_indice_fx': '{:,.2f}',\n    'flujo_en_clp': '{:,.2f}',\n}\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#construccion-de-la-curva","title":"Construcci\u00f3n de la Curva","text":"<p>La construcci\u00f3n de una curva se hace en varios pasos.</p>"},{"location":"4_Valorizacion_Sensibilidad/#vectores-de-float-e-int","title":"Vectores de <code>Float</code> e <code>Int</code>","text":"<p>Este es un vector de n\u00fameros enteros (grandes, de ah\u00ed la l (long))</p> <pre><code>lvec = qcf.long_vec()\n</code></pre> <p>Agregar un elemento.</p> <pre><code>lvec.append(1000)\n</code></pre> <p>Este es un vector de n\u00fameros <code>float</code>.</p> <pre><code>vec = qcf.double_vec()\n</code></pre> <p>Agregar un elemento.</p> <pre><code>vec.append(.025)\n</code></pre> <p>Obtener ese elemento.</p> <pre><code>print(f\"Plazo: {lvec[0]:,.0f}\")\nprint(f\"Tasa: {vec[0]:,.2%}\")\n</code></pre> <pre><code>Plazo: 1,000\nTasa: 2.50%\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#objeto-curva","title":"Objeto Curva","text":"<p>Es simplemente un <code>long_vec</code> que representa las abscisas de la curva y un <code>double_vec</code> que representa las ordenadas. Ambos vectores deben tener el mismo largo. </p> <pre><code>curva = qcf.QCCurve(lvec, vec)\n</code></pre> <p>Un elemento de una curva se representa como un par abscisa, ordenada.</p> <pre><code>curva.get_values_at(0)\n</code></pre> <pre><code>(1000, 0.025)\n</code></pre> <p>Se obtiene el plazo en una posici\u00f3n de la curva.</p> <pre><code>curva.get_values_at(0)[0]\n</code></pre> <pre><code>1000\n</code></pre> <p>Se obtiene la tasa en una posici\u00f3n de la curva.</p> <pre><code>curva.get_values_at(0)[1]\n</code></pre> <pre><code>0.025\n</code></pre> <p>Se agrega un par (plazo, valor) a la curva.</p> <pre><code>curva.set_pair(100, .026)\n</code></pre> <p>Se verifica. Notar que se debe usar el \u00edndice 0 ya que la curva se ordena autom\u00e1ticamente por plazos ascendentes.</p> <pre><code>curva.get_values_at(0)[0]\n</code></pre> <pre><code>100\n</code></pre> <pre><code>curva.get_values_at(0)[1]\n</code></pre> <pre><code>0.026\n</code></pre> <p>Se agrega un par m\u00e1s.</p> <pre><code>curva.set_pair(370, .03)\n</code></pre> <p>Se itera sobre la curva mostrando sus valores</p> <pre><code>for i in range(curva.get_length()):\n    pair = curva.get_values_at(i)\n    print(\"Tenor: {0:,.0f} Valor: {1:.4%}\".format(pair[0], pair[1]))\n</code></pre> <pre><code>Tenor: 100 Valor: 2.6000%\nTenor: 370 Valor: 3.0000%\nTenor: 1,000 Valor: 2.5000%\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#interpolador","title":"Interpolador","text":"<p>Se agrega un interpolador. En este caso, un interpolador lineal.</p> <pre><code>lin = qcf.QCLinearInterpolator(curva)\n</code></pre> <p>Se puede ahora obtener una tasa a un plazo cualquiera.</p> <pre><code>plazo = 120\nprint(f\"Tasa a {plazo:,.0f} d\u00edas es igual a {lin.interpolate_at(plazo):.4%}\")\n</code></pre> <pre><code>Tasa a 120 d\u00edas es igual a 2.6296%\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#curva-cero-cupon","title":"Curva Cero Cup\u00f3n","text":"<p>Para completar el proceso se define un objeto de tipo <code>QCInterestRate</code>. Con este objeto, que representa la convenci\u00f3n de las tasas de inter\u00e9s asociadas a la curva, se termina de dar de alta una curva cero cup\u00f3n.</p> <pre><code>yf = qcf.QCAct365()\nwf = qcf.QCContinousWf()\ntasa = qcf.QCInterestRate(.0, yf, wf)\n</code></pre> <pre><code>zcc = qcf.ZeroCouponCurve(lin, tasa)\n</code></pre> <p>El interpolador permite obtener una tasa a cualquier plazo.</p> <pre><code>plazo = 300\nprint(f\"Tasa en {plazo:,.0f} es igual a {zcc.get_rate_at(plazo):.4%}\")\n</code></pre> <pre><code>Tasa en 300 es igual a 2.8963%\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#otros-metodos","title":"Otros m\u00e9todos:","text":"<p>Discount factor.</p> <pre><code>print(f\"Discount factor at {plazo}: {zcc.get_discount_factor_at(plazo):.6%}\")\nprint(f\"Check: {exp(-zcc.get_rate_at(plazo) * plazo / 365):.6%}\")\n</code></pre> <pre><code>Discount factor at 300: 97.647593%\nCheck: 97.647593%\n</code></pre> <p>Tasa Forward</p> <pre><code>d1 = 30\nd2 = 90\nprint(f\"Tasa forward entre los d\u00edas {d1:,.0f} y {d2:,.0f}: {zcc.get_forward_rate(d1, d2):.4%}\")\n</code></pre> <pre><code>Tasa forward entre los d\u00edas 30 y 90: 2.6000%\n</code></pre> <p>Se verifica el c\u00e1lculo.</p> <pre><code>df1 = zcc.get_discount_factor_at(d1)\ndf2 = zcc.get_discount_factor_at(d2)\ndf12 = df1 / df2\nprint(f\"Check: {log(df12) * 365 / (d2 - d1):.4%}\")\n</code></pre> <pre><code>Check: 2.6000%\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#valorizar","title":"Valorizar","text":"<p>Para valorizar es necesario dar de alta un objeto de tipo <code>PresentValue</code>.</p> <pre><code>pv = qcf.PresentValue()\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#deposito-a-plazo","title":"Dep\u00f3sito a Plazo","text":"<p>Se utilizar\u00e1 como instrumento un dep\u00f3sito a plazo en CLP o USD. Este instrumento se modela como un <code>SimpleCashflow</code>. Este, a su vez se construye con un monto, una fecha y una moneda.</p> <pre><code>fecha_vcto = qcf.QCDate(13, 1, 2025)\nmonto = 10_000_000.0\nclp = qcf.QCCLP()\n\n# Se construye el dep\u00f3sito\ndepo = qcf.SimpleCashflow(fecha_vcto, monto, clp)\n</code></pre> <pre><code>print(f\"Monto del dep\u00f3sito: {depo.amount():,.0f}\")\n</code></pre> <pre><code>Monto del dep\u00f3sito: 10,000,000\n</code></pre> <p>Se define una fecha de valorizaci\u00f3n y se calcula el valor presente del depo.</p> <pre><code>fecha_hoy = qcf.QCDate(31, 1, 2024)\nprint(f\"Valor presente depo: {pv.pv(fecha_hoy, depo, zcc):,.2f}\")\n</code></pre> <pre><code>Valor presente depo: 9,721,044.77\n</code></pre> <p>Se verifica a mano el resultado.</p> <pre><code>plazo = fecha_hoy.day_diff(fecha_vcto)\nprint(\"Plazo:\", plazo)\n</code></pre> <pre><code>Plazo: 348\n</code></pre> <pre><code>tasa_int = zcc.get_rate_at(plazo)\nprint(f\"Tasa: {tasa_int:,.4%}\")\n</code></pre> <pre><code>Tasa: 2.9674%\n</code></pre> <pre><code>valor_presente = monto * exp(-tasa_int * plazo / 365)\nprint(f\"Valor presente a mano: {valor_presente:,.2f}\")\n</code></pre> <pre><code>Valor presente a mano: 9,721,044.77\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#renta-fija-de-chile","title":"Renta Fija de Chile","text":"<p>Se muestra el ejemplo de valorizaci\u00f3n de un bono bullet a tasa fija con las convenciones de la Bolsa de Comercio de Santiago. Para el ejemplo usamos las caracter\u00edsticas del BTU0150326.</p> <p>Se dan de alta los par\u00e1metros requeridos para instanciar un objeto de tipo <code>FixedRateLeg</code>.</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(1, 3, 2015)\nfecha_final = qcf.QCDate(1, 3, 2026)\nbus_adj_rule = qcf.BusyAdjRules.NO\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 100.0\namort_es_flujo = True\nvalor_tasa_fija = .015\ntasa_cupon = qcf.QCInterestRate(\n    valor_tasa_fija, \n    qcf.QC30360(),\n    qcf.QCLinearWf()\n)\nmoneda = qcf.QCCLP()\nes_bono = True\n</code></pre> <p>Se da de alta el objeto.</p> <pre><code>pata_bono = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad,\n    periodo_irregular,\n    calendario,\n    lag_pago,\n    nominal,\n    amort_es_flujo,\n    tasa_cupon,\n    moneda,\n    es_bono\n)\n</code></pre> <p>Se da de alta el valor de la TERA y luego se construye un objeto de tipo <code>ChileanFixedRateBond</code>.</p> <pre><code>tera = qcf.QCInterestRate(.015044, qcf.QCAct365(), qcf.QCCompoundWf())\nbono_chileno = qcf.ChileanFixedRateBond(pata_bono, tera)\n</code></pre> <p>Se valoriza al 2021-09-28 a una TIR de mercado del 1.61%.</p> <pre><code>fecha_valor = qcf.QCDate(28, 9, 2021)\ntir = qcf.QCInterestRate(.0161, qcf.QCAct365(), qcf.QCCompoundWf())\n\nvalor_presente = bono_chileno.present_value(fecha_valor, tir)\nprecio = bono_chileno.precio(fecha_valor, tir)\nvalor_par = bono_chileno.valor_par(fecha_valor)\n\nprint(f'Valor presente: {valor_presente:,.8f}')\nprint(f'Precio: {precio:,.2%}')\nprint(f'Valor par: {valor_par:,.18f}')\n</code></pre> <pre><code>Valor presente: 99.67188455\nPrecio: 99.56%\nValor par: 100.110516628864033351\n</code></pre> <p>Con esto el valor a pagar es:</p> <pre><code>valor_uf = 30_080.37\nvalor_pago = precio * valor_par * valor_uf\nprint(f'Valor a pagar: {valor_pago:,.0f}')\n</code></pre> <pre><code>Valor a pagar: 2,998,111\n</code></pre> <p>Con 4 decimales en el precio (4 decimales porcentuales, 6 decimales en el n\u00famero):</p> <pre><code>precio2 = bono_chileno.precio2(fecha_valor, tir, 6)\nprint(f'Precio a 4 decmales: {precio2:.4%}')\n</code></pre> <pre><code>Precio a 4 decmales: 99.5619%\n</code></pre> <p>La funci\u00f3n <code>precio2</code> entrega el mismo resultado que la funci\u00f3n precio cuando se utiliza con 2 decimales porcentuales.</p> <pre><code>precio22 = bono_chileno.precio2(fecha_valor, tir, 4)\nprint(f'Precio a 4 decmales: {precio22:.4%}')\n</code></pre> <pre><code>Precio a 4 decmales: 99.5600%\n</code></pre> <p>Se muestran las diferencias con la convenci\u00f3n de precio usual en mercados desarrollados.</p> <pre><code>bono = qcf.FixedRateBond(pata_bono)\nprint(f'Valor presente: {bono.present_value(fecha_valor, tir):,.8f}')\nprint(f'Precio: {bono.price(fecha_valor, tir):,.8f}')\n</code></pre> <pre><code>Valor presente: 99.67188455\nPrecio: 99.55938455\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#curvas-reales","title":"Curvas Reales","text":"<p>Construyamos dos curvas a partir de data real. Primero una curva en CLP.</p> <pre><code>curva_clp = pd.read_excel(\"./input/curva_clp.xlsx\")\ncurva_clp.style.format(format_dict)\n</code></pre> plazo tasa 0 1 1.7500% 1 4 1.7501% 2 96 1.4867% 3 188 1.3049% 4 279 1.2870% 5 369 1.3002% 6 553 1.3035% 7 734 1.2951% 8 1,099 1.4440% 9 1,465 1.6736% 10 1,830 1.9860% 11 2,195 2.2766% 12 2,560 2.5812% 13 2,926 2.8216% 14 3,291 3.0373% 15 3,656 3.2154% 16 4,387 3.4525% 17 5,482 3.7636% 18 7,309 4.1641% <p>Se da de alta un vector con los plazos (variable de tipo <code>long</code>) y un vector con las tasas (variable de tipo <code>double</code>).</p> <pre><code>lvec1 = qcf.long_vec()\nvec1 = qcf.double_vec()\nfor t in curva_clp.itertuples():\n    lvec1.append(int(t.plazo))\n    vec1.append(t.tasa)\n</code></pre> <p>Luego, con una curva, un interpolador y un objeto <code>QCInterestRate</code>(que indica la convenci\u00f3n de las tasas de la curva) se construye una curva cup\u00f3n cero.</p> <pre><code>curva1 = qcf.QCCurve(lvec1, vec1)\nlin1 = qcf.QCLinearInterpolator(curva1)\nzcc_clp = qcf.ZeroCouponCurve(lin1, tasa)\n</code></pre> <p>Luego, una curva en USD.</p> <pre><code>curva_usd = pd.read_excel(\"./input/curva_usd.xlsx\")\ncurva_usd.style.format(format_dict)\n</code></pre> plazo tasa 0 3 1.5362% 1 4 1.1521% 2 7 1.5536% 3 14 1.5850% 4 31 1.6595% 5 60 1.7698% 6 91 1.8010% 7 123 1.7711% 8 152 1.7542% 9 182 1.7394% 10 213 1.7288% 11 244 1.7183% 12 276 1.7027% 13 305 1.6917% 14 335 1.6820% 15 367 1.6722% 16 549 1.6207% 17 731 1.5947% 18 1,096 1.5788% 19 1,461 1.5906% 20 1,827 1.6190% 21 2,558 1.7028% 22 3,653 1.8533% 23 4,385 1.9547% 24 5,479 2.0893% 25 7,305 2.2831% 26 9,132 2.4306% 27 10,958 2.5576% <p>Se encapasular\u00e1 todo el procedimiento anterior en una funci\u00f3n que dado un <code>DataFrame</code> construya un objeto <code>ZeroCouponCurve</code>.</p> <pre><code>def zcc_from_df(df: pd.DataFrame, tasa: qcf.QCInterestRate) -&gt; qcf.ZeroCouponCurve:\n    lvec = qcf.long_vec()\n    vec = qcf.double_vec()\n    for t in df.itertuples():\n        lvec.append(int(t.plazo))\n        vec.append(t.tasa)\n    curva = qcf.QCCurve(lvec, vec)\n    lin = qcf.QCLinearInterpolator(curva)\n    return qcf.ZeroCouponCurve(lin, tasa)\n</code></pre> <pre><code>zcc_usd = zcc_from_df(curva_usd, tasa)\n</code></pre> <p>Finalmente, una curva en CLF.</p> <pre><code>curva_clf = pd.read_excel(\"./input/curva_clf.xlsx\")\ncurva_clf.style.format(format_dict)\n</code></pre> plazo tasa 0 1 -5.6780% 1 4 -5.6744% 2 35 -0.9340% 3 64 -2.1183% 4 96 -2.0079% 5 126 -2.0762% 6 155 -1.9197% 7 188 -1.9347% 8 218 -1.7626% 9 249 -1.7987% 10 279 -1.9335% 11 309 -1.8159% 12 341 -1.5940% 13 369 -1.5994% 14 400 -1.5068% 15 428 -1.6115% 16 461 -1.5923% 17 491 -1.5780% 18 522 -1.5186% 19 553 -1.5533% 20 582 -1.5649% 21 734 -1.6594% 22 1,099 -1.4881% 23 1,465 -1.2740% 24 1,830 -1.0201% 25 2,195 -0.8009% 26 2,560 -0.5868% 27 2,926 -0.4145% 28 3,291 -0.3047% 29 3,656 -0.2242% 30 4,387 -0.1871% 31 5,482 -0.1056% 32 7,309 -0.0639% <pre><code>zcc_clf = zcc_from_df(curva_clf, tasa)\n</code></pre> <pre><code>curva_sofr = pd.read_excel(\"./input/sofr.xlsx\")\ncurva_sofr.style.format(format_dict)\n</code></pre> curva fecha plazo tasa 0 SOFR 2024-06-11 00:00:00 1 5.3935% 1 SOFR 2024-06-11 00:00:00 2 5.3930% 2 SOFR 2024-06-11 00:00:00 9 5.3911% 3 SOFR 2024-06-11 00:00:00 16 5.3909% 4 SOFR 2024-06-11 00:00:00 32 5.3936% 5 SOFR 2024-06-11 00:00:00 63 5.3894% 6 SOFR 2024-06-11 00:00:00 94 5.3843% 7 SOFR 2024-06-11 00:00:00 124 5.3598% 8 SOFR 2024-06-11 00:00:00 155 5.3375% 9 SOFR 2024-06-11 00:00:00 185 5.3127% 10 SOFR 2024-06-11 00:00:00 216 5.2777% 11 SOFR 2024-06-11 00:00:00 247 5.2404% 12 SOFR 2024-06-11 00:00:00 275 5.2070% 13 SOFR 2024-06-11 00:00:00 367 5.0882% 14 SOFR 2024-06-11 00:00:00 550 4.8542% 15 SOFR 2024-06-11 00:00:00 732 4.6727% 16 SOFR 2024-06-11 00:00:00 1,097 4.4059% 17 SOFR 2024-06-11 00:00:00 1,463 4.2398% 18 SOFR 2024-06-11 00:00:00 1,828 4.1384% 19 SOFR 2024-06-11 00:00:00 2,193 4.0790% 20 SOFR 2024-06-11 00:00:00 2,558 4.0405% 21 SOFR 2024-06-11 00:00:00 2,924 4.0173% 22 SOFR 2024-06-11 00:00:00 3,289 4.0022% 23 SOFR 2024-06-11 00:00:00 3,654 3.9939% 24 SOFR 2024-06-11 00:00:00 4,385 3.9904% 25 SOFR 2024-06-11 00:00:00 5,480 3.9912% 26 SOFR 2024-06-11 00:00:00 7,307 3.9428% 27 SOFR 2024-06-11 00:00:00 9,133 3.8068% 28 SOFR 2024-06-11 00:00:00 10,959 3.6594% <pre><code>zcc_sofr = zcc_from_df(curva_sofr, tasa)\nzcc_sofr.get_rate_at(10_959)\n</code></pre> <pre><code>0.0365940888755\n</code></pre> <pre><code>curva_sol = {\n  \"curve_code\": \"CSOFR\",\n  \"type_of_rate\": \"CON_ACT/365\",\n  \"process_date\": \"2024-06-11\",\n  \"jacobians\": {},\n  \"values\": [\n    {\n      \"tenor\": \"2D\",\n      \"maturity\": 2,\n      \"rate\": 0.05393091948998677\n    },\n    {\n      \"tenor\": \"7D\",\n      \"maturity\": 9,\n      \"rate\": 0.05391149528761137\n    },\n    {\n      \"tenor\": \"14D\",\n      \"maturity\": 16,\n      \"rate\": 0.053909500139491626\n    },\n    {\n      \"tenor\": \"1M\",\n      \"maturity\": 34,\n      \"rate\": 0.05392893501738643\n    },\n    {\n      \"tenor\": \"2M\",\n      \"maturity\": 63,\n      \"rate\": 0.053894362943625894\n    },\n    {\n      \"tenor\": \"3M\",\n      \"maturity\": 94,\n      \"rate\": 0.053843482977097415\n    },\n    {\n      \"tenor\": \"4M\",\n      \"maturity\": 125,\n      \"rate\": 0.05359443451658483\n    },\n    {\n      \"tenor\": \"5M\",\n      \"maturity\": 155,\n      \"rate\": 0.05337515689463274\n    },\n    {\n      \"tenor\": \"6M\",\n      \"maturity\": 185,\n      \"rate\": 0.05312657866085667\n    },\n    {\n      \"tenor\": \"7M\",\n      \"maturity\": 216,\n      \"rate\": 0.052777204713019304\n    },\n    {\n      \"tenor\": \"8M\",\n      \"maturity\": 247,\n      \"rate\": 0.05240381230639302\n    },\n    {\n      \"tenor\": \"9M\",\n      \"maturity\": 275,\n      \"rate\": 0.0520700981638382\n    },\n    {\n      \"tenor\": \"1Y\",\n      \"maturity\": 367,\n      \"rate\": 0.05088167612943658\n    },\n    {\n      \"tenor\": \"18M\",\n      \"maturity\": 552,\n      \"rate\": 0.04852936930616741\n    },\n    {\n      \"tenor\": \"2Y\",\n      \"maturity\": 734,\n      \"rate\": 0.04659950874645961\n    },\n    {\n      \"tenor\": \"3Y\",\n      \"maturity\": 1098,\n      \"rate\": 0.04394041235592892\n    },\n    {\n      \"tenor\": \"4Y\",\n      \"maturity\": 1463,\n      \"rate\": 0.04231284987923743\n    },\n    {\n      \"tenor\": \"5Y\",\n      \"maturity\": 1828,\n      \"rate\": 0.041317554448529636\n    },\n    {\n      \"tenor\": \"6Y\",\n      \"maturity\": 2193,\n      \"rate\": 0.04073549138440949\n    },\n    {\n      \"tenor\": \"7Y\",\n      \"maturity\": 2558,\n      \"rate\": 0.04035917885531376\n    },\n    {\n      \"tenor\": \"8Y\",\n      \"maturity\": 2925,\n      \"rate\": 0.040119782655144265\n    },\n    {\n      \"tenor\": \"9Y\",\n      \"maturity\": 3289,\n      \"rate\": 0.039975186953621844\n    },\n    {\n      \"tenor\": \"10Y\",\n      \"maturity\": 3654,\n      \"rate\": 0.03989648083295584\n    },\n    {\n      \"tenor\": \"12Y\",\n      \"maturity\": 4385,\n      \"rate\": 0.03986864130635106\n    },\n    {\n      \"tenor\": \"15Y\",\n      \"maturity\": 5480,\n      \"rate\": 0.039884006370912016\n    },\n    {\n      \"tenor\": \"20Y\",\n      \"maturity\": 7307,\n      \"rate\": 0.03940855790321542\n    },\n    {\n      \"tenor\": \"25Y\",\n      \"maturity\": 9134,\n      \"rate\": 0.03804951829543225\n    },\n    {\n      \"tenor\": \"30Y\",\n      \"maturity\": 10961,\n      \"rate\": 0.036573592658114495\n    },\n    {\n      \"tenor\": \"40Y\",\n      \"maturity\": 14612,\n      \"rate\": 0.03329402953514909\n    },\n    {\n      \"tenor\": \"50Y\",\n      \"maturity\": 18264,\n      \"rate\": 0.029736924965687982\n    }\n  ]\n}\n</code></pre> <pre><code>df_curva_sol = pd.DataFrame(curva_sol[\"values\"])\n</code></pre> <pre><code>df_curva_sol.columns = ['tenor', 'plazo', 'tasa']\nzcc_sol = zcc_from_df(df_curva_sol, tasa)\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#curvas-para-sensibilidad","title":"Curvas para Sensibilidad","text":"<p>Para calcular sensibilidad a la curva cero cup\u00f3n, se define qu\u00e9 v\u00e9rtice de la curva se quiere desplazar y el monto en puntos b\u00e1sicos del desplazamiento.</p> <pre><code>vertice = 15\nbp = 1\n</code></pre> <p>Se construyen las curvas con ese v\u00e9rtice 1 punto b\u00e1sico m\u00e1s arriba y 1 punto b\u00e1sico m\u00e1s abajo. Para esto se define una funci\u00f3n auxiliar.</p> <pre><code>def curvas_sens(\n    df: pd.DataFrame, \n    tasa: qcf.QCInterestRate, \n    vertice: int, \n    bp: float\n) -&gt; tuple[qcf.ZeroCouponCurve, qcf.ZeroCouponCurve]:\n    bp /= 10_000\n    lvec = qcf.long_vec()\n    vec_sens_up = qcf.double_vec()\n    vec_sens_down = qcf.double_vec()\n    for t in df.itertuples():\n        lvec.append(int(t.plazo))\n        if t.Index == vertice:\n            vec_sens_up.append(t.tasa + bp)\n            vec_sens_down.append(t.tasa - bp)\n        else:\n            vec_sens_up.append(t.tasa)\n            vec_sens_down.append(t.tasa)\n\n    zcc_sens_up = qcf.QCCurve(lvec, vec_sens_up)\n    lin_sens_up = qcf.QCLinearInterpolator(zcc_sens_up)\n    zz_sens_up = qcf.ZeroCouponCurve(lin_sens_up, tasa)\n\n    zcc_sens_down = qcf.QCCurve(lvec, vec_sens_down)\n    lin_sens_down = qcf.QCLinearInterpolator(zcc_sens_down)\n    zz_sens_down = qcf.ZeroCouponCurve(lin_sens_down, tasa)\n\n    return zz_sens_up, zz_sens_down\n</code></pre> <pre><code>zcc_clp_up, zcc_clp_down = curvas_sens(curva_clp, tasa, vertice, bp)\nzcc_usd_up, zcc_usd_down = curvas_sens(curva_usd, tasa, vertice, bp)\nzcc_clf_up, zcc_clf_down = curvas_sens(curva_clf, tasa, vertice, bp)\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#fixedratecashflow-leg","title":"FixedRateCashflow Leg","text":"<p>Se da de alta una pata fija:</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(13, 6, 2024)\nfecha_final = qcf.QCDate(13, 6, 2026)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad = qcf.Tenor('12M')\nperiodo_irregular = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 1_000_000.0\namort_es_flujo = True\nvalor_tasa_fija = 0.048864\nvalor_tasa_fija = 0.047134\ntasa_cupon = qcf.QCInterestRate(\n    valor_tasa_fija, \n    qcf.QCAct360(), \n    qcf.QCLinearWf()\n)\nmoneda = qcf.QCUSD()\nes_bono = False\n\nfixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad,\n    periodo_irregular,\n    calendario,\n    lag_pago,\n    nominal,\n    amort_es_flujo,\n    tasa_cupon,\n    moneda,\n    es_bono\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(fixed_rate_leg).style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-06-13 2025-06-13 2025-06-13 1,000,000.00 0.00 47,788.64 True 47,788.64 USD 4.7134% LinAct360 1 2025-06-13 2026-06-15 2026-06-15 1,000,000.00 1,000,000.00 48,050.49 True 1,048,050.49 USD 4.7134% LinAct360 <p>Se calcula ahora el valor presente:</p> <pre><code>vp_fija = pv.pv(fecha_val:=qcf.QCDate(11, 6, 2024), fixed_rate_leg, zcc_sofr)\ndias = fecha_val.day_diff(qcf.QCDate(13, 6, 2024))\nprint(f\"D\u00edas: {dias}\")\nprint(f\"Valor presente de la pata fija es: {vp_fija / zcc_sofr.get_discount_factor_at(dias) :,.0f}\")\n</code></pre> <pre><code>D\u00edas: 2\nValor presente de la pata fija es: 999,784\n</code></pre> <p>Al calcular el valor presente, tambi\u00e9n se calculan las derivadas del valor presente respecto a cada uno de los v\u00e9rtices de la curva.</p> <pre><code>der = pv.get_derivatives()\n</code></pre> <p>Con esas derivadas, se puede calcular la sensibilidad a la curva cup\u00f3n cero a un movimiento de 1 punto b\u00e1sico.</p> <pre><code>i = 0\ntotal = 0\nfor d in der:\n    total += d * bp / 10_000\n    print(f\"Sensibilidad en {i}: {d * bp / 10_000:0,.0f}\")\n    i += 1\nprint(f\"Sensibilidad total: {total:,.0f}\")\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: 0\nSensibilidad en 3: 0\nSensibilidad en 4: 0\nSensibilidad en 5: 0\nSensibilidad en 6: 0\nSensibilidad en 7: 0\nSensibilidad en 8: 0\nSensibilidad en 9: 0\nSensibilidad en 10: 0\nSensibilidad en 11: 0\nSensibilidad en 12: 0\nSensibilidad en 13: -5\nSensibilidad en 14: 0\nSensibilidad en 15: -191\nSensibilidad en 16: -1\nSensibilidad en 17: 0\nSensibilidad en 18: 0\nSensibilidad en 19: 0\nSensibilidad en 20: 0\nSensibilidad en 21: 0\nSensibilidad en 22: 0\nSensibilidad en 23: 0\nSensibilidad en 24: 0\nSensibilidad en 25: 0\nSensibilidad en 26: 0\nSensibilidad en 27: 0\nSensibilidad en 28: 0\nSensibilidad total: -196\n</code></pre> <p>Se puede verificar la sensibilidad por diferencias finitas.</p> <p>Se calcula el valor presente con las curvas desplazadas.</p> <pre><code>vp_fija_sens_up = pv.pv(fecha_hoy, fixed_rate_leg, zcc_usd_up)\nvp_fija_sens_down = pv.pv(fecha_hoy, fixed_rate_leg, zcc_usd_down)\nprint(f\"Valor presente up de la pata fija es: {vp_fija_sens_up:,.4f}\")\nprint(f\"Valor presente down de la pata fija es: {vp_fija_sens_down:,.4f}\")\n</code></pre> <pre><code>Valor presente up de la pata fija es: 1,056,008.6812\nValor presente down de la pata fija es: 1,056,012.1915\n</code></pre> <p>Finalmente, se calcula la sensibilidad (usando la aproximaci\u00f3n central por diferencias finitas).</p> <pre><code>print(f\"Sensibilidad por diferencias finitas: {(vp_fija_sens_up - vp_fija_sens_down) / 2:,.0f}\")\n</code></pre> <pre><code>Sensibilidad por diferencias finitas: -2\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#overnightindex-leg","title":"OvernightIndex Leg","text":"<p>Se da de alta una pata OvernightIndex.</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(10, 1, 2019)\nfecha_final = qcf.QCDate(10, 1, 2022)\nbus_adj_rule = qcf.BusyAdjRules.FOLLOW\nfix_adj_rule = qcf.BusyAdjRules.PREVIOUS\ndates_for_eq_rate = qcf.DatesForEquivalentRate.ACCRUAL\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 38_000_000_000.0\namort_es_flujo = True\nspread = .0\ngearing = 1.0\n\novernight_index_leg = qcf.LegFactory.build_bullet_overnight_index_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    fix_adj_rule=fix_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    fixing_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    index_name='ICPCLP',\n    eq_rate_decimal_places=4,\n    notional_currency=qcf.QCCLP(),\n    dates_for_eq_rate=dates_for_eq_rate,\n    sett_lag_behaviour=qcf.SettLagBehaviour.DONT_MOVE,\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(overnight_index_leg).style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa tipo_tasa interes flujo spread gearing 0 2019-01-10 2019-07-10 2019-01-10 2019-07-10 2019-07-10 38,000,000,000.00 0.00 True CLP ICPCLP 1.00 1.00 0.0000% LinAct360 0.00 0.00 0.0000% 1.00 1 2019-07-10 2020-01-10 2019-07-10 2020-01-10 2020-01-10 38,000,000,000.00 0.00 True CLP ICPCLP 1.00 1.00 0.0000% LinAct360 0.00 0.00 0.0000% 1.00 2 2020-01-10 2020-07-10 2020-01-10 2020-07-10 2020-07-10 38,000,000,000.00 0.00 True CLP ICPCLP 1.00 1.00 0.0000% LinAct360 0.00 0.00 0.0000% 1.00 3 2020-07-10 2021-01-11 2020-07-10 2021-01-11 2021-01-11 38,000,000,000.00 0.00 True CLP ICPCLP 1.00 1.00 0.0000% LinAct360 0.00 0.00 0.0000% 1.00 4 2021-01-11 2021-07-12 2021-01-11 2021-07-12 2021-07-12 38,000,000,000.00 0.00 True CLP ICPCLP 1.00 1.00 0.0000% LinAct360 0.00 0.00 0.0000% 1.00 5 2021-07-12 2022-01-10 2021-07-12 2022-01-10 2022-01-10 38,000,000,000.00 38,000,000,000.00 True CLP ICPCLP 1.00 1.00 0.0000% LinAct360 0.00 38,000,000,000.00 0.0000% 1.00 <p>Notar que al dar de alta un Leg con OvernightIndexCashflow, los valores futuros de los \u00edndeces son los default (=1.0). Por lo tanto, el primer paso para valorizar estos cashflows, es calcular los valores forward de los \u00edndices.</p> <p>Se da de alta un objeto de tipo <code>ForwardRates</code>.</p> <pre><code>fwd_rates = qcf.ForwardRates()\n</code></pre> <p>Se calculan los \u00edndices forward.</p> <pre><code>icp_val = 18_890.34 # icp a la fecha de proceso\nfecha_hoy = qcf.QCDate(8, 1, 2019)\nindex = 0\n\nfor i in range(overnight_index_leg.size()):\n    cashflow = overnight_index_leg.get_cashflow_at(i)\n    if cashflow.get_start_date() &lt;= fecha_hoy &lt;= cashflow.get_end_date():\n        index = i\n\nicp_fecha_inicio_cupon_vigente = 18_376.69\novernight_index_leg.get_cashflow_at(index).set_start_date_index(icp_fecha_inicio_cupon_vigente)\n\nfwd_rates.set_rates_overnight_index_leg(fecha_hoy, icp_val, overnight_index_leg, zcc_clp)\n</code></pre> <pre><code>aux.leg_as_dataframe(overnight_index_leg).style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa tipo_tasa interes flujo spread gearing 0 2019-01-10 2019-07-10 2019-01-10 2019-07-10 2019-07-10 38,000,000,000.00 0.00 True CLP ICPCLP 18,892.15 19,015.28 1.3000% LinAct360 248,372,222.00 248,372,222.00 0.0000% 1.00 1 2019-07-10 2020-01-10 2019-07-10 2020-01-10 2020-01-10 38,000,000,000.00 0.00 True CLP ICPCLP 19,015.28 19,138.86 1.2700% LinAct360 246,662,222.00 246,662,222.00 0.0000% 1.00 2 2020-01-10 2020-07-10 2020-01-10 2020-07-10 2020-07-10 38,000,000,000.00 0.00 True CLP ICPCLP 19,138.86 19,264.34 1.3000% LinAct360 249,744,444.00 249,744,444.00 0.0000% 1.00 3 2020-07-10 2021-01-11 2020-07-10 2021-01-11 2021-01-11 38,000,000,000.00 0.00 True CLP ICPCLP 19,264.34 19,388.80 1.2600% LinAct360 246,050,000.00 246,050,000.00 0.0000% 1.00 4 2021-01-11 2021-07-12 2021-01-11 2021-07-12 2021-07-12 38,000,000,000.00 0.00 True CLP ICPCLP 19,388.80 19,550.81 1.6500% LinAct360 316,983,333.00 316,983,333.00 0.0000% 1.00 5 2021-07-12 2022-01-10 2021-07-12 2022-01-10 2022-01-10 38,000,000,000.00 38,000,000,000.00 True CLP ICPCLP 19,550.81 19,728.77 1.8000% LinAct360 345,800,000.00 38,345,800,000.00 0.0000% 1.00 <p>Con esto, podemos calcular el valor presente.</p> <pre><code>vp_on_index_leg = pv.pv(fecha_hoy, overnight_index_leg, zcc_clp)\nprint(f\"Valor presente pata ON Index Leg: {vp_on_index_leg:,.0f}\")\n</code></pre> <pre><code>Valor presente pata ON Index Leg: 37,996,356,295\n</code></pre> <pre><code>print(f\"{nominal * zcc_clp.get_discount_factor_at(2):,.0f}\")\n</code></pre> <pre><code>37,996,356,295\n</code></pre> <p>Tambi\u00e9n en este caso es posible calcular la sensibilidad a la curva de descuento.</p> <pre><code>der = pv.get_derivatives()\ni = 0\nfor d in der:\n    print(f\"Sensibilidad en {i:}: {d * bp / 10_000:0,.0f}\")\n    i += 1\nsens_disc = [d * bp / 10_000 for d in der]\nprint()\nprint(\"Sensibilidad de descuento: {0:,.0f} CLP\".format(sum(sens_disc)))\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: -670\nSensibilidad en 3: -11,665\nSensibilidad en 4: -545\nSensibilidad en 5: -24,764\nSensibilidad en 6: -35,947\nSensibilidad en 7: -116,962\nSensibilidad en 8: -11,053,193\nSensibilidad en 9: 0\nSensibilidad en 10: 0\nSensibilidad en 11: 0\nSensibilidad en 12: 0\nSensibilidad en 13: 0\nSensibilidad en 14: 0\nSensibilidad en 15: 0\nSensibilidad en 16: 0\nSensibilidad en 17: 0\nSensibilidad en 18: 0\n\nSensibilidad de descuento: -11,243,745 CLP\n</code></pre> <p>La estructura es la misma que para una pata fija, lo que indica que se debe tambi\u00e9n incluir la sensibilidad a la curva de proyecci\u00f3n.</p> <pre><code>result = []\nfor i in range(overnight_index_leg.size()):\n    cshflw = overnight_index_leg.get_cashflow_at(i)\n    amt_der = cshflw.get_amount_derivatives()\n    df = zcc_clp.get_discount_factor_at(fecha_hoy.day_diff(cshflw.get_settlement_date()))\n    amt_der = [a * bp / 10_000  * df for a in amt_der]\n    if len(amt_der) &gt; 0:\n        result.append(np.array(amt_der))\ntotal = result[0] * 0\n\nfor r in result:\n    total += r\n\nfor i in range(len(total)):\n    print(\"Sensibilidad en {0:}: {1:0,.0f}\".format(i, total[i]))\n\nprint()\nprint(\"Sensibilidad de proyecci\u00f3n: {0:,.0f} CLP\".format(sum(total)))\n</code></pre> <pre><code>Sensibilidad en 0: -13,880\nSensibilidad en 1: -6,940\nSensibilidad en 2: 670\nSensibilidad en 3: 11,665\nSensibilidad en 4: 545\nSensibilidad en 5: 24,764\nSensibilidad en 6: 35,947\nSensibilidad en 7: 116,962\nSensibilidad en 8: 11,053,193\nSensibilidad en 9: 0\nSensibilidad en 10: 0\nSensibilidad en 11: 0\nSensibilidad en 12: 0\nSensibilidad en 13: 0\nSensibilidad en 14: 0\nSensibilidad en 15: 0\nSensibilidad en 16: 0\nSensibilidad en 17: 0\nSensibilidad en 18: 0\n\nSensibilidad de proyecci\u00f3n: 11,222,925 CLP\n</code></pre> <p>Como se espera de una pata OvernightIndex (con lag de pago igual a 0 y spread igual a 0), ambas sensibilidades se cancelan.</p>"},{"location":"4_Valorizacion_Sensibilidad/#se-verifica-la-sensibilidad-de-proyeccion-por-diferencias-finitas","title":"Se verifica la sensibilidad de proyecci\u00f3n por diferencias finitas:","text":"<pre><code>fwd_rates.set_rates_overnight_index_leg(fecha_hoy, icp_val, overnight_index_leg, zcc_clp_up)\nvp_on_index_leg_up = pv.pv(fecha_hoy, overnight_index_leg, zcc_clp)\n\nfwd_rates.set_rates_overnight_index_leg(fecha_hoy, icp_val, overnight_index_leg, zcc_clp_down)\nvp_on_index_leg_down = pv.pv(fecha_hoy, overnight_index_leg, zcc_clp)\n\nprint(f\"Sensibilidad en v\u00e9rtice {vertice}: {(vp_on_index_leg_up - vp_on_index_leg_down) / 2:,.0f} CLP\")\n</code></pre> <pre><code>Sensibilidad en v\u00e9rtice 15: 0 CLP\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#iborcashflow-leg","title":"IborCashflow Leg","text":"<p>Se da de alta una pata de tipo IborCashflow.</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(12, 11, 2019)\nfecha_final = qcf.QCDate(12, 5, 2021)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nperiodicidad_fijacion = qcf.Tenor('6M')\nperiodo_irregular_fijacion = qcf.StubPeriod.NO\n\n# vamos a usar el mismo calendario para pago y fijaciones\nlag_de_fijacion = 2\n\n# Definici\u00f3n del \u00edndice\ncodigo = 'TERSOFR6M'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('2d')\ntenor = qcf.Tenor('6m')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\ntermsofr_6m = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd\n)\n# Fin \u00edndice\n\nnominal = 20_000_000.0\namort_es_flujo = True\nmoneda = usd\nspread = .0\ngearing = 1.0\n\nibor_leg = qcf.LegFactory.build_bullet_ibor_leg(\n    rp, \n    fecha_inicio, \n    fecha_final, \n    bus_adj_rule, \n    periodicidad_pago,\n    periodo_irregular_pago, \n    calendario, \n    lag_pago,\n    periodicidad_fijacion, \n    periodo_irregular_fijacion,\n    calendario, \n    lag_de_fijacion, \n    termsofr_6m,\n    nominal, \n    amort_es_flujo, \n    moneda, \n    spread, \n    gearing\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(ibor_leg).style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2019-11-12 2020-05-12 2019-11-08 2020-05-12 20,000,000.00 0.00 0.00 True 0.00 USD TERSOFR6M 0.0000% 0.0000% 1.00 LinAct360 1 2020-05-12 2020-11-12 2020-05-08 2020-11-12 20,000,000.00 0.00 0.00 True 0.00 USD TERSOFR6M 0.0000% 0.0000% 1.00 LinAct360 2 2020-11-12 2021-05-12 2020-11-10 2021-05-12 20,000,000.00 20,000,000.00 0.00 True 20,000,000.00 USD TERSOFR6M 0.0000% 0.0000% 1.00 LinAct360 <pre><code>valor_termsofr_6m = 0.02\nfecha_hoy = qcf.QCDate(25, 2, 2020)\nibor_leg.get_cashflow_at(0).set_interest_rate_value(valor_termsofr_6m)\nfwd_rates.set_rates_ibor_leg1(fecha_hoy, ibor_leg, zcc_usd)\n</code></pre> <pre><code>aux.leg_as_dataframe(ibor_leg).style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_fixing fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2019-11-12 2020-05-12 2019-11-08 2020-05-12 20,000,000.00 0.00 202,222.22 True 202,222.22 USD TERSOFR6M 2.0000% 0.0000% 1.00 LinAct360 1 2020-05-12 2020-11-12 2020-05-08 2020-11-12 20,000,000.00 0.00 169,878.64 True 169,878.64 USD TERSOFR6M 1.6619% 0.0000% 1.00 LinAct360 2 2020-11-12 2021-05-12 2020-11-10 2021-05-12 20,000,000.00 20,000,000.00 155,899.59 True 20,155,899.59 USD TERSOFR6M 1.5504% 0.0000% 1.00 LinAct360 <p>Se verifica la tasa forward del segundo cashflow.</p> <pre><code>which_cashflow = 1\nd1 = fecha_hoy.day_diff(ibor_leg.get_cashflow_at(which_cashflow).get_start_date())\nd2 = fecha_hoy.day_diff(ibor_leg.get_cashflow_at(which_cashflow).get_end_date())\nprint(f\"d1: {d1:,.0f}\")\nprint(f\"d2: {d2:,.0f}\")\ncrv = zcc_usd\nw1 = 1 / crv.get_discount_factor_at(d1)\nw2 = 1 / crv.get_discount_factor_at(d2)\nprint(f\"Factor forward: {w2 / w1:.4%}\")\nprint(f\"Tasa forward: {(w2 / w1 - 1) * 360 / (d2 - d1):.4%}\")\nprint(f\"Curve method {crv.get_forward_rate_with_rate(termsofr_6m.get_rate(), d1, d2):.4%}\")\n</code></pre> <pre><code>d1: 77\nd2: 261\nFactor forward: 100.8494%\nTasa forward: 1.6619%\nCurve method 1.6619%\n</code></pre> <p>C\u00e1lculo de valor presente.</p> <pre><code>vp_ibor = pv.pv(fecha_hoy, ibor_leg, zcc_usd)\nprint(f\"Valor presente pata IBOR: {vp_ibor:,.0f}\")\n</code></pre> <pre><code>Valor presente pata IBOR: 20,126,209\n</code></pre> <p>Derivadas del valor presente.</p> <pre><code>der = pv.get_derivatives()\ni = 0\nfor d in der:\n    print(f\"Sensibilidad en {i}: {d * bp / 10_000:0,.0f}\")\n    i += 1\nprint()\nprint(f\"Sensibilidad de descuento: {sum(der) * bp / 10_000:,.0f} USD\")\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: 0\nSensibilidad en 3: 0\nSensibilidad en 4: 0\nSensibilidad en 5: -2\nSensibilidad en 6: -2\nSensibilidad en 7: 0\nSensibilidad en 8: 0\nSensibilidad en 9: 0\nSensibilidad en 10: 0\nSensibilidad en 11: -6\nSensibilidad en 12: -6\nSensibilidad en 13: 0\nSensibilidad en 14: 0\nSensibilidad en 15: -1,407\nSensibilidad en 16: -986\nSensibilidad en 17: 0\nSensibilidad en 18: 0\nSensibilidad en 19: 0\nSensibilidad en 20: 0\nSensibilidad en 21: 0\nSensibilidad en 22: 0\nSensibilidad en 23: 0\nSensibilidad en 24: 0\nSensibilidad en 25: 0\nSensibilidad en 26: 0\nSensibilidad en 27: 0\n\nSensibilidad de descuento: -2,409 USD\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#se-verifica-la-sensibilidad-de-descuento-por-diferencias-finitas","title":"Se verifica la sensibilidad de descuento por diferencias finitas.","text":"<pre><code>vp_ibor_up = pv.pv(fecha_hoy, ibor_leg, zcc_usd_up)\nprint(f\"Valor presente up pata IBOR: {vp_ibor_up:,.0f}\")\n\nvp_ibor_down = pv.pv(fecha_hoy, ibor_leg, zcc_usd_down)\nprint(f\"Valor presente down pata IBOR: {vp_ibor_down:,.0f}\")\n\nprint(f\"Sensibilidad de descuento en el v\u00e9rtice {vertice}: {(vp_ibor_up - vp_ibor_down) / 2:,.0f}\")\n</code></pre> <pre><code>Valor presente up pata IBOR: 20,124,803\nValor presente down pata IBOR: 20,127,616\nSensibilidad de descuento en el v\u00e9rtice 15: -1,407\n</code></pre> <p>Se calcula tambi\u00e9n la sensibilidad a la curva de proyecci\u00f3n.</p> <pre><code>result = []\n\nfor i in range(ibor_leg.size()):\n    cshflw = ibor_leg.get_cashflow_at(i)\n    df = zcc_usd.get_discount_factor_at(fecha_hoy.day_diff(cshflw.get_settlement_date()))\n    amt_der = cshflw.get_amount_derivatives()\n    if len(amt_der) &gt; 0:\n        amt_der = [a * bp / 10_000 * df for a in amt_der]\n        result.append(np.array(amt_der))\n\ntotal = result[0] * 0\nfor r in result:\n    total += r\n\nfor i in range(len(total)):\n    print(f\"Sensibilidad en {i}: {total[i]:0,.0f}\")\nprint()\nprint(f\"Sensibilidad de proyecci\u00f3n: {sum(total):,.0f} USD\")\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: 0\nSensibilidad en 3: 0\nSensibilidad en 4: 0\nSensibilidad en 5: -190\nSensibilidad en 6: -231\nSensibilidad en 7: 0\nSensibilidad en 8: 0\nSensibilidad en 9: 0\nSensibilidad en 10: 0\nSensibilidad en 11: 6\nSensibilidad en 12: 6\nSensibilidad en 13: 0\nSensibilidad en 14: 0\nSensibilidad en 15: 1,407\nSensibilidad en 16: 986\nSensibilidad en 17: 0\nSensibilidad en 18: 0\nSensibilidad en 19: 0\nSensibilidad en 20: 0\nSensibilidad en 21: 0\nSensibilidad en 22: 0\nSensibilidad en 23: 0\nSensibilidad en 24: 0\nSensibilidad en 25: 0\nSensibilidad en 26: 0\nSensibilidad en 27: 0\n\nSensibilidad de proyecci\u00f3n: 1,984 USD\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#se-verifica-la-sensibilidad-de-proyeccion-por-diferencias-finitas_1","title":"Se verifica la sensibilidad de proyecci\u00f3n por diferencias finitas.","text":"<pre><code>fwd_rates.set_rates_ibor_leg1(fecha_hoy, ibor_leg, zcc_usd_up)\nvp_ibor_up = pv.pv(fecha_hoy, ibor_leg, zcc_usd)\nprint(f\"Valor presente up pata IBOR: {vp_ibor_up:,.0f}\")\n\nfwd_rates.set_rates_ibor_leg1(fecha_hoy, ibor_leg, zcc_usd_down)\nvp_ibor_down = pv.pv(fecha_hoy, ibor_leg, zcc_usd)\nprint(f\"Valor presente down pata IBOR: {vp_ibor_down:,.0f}\")\n\nprint(f\"Sensibilidad de proyecci\u00f3n en el v\u00e9rtice {vertice}: {(vp_ibor_up - vp_ibor_down) / 2:,.0f}\")\n</code></pre> <pre><code>Valor presente up pata IBOR: 20,127,616\nValor presente down pata IBOR: 20,124,803\nSensibilidad de proyecci\u00f3n en el v\u00e9rtice 15: 1,407\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#icpclfcashflow-leg","title":"IcpClfCashflow Leg","text":"<p>Se da de alta una pata de tipo IcpClfCashflow.</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 5, 2018)\nfecha_final = qcf.QCDate(31, 3, 2021) \nbus_adj_rule = qcf.BusyAdjRules.FOLLOW\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 300_000.0\namort_es_flujo = True \nspread = .0\ngearing = 1.0\n\nicp_clf_leg = qcf.LegFactory.build_bullet_icp_clf_leg(\n    rp, \n    fecha_inicio, \n    fecha_final, \n    bus_adj_rule, \n    periodicidad_pago,\n    periodo_irregular_pago, \n    calendario, \n    lag_pago,\n    nominal, \n    amort_es_flujo, \n    spread, \n    gearing\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(icp_clf_leg).style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion amort_es_flujo flujo moneda_nocional icp_inicial icp_final uf_inicial uf_final valor_tasa interes spread gearing tipo_tasa flujo_en_clp 0 2018-05-31 2018-10-31 2018-10-31 300,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 0.00 1 2018-10-31 2019-04-30 2019-04-30 300,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 0.00 2 2019-04-30 2019-10-31 2019-10-31 300,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 0.00 3 2019-10-31 2020-04-30 2020-04-30 300,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 0.00 4 2020-04-30 2020-11-02 2020-11-02 300,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 0.00 5 2020-11-02 2021-04-30 2021-04-30 300,000.00 300,000.00 True 300,000.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 10,500,000,000.00 <pre><code>icp_hoy = 18_882.07\nuf_hoy = 28_440.19\nfwd_rates.set_rates_icp_clf_leg(fecha_hoy, icp_hoy, uf_hoy, icp_clf_leg, zcc_clp, zcc_clp, zcc_clf)\ncshflw = icp_clf_leg.get_cashflow_at(3)\ncshflw.set_start_date_uf(28_080.26)\ncshflw.set_start_date_icp(18_786.13)\n</code></pre> <pre><code>aux.leg_as_dataframe(icp_clf_leg).style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion amort_es_flujo flujo moneda_nocional icp_inicial icp_final uf_inicial uf_final valor_tasa interes spread gearing tipo_tasa flujo_en_clp 0 2018-05-31 2018-10-31 2018-10-31 300,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 0.00 1 2018-10-31 2019-04-30 2019-04-30 300,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 0.00 2 2019-04-30 2019-10-31 2019-10-31 300,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 0.00 3 2019-10-31 2020-04-30 2020-04-30 300,000.00 0.00 True -3,401.28 CLF 18,786.13 18,935.12 28,080.26 28,627.71 -2.2426% -3,401.28 0.0000% 1.00 LinAct360 -97,370,764.00 4 2020-04-30 2020-11-02 2020-11-02 300,000.00 0.00 True -2,589.43 CLF 18,935.12 19,050.65 28,627.71 29,053.02 -1.6706% -2,589.43 0.0000% 1.00 LinAct360 -75,230,762.00 5 2020-11-02 2021-04-30 2021-04-30 300,000.00 300,000.00 True 298,044.72 CLF 19,050.65 19,173.77 29,053.02 29,432.64 -1.3108% -1,955.28 0.0000% 1.00 LinAct360 8,772,243,383.00 <pre><code>vp_icp_clf = pv.pv(fecha_hoy, icp_clf_leg, zcc_clf)\nprint(f\"Valor presente en UF: {vp_icp_clf:,.2f}\")\nprint(f\"Valor presente en CLP: {vp_icp_clf * uf_hoy:,.0f}\")\n</code></pre> <pre><code>Valor presente en UF: 297,715.99\nValor presente en CLP: 8,467,099,423\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#sensibilidad-de-descuento","title":"Sensibilidad de Descuento","text":"<pre><code>der = pv.get_derivatives()\ni = 0\nfor d in der:\n    print(f\"Sensibilidad en {i}: {d * bp / 10_000:0,.2f}\")\n    i += 1\nprint()\nprint(f\"Sensibilidad de descuento: {sum(der) * bp / 10_000:,.2f} CLF\")\n</code></pre> <pre><code>Sensibilidad en 0: 0.00\nSensibilidad en 1: 0.00\nSensibilidad en 2: 0.00\nSensibilidad en 3: 0.06\nSensibilidad en 4: 0.00\nSensibilidad en 5: 0.00\nSensibilidad en 6: 0.00\nSensibilidad en 7: 0.00\nSensibilidad en 8: 0.00\nSensibilidad en 9: 0.17\nSensibilidad en 10: 0.01\nSensibilidad en 11: 0.00\nSensibilidad en 12: 0.00\nSensibilidad en 13: 0.00\nSensibilidad en 14: 0.00\nSensibilidad en 15: -33.62\nSensibilidad en 16: -2.17\nSensibilidad en 17: 0.00\nSensibilidad en 18: 0.00\nSensibilidad en 19: 0.00\nSensibilidad en 20: 0.00\nSensibilidad en 21: 0.00\nSensibilidad en 22: 0.00\nSensibilidad en 23: 0.00\nSensibilidad en 24: 0.00\nSensibilidad en 25: 0.00\nSensibilidad en 26: 0.00\nSensibilidad en 27: 0.00\nSensibilidad en 28: 0.00\nSensibilidad en 29: 0.00\nSensibilidad en 30: 0.00\nSensibilidad en 31: 0.00\nSensibilidad en 32: 0.00\n\nSensibilidad de descuento: -35.54 CLF\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#sensibilidad-de-proyeccion","title":"Sensibilidad de Proyecci\u00f3n","text":"<pre><code>result = []\nfor i in range(icp_clf_leg.size()):\n    cshflw = icp_clf_leg.get_cashflow_at(i)\n    df = zcc_clf.get_discount_factor_at(fecha_hoy.day_diff(cshflw.date()))\n    amt_der = cshflw.get_amount_ufclf_derivatives()\n    if len(amt_der) &gt; 0:\n        amt_der = [a * bp / 10_000 * df for a in amt_der]\n        result.append(np.array(amt_der))\n\ntotal = result[0] * 0\nfor r in result:\n    total += r\n\nfor i in range(len(total)):\n    print(f\"Sensibilidad en {i}: {total[i]:0,.2f}\")\n</code></pre> <pre><code>Sensibilidad en 0: 0.00\nSensibilidad en 1: 0.00\nSensibilidad en 2: 0.00\nSensibilidad en 3: -0.06\nSensibilidad en 4: -0.00\nSensibilidad en 5: 0.00\nSensibilidad en 6: 0.00\nSensibilidad en 7: 0.00\nSensibilidad en 8: 0.00\nSensibilidad en 9: -0.17\nSensibilidad en 10: -0.01\nSensibilidad en 11: 0.00\nSensibilidad en 12: 0.00\nSensibilidad en 13: 0.00\nSensibilidad en 14: 0.00\nSensibilidad en 15: 33.62\nSensibilidad en 16: 2.17\nSensibilidad en 17: 0.00\nSensibilidad en 18: 0.00\nSensibilidad en 19: 0.00\nSensibilidad en 20: 0.00\nSensibilidad en 21: 0.00\nSensibilidad en 22: 0.00\nSensibilidad en 23: 0.00\nSensibilidad en 24: 0.00\nSensibilidad en 25: 0.00\nSensibilidad en 26: 0.00\nSensibilidad en 27: 0.00\nSensibilidad en 28: 0.00\nSensibilidad en 29: 0.00\nSensibilidad en 30: 0.00\nSensibilidad en 31: 0.00\nSensibilidad en 32: 0.00\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#compoundedovernightrate-leg","title":"CompoundedOvernightRate Leg","text":"<p>Se da de alta una pata de tipo CompoundedOvernightRate.</p> <pre><code>rp = qcf.RecPay.PAY\nfecha_inicio = qcf.QCDate(13, 6, 2024)\nfecha_final = qcf.QCDate(13, 12, 2025)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('12M')\nperiodo_irregular_pago = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nlookback = 0\n\n######################################################################\n# Definici\u00f3n del \u00edndice\n\ncodigo = 'OISTEST'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('0d')\ntenor = qcf.Tenor('1d')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\noistest = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd)\n\n# Fin \u00edndice\n######################################################################\n\nnominal = 1_000_000.0\namort_es_flujo = True\nmoneda = usd\nspread = .0\ngearing = 1.0\n\ncor_leg = qcf.LegFactory.build_bullet_compounded_overnight_rate_leg_2(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad_pago,\n    periodo_irregular_pago,\n    calendario,\n    lag_pago,\n    calendario,\n    oistest,\n    nominal,\n    amort_es_flujo,\n    usd,\n    spread,\n    gearing,\n    qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    10,\n    lookback,\n    0\n)\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#valor-presente","title":"Valor Presente","text":"<pre><code>ts = qcf.time_series()\nfwd_rates.set_rates_compounded_overnight_leg2(\n    fecha_inicio,\n    cor_leg,\n    zcc_sofr,\n    ts\n)\n</code></pre> <pre><code>aux.leg_as_dataframe(cor_leg).style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional codigo_indice_tasa tipo_tasa valor_tasa spread gearing 0 2024-06-13 2024-12-13 2024-12-13 -1,000,000.00 0.00 -27,002.51 True -27,002.51 USD OISTEST LinAct360 5.3120% 0.0000% 1.00 1 2024-12-13 2025-12-15 2025-12-15 -1,000,000.00 -1,000,000.00 -47,599.76 True -1,047,599.76 USD OISTEST LinAct360 4.6692% 0.0000% 1.00 <pre><code>print(f'Valor presente: {pv.pv(fecha_inicio, cor_leg, zcc_sofr):,.0f}')\n</code></pre> <pre><code>Valor presente: -1,000,000\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#sensibilidad-de-proyeccion_1","title":"Sensibilidad de Proyecci\u00f3n","text":"<pre><code>proj_sens_by_cashflow = np.array([np.array(\n    np.array(cor_leg.get_cashflow_at(i).get_amount_derivatives()) *\n    zcc_usd.get_discount_factor_at(fecha_hoy.day_diff(cor_leg.get_cashflow_at(i).get_settlement_date())) * bp / 10_000)\n                             for i in range(cor_leg.size())])\nproj_sens = np.sum(proj_sens_by_cashflow, axis=0)\nfor i, s in enumerate(proj_sens):\n     print(f\"Sensibilidad en {i}: {s:0,.2f}\")\n</code></pre> <pre><code>Sensibilidad en 0: 0.00\nSensibilidad en 1: 0.00\nSensibilidad en 2: 0.00\nSensibilidad en 3: 0.00\nSensibilidad en 4: 0.00\nSensibilidad en 5: 0.00\nSensibilidad en 6: 0.00\nSensibilidad en 7: 0.00\nSensibilidad en 8: 0.00\nSensibilidad en 9: 0.06\nSensibilidad en 10: 0.00\nSensibilidad en 11: 0.00\nSensibilidad en 12: 0.00\nSensibilidad en 13: 0.00\nSensibilidad en 14: -143.41\nSensibilidad en 15: 0.00\nSensibilidad en 16: 0.00\nSensibilidad en 17: 0.00\nSensibilidad en 18: 0.00\nSensibilidad en 19: 0.00\nSensibilidad en 20: 0.00\nSensibilidad en 21: 0.00\nSensibilidad en 22: 0.00\nSensibilidad en 23: 0.00\nSensibilidad en 24: 0.00\nSensibilidad en 25: 0.00\nSensibilidad en 26: 0.00\nSensibilidad en 27: 0.00\nSensibilidad en 28: 0.00\n</code></pre> <p>Verifica sensibilidad de proyecci\u00f3n.</p> <pre><code>fwd_rates.set_rates_compounded_overnight_leg2(fecha_hoy, cor_leg, zcc_usd_up, ts)\nvp_cor_up = pv.pv(fecha_hoy, cor_leg, zcc_usd)\nprint(f\"Valor presente up pata CompoundedOvernightRate: {vp_cor_up:,.0f}\")\n\nfwd_rates.set_rates_compounded_overnight_leg2(fecha_hoy, cor_leg, zcc_usd_down, ts)\nvp_cor_down = pv.pv(fecha_hoy, cor_leg, zcc_usd)\nprint(f\"Valor presente down pata CompoundedOvernightRate: {vp_cor_down:,.0f}\")\n\nprint(f\"Sensibilidad de proyecci\u00f3n en el v\u00e9rtice {vertice}: {(vp_cor_up - vp_cor_down) / 2:,.2f}\")\n</code></pre> <pre><code>Valor presente up pata CompoundedOvernightRate: -933,530\nValor presente down pata CompoundedOvernightRate: -933,530\nSensibilidad de proyecci\u00f3n en el v\u00e9rtice 15: 0.00\n</code></pre>"},{"location":"4_Valorizacion_Sensibilidad/#sensibilidad-de-descuento_1","title":"Sensibilidad de Descuento","text":"<pre><code>disc_der = np.array(pv.get_derivatives()) * bp / 10_000\nfor i, s in enumerate(disc_der):\n    print(f\"Sensibilidad en {i}: {s:0,.2f}\")\n</code></pre> <pre><code>Sensibilidad en 0: 0.00\nSensibilidad en 1: 0.00\nSensibilidad en 2: 0.00\nSensibilidad en 3: 0.00\nSensibilidad en 4: 0.00\nSensibilidad en 5: 0.00\nSensibilidad en 6: 0.00\nSensibilidad en 7: 0.00\nSensibilidad en 8: 0.00\nSensibilidad en 9: 0.00\nSensibilidad en 10: 0.00\nSensibilidad en 11: 0.00\nSensibilidad en 12: 0.00\nSensibilidad en 13: 0.00\nSensibilidad en 14: 0.00\nSensibilidad en 15: 0.00\nSensibilidad en 16: 0.00\nSensibilidad en 17: 0.00\nSensibilidad en 18: 0.00\nSensibilidad en 19: 0.79\nSensibilidad en 20: 325.17\nSensibilidad en 21: 215.45\nSensibilidad en 22: 0.00\nSensibilidad en 23: 0.00\nSensibilidad en 24: 0.00\nSensibilidad en 25: 0.00\nSensibilidad en 26: 0.00\nSensibilidad en 27: 0.00\n</code></pre> <p>Verifica la sensibilidad de descuento.</p> <pre><code>fwd_rates.set_rates_compounded_overnight_leg2(fecha_hoy, cor_leg, zcc_usd, ts)\nvp_cor_up = pv.pv(fecha_hoy, cor_leg, zcc_usd_up)\nprint(f\"Valor presente up pata CompoundedOvernightRate: {vp_cor_up:,.2f}\")\n\nfwd_rates.set_rates_compounded_overnight_leg2(fecha_hoy, cor_leg, zcc_usd, ts)\nvp_cor_down = pv.pv(fecha_hoy, cor_leg, zcc_usd_down)\nprint(f\"Valor presente down pata CompoundedOvernightRate: {vp_cor_down:,.2f}\")\n\nprint(f\"Sensibilidad de descuento en el v\u00e9rtice {vertice}: {(vp_cor_up - vp_cor_down) / 2:,.2f}\")\n</code></pre> <pre><code>Valor presente up pata CompoundedOvernightRate: -933,530.48\nValor presente down pata CompoundedOvernightRate: -933,530.48\nSensibilidad de descuento en el v\u00e9rtice 15: 0.00\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"5_SwapICPCLP/","title":"Configurar un SwapICPCLP de Mercado","text":"<p>Se muestra una forma posible de configurar una operaci\u00f3n de Swap ICPCLP de mercado. Se definir\u00e1n algunos par\u00e1metros por default y s\u00f3lo ser\u00e1 necesario especificar el nocional, el plazo, el valor de la tasa fija y si \u00e9sta se recibe o se paga para obtener la estructura completa.</p> <p>Para ejecutar todos los ejemplos se debe importar la librer\u00eda. Se sugiere utilizar siempre el alias <code>qcf</code>. </p> <pre><code>import qcfinancial as qcf\nimport aux_functions as aux\n</code></pre> <p>Se verifica la versi\u00f3n y build de <code>qcfinancial</code>.</p>"},{"location":"5_SwapICPCLP/#parametros-por-default-de-la-operacion","title":"Par\u00e1metros por Default de la Operaci\u00f3n","text":"<p>Se comienza estableciendo una fecha de trade y dando de alta un <code>dict</code> con los par\u00e1metros por default comunes y los espec\u00edficos de ambas patas.</p> <pre><code>trade_date = qcf.QCDate(14, 6, 2024)\n</code></pre> <pre><code>both_default_values = {\n    \"bus_adj_rule\": qcf.BusyAdjRules.MODFOLLOW,\n    \"settlement_calendar\": qcf.BusinessCalendar(trade_date, 20),\n    \"settlement_stub_period\": qcf.StubPeriod.NO,\n    \"settlement_lag\": 1,\n    \"amort_is_cashflow\": False,\n    \"notional_currency\": qcf.QCCLP(),\n    \"sett_lag_behaviour\": qcf.SettLagBehaviour.DONT_MOVE\n}\n\nicpclp_default_values = {\n    \"fix_adj_rule\": qcf.BusyAdjRules.MODFOLLOW,\n    \"fixing_calendar\": qcf.BusinessCalendar(trade_date, 20),\n    \"dates_for_eq_rate\": qcf.DatesForEquivalentRate.ACCRUAL,\n    \"interest_rate\": qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    \"eq_rate_decimal_places\": 4,\n}\n\nfixed_rate_default_values = {\n    \"is_bond\":False,  \n}\n</code></pre>"},{"location":"5_SwapICPCLP/#pata-fija","title":"Pata Fija","text":"<p>Se da de alta los par\u00e1metros variables de la pata fija. Notar la utilizaci\u00f3n del par\u00e1metro auxiliar <code>maturity</code> que permite calcular la fecha final.</p> <pre><code>str_maturity = \"1Y\"\nmaturity = qcf.Tenor(str_maturity)\nmeses = maturity.get_months() + 12 * maturity.get_years()\n</code></pre> <p>Se da de alta el objeto.</p> <pre><code>fixed_rate_value = .03\nfixed_rate_leg_other_values = {\n    \"settlement_periodicity\": qcf.Tenor('2Y') if str_maturity in ['1M', '2M', '3M', '6M', '9M', '12M', '1Y', '18M'] else qcf.Tenor('6M'),\n    \"rec_pay\": qcf.RecPay.RECEIVE,\n    \"initial_notional\": 1_000_000_000.0,\n    \"start_date\": (start_date:=qcf.QCDate(18, 6, 2024)),\n    \"end_date\": start_date.add_months(meses),\n    \"interest_rate\": qcf.QCInterestRate(fixed_rate_value, qcf.QCAct360(), qcf.QCLinearWf()),  \n}\n</code></pre> <pre><code>fixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    **(both_default_values | fixed_rate_default_values | fixed_rate_leg_other_values)\n)\n</code></pre> <p>Se visualiza el resultado.</p> <pre><code>aux.leg_as_dataframe(fixed_rate_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-06-18 2025-06-18 2025-06-19 1,000,000,000.00 1,000,000,000.00 30,416,666.67 False 30,416,666.67 CLP 3.0000% LinAct360"},{"location":"5_SwapICPCLP/#pata-overnightindex","title":"Pata OvernightIndex","text":"<p>Se da de alta los par\u00e1metros variables de la pata OvernightIndex. Notar que se reutilizan algunos de los par\u00e1metros de la pata fija.</p> <pre><code>rp = qcf.RecPay.RECEIVE if fixed_rate_leg_other_values['rec_pay'] == qcf.RecPay.PAY else qcf.RecPay.RECEIVE\n\nicpclp_leg_other_values = {\n    \"rec_pay\": rp,\n    \"initial_notional\": fixed_rate_leg_other_values[\"initial_notional\"],\n    \"start_date\": fixed_rate_leg_other_values[\"start_date\"],\n    \"end_date\": fixed_rate_leg_other_values[\"end_date\"],\n    \"settlement_periodicity\": fixed_rate_leg_other_values[\"settlement_periodicity\"],\n    \"interest_rate\": qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    \"index_name\": \"ICPCLP\",\n    \"spread\": 0.0,\n    \"gearing\": 1.0,\n}\n</code></pre> <p>Finalmente, se da de alta el objeto.</p> <pre><code>on_index_leg = qcf.LegFactory.build_bullet_overnight_index_leg(\n    **(both_default_values | icpclp_default_values | icpclp_leg_other_values)\n)\n</code></pre> <p>Se visualiza.</p> <pre><code>aux.leg_as_dataframe(on_index_leg).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa tipo_tasa interes flujo spread gearing 0 2024-06-18 2025-06-18 2024-06-18 2025-06-18 2025-06-19 1,000,000,000.00 1,000,000,000.00 False CLP ICPCLP 1.000000 1.000000 0.0000% LinAct360 0.00 0.00 0.0000% 1.00"},{"location":"6_Curva_SOFR/","title":"Curva SOFR","text":"<p>Se construye la curva cup\u00f3n cero asociada a los swaps de SOFR vs tasa fija:</p> <p>Se utiliza el procedimiento cl\u00e1sico que consiste en:</p> <ul> <li>Resolver el sistema de ecuaciones que iguala el valor presente de las patas fijas (en <code>start_date</code>) con el valor del nocional.</li> <li>Se considera como flujo el nocional al vencimiento.</li> <li>Es importante notar que para que estas ecuaciones sean v\u00e1lidas se debe suponer que el settlement lag es siempre igual a 0.</li> </ul> <pre><code>import qcfinancial as qcf\nimport pandas as pd\nimport aux_functions as aux\n</code></pre>"},{"location":"6_Curva_SOFR/#data","title":"Data","text":"<p>La data se obtiene del asiguiente archivo Excel. En \u00e9l, adem\u00e1s de las tasas de los swaps, se ha registrado las caracter\u00edsticas principales de estos contratos.</p> <pre><code>data = pd.read_excel(\"./input/20240621_sofr_data.xlsx\")\n</code></pre> <pre><code>data.style.format({'rate':'{:.4%}'})\n</code></pre> ticket start_date tenor stub_period pay_freq settlement_lag bus_adj_rule yf wf rate 0 USOSFR1Z BGN Curncy 2024-06-25 00:00:00 7D SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.3342% 1 USOSFR2Z BGN Curncy 2024-06-25 00:00:00 14D SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.3375% 2 USOSFR3Z BGN Curncy 2024-06-25 00:00:00 21D SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.3415% 3 USOSFRA BGN Curncy 2024-06-25 00:00:00 1M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.3442% 4 USOSFRB BGN Curncy 2024-06-25 00:00:00 2M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.3454% 5 USOSFRC BGN Curncy 2024-06-25 00:00:00 3M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.3426% 6 USOSFRD BGN Curncy 2024-06-25 00:00:00 4M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.3171% 7 USOSFRE BGN Curncy 2024-06-25 00:00:00 5M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.2955% 8 USOSFRF BGN Curncy 2024-06-25 00:00:00 6M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.2714% 9 USOSFRG BGN Curncy 2024-06-25 00:00:00 7M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.2366% 10 USOSFRH BGN Curncy 2024-06-25 00:00:00 8M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.1986% 11 USOSFRI BGN Curncy 2024-06-25 00:00:00 9M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.1667% 12 USOSFRK BGN Curncy 2024-06-25 00:00:00 11M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.0841% 13 USOSFR1 BGN Curncy 2024-06-25 00:00:00 12M SHORT_FRONT 2Y 2 MOD_FOLLOW Act360 Lin 5.0477% 14 USOSFR1F BGN Curncy 2024-06-25 00:00:00 18M SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 4.7545% 15 USOSFR2 BGN Curncy 2024-06-25 00:00:00 2Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 4.5629% 16 USOSFR3 BGN Curncy 2024-06-25 00:00:00 3Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 4.2799% 17 USOSFR4 BGN Curncy 2024-06-25 00:00:00 4Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 4.1110% 18 USOSFR5 BGN Curncy 2024-06-25 00:00:00 5Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 4.0095% 19 USOSFR6 BGN Curncy 2024-06-25 00:00:00 6Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.9498% 20 USOSFR7 BGN Curncy 2024-06-25 00:00:00 7Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.9114% 21 USOSFR8 BGN Curncy 2024-06-25 00:00:00 8Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.8869% 22 USOSFR9 BGN Curncy 2024-06-25 00:00:00 9Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.8721% 23 USOSFR10 BGN Curncy 2024-06-25 00:00:00 10Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.8639% 24 USOSFR12 BGN Curncy 2024-06-25 00:00:00 12Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.8604% 25 USOSFR15 BGN Curncy 2024-06-25 00:00:00 15Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.8615% 26 USOSFR20 BGN Curncy 2024-06-25 00:00:00 20Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.8278% 27 USOSFR25 BGN Curncy 2024-06-25 00:00:00 25Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.7356% 28 USOSFR30 BGN Curncy 2024-06-25 00:00:00 30Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.6388% 29 USOSFR40 BGN Curncy 2024-06-25 00:00:00 40Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.4272% 30 USOSFR50 BGN Curncy 2024-06-25 00:00:00 50Y SHORT_FRONT 1Y 2 MOD_FOLLOW Act360 Lin 3.2120%"},{"location":"6_Curva_SOFR/#input","title":"Input","text":"<p>Se definen los inputs que son comunes a todas las operaciones. Notar que, contrariamente a lo que indican los datos, se establece que el settlement lag sea igual a 0. Esto para poder aplicar la condici\u00f3n que iguala el valor prersente de la pata fija en <code>start_date</code> al nocional.</p> <pre><code># Debe coincidir con la fecha de los datos\ntrade_date = qcf.QCDate(21, 6, 2024)\n</code></pre> <pre><code># Convenci\u00f3n de las tasas de las patas fijas\nyf = qcf.QCAct360()\nwf = qcf.QCLinearWf()\n</code></pre> <pre><code># Los par\u00e1metros se organizan en un dict.\ncommon_params = {\n    \"rec_pay\": qcf.RecPay.RECEIVE,\n    \"start_date\": qcf.QCDate(25, 6, 2024),\n    \"bus_adj_rule\": qcf.BusyAdjRules.MODFOLLOW,\n    \"settlement_stub_period\": qcf.StubPeriod.SHORTFRONT,\n    \"settlement_calendar\": qcf.BusinessCalendar(trade_date, 50),\n    \"settlement_lag\": 0,  # Se impone = 0\n    \"initial_notional\": 1_000_000,\n    \"amort_is_cashflow\": True,\n    \"notional_currency\": qcf.QCUSD(),\n    \"is_bond\": False,\n    \"sett_lag_behaviour\": qcf.SettLagBehaviour.DONT_MOVE,\n}\n</code></pre> <p>La siguiente celda es para facilitar la escritura del c\u00f3digo que viene ya que nos recuerda cu\u00e1les son los argumentos de la funci\u00f3n que construye patas fijas.</p> <pre><code>for p in qcf.LegFactory.build_bullet_fixed_rate_leg.__doc__.split(','):\n    print(p)\n</code></pre> <pre><code>build_bullet_fixed_rate_leg(rec_pay: qcfinancial.RecPay\n start_date: qcfinancial.QCDate\n end_date: qcfinancial.QCDate\n bus_adj_rule: qcfinancial.BusyAdjRules\n settlement_periodicity: qcfinancial.Tenor\n settlement_stub_period: qcfinancial.StubPeriod\n settlement_calendar: qcfinancial.BusinessCalendar\n settlement_lag: typing.SupportsInt\n initial_notional: typing.SupportsFloat\n amort_is_cashflow: bool\n interest_rate: qcfinancial.QCInterestRate\n notional_currency: qcfinancial.QCCurrency\n is_bond: bool\n sett_lag_behaviour: qcfinancial.SettLagBehaviour = &lt;SettLagBehaviour.DONT_MOVE: 1&gt;) -&gt; qcfinancial.Leg\n\nBuilds a Leg containing only cashflows of type FixedRateCashflow. Amortization is BULLET\n</code></pre> <p>En el siguiente loop, se construyen todas las patas fijas.</p> <pre><code># Aqu\u00ed se almacenar\u00e1n los resultados\nfixed_rate_legs = []\n\n# Se recorre el DataFrame con la data\nfor t in data.itertuples():\n    # Madurez del contrato\n    tenor = qcf.Tenor(t.tenor)\n\n    # Se calcula el n\u00famero de meses de la madurez\n    months = tenor.get_months() + 12 * tenor.get_years()\n\n    # Se calcula la fecha final del swap sin aplicar todav\u00eda ajustes de calendario\n    if (days:=tenor.get_days()) &gt; 0:\n        end_date = common_params[\"start_date\"].add_days(days)\n    else:\n        end_date = common_params[\"start_date\"].add_months(months)\n\n    # Se define un dict con los par\u00e1metros propios de cada contrato\n    other_params = {\n        \"end_date\": end_date,\n        \"settlement_periodicity\": qcf.Tenor(t.pay_freq),\n        \"interest_rate\": qcf.QCInterestRate(t.rate, yf, wf),\n    }\n\n    # Se construye y almacena la pata fija correspondiente\n    fixed_rate_legs.append(\n        qcf.LegFactory.build_bullet_fixed_rate_leg(\n            **(common_params | other_params),\n        )\n    )\n</code></pre> <p>Se muestra la estructura de un par de patas fijas.</p> <pre><code>aux.leg_as_dataframe(fixed_rate_legs[0]).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-06-25 2024-07-02 2024-07-02 1,000,000.00 1,000,000.00 1,037.21 True 1,001,037.21 USD 5.3342% LinAct360 <pre><code>aux.leg_as_dataframe(fixed_rate_legs[14]).style.format(aux.format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nocional amortizacion interes amort_es_flujo flujo moneda_nocional valor_tasa tipo_tasa 0 2024-06-25 2024-12-25 2024-12-25 1,000,000.00 0.00 24,168.71 True 24,168.71 USD 4.7545% LinAct360 1 2024-12-25 2025-12-25 2025-12-25 1,000,000.00 1,000,000.00 48,205.35 True 1,048,205.35 USD 4.7545% LinAct360"},{"location":"6_Curva_SOFR/#curva-inicial","title":"Curva Inicial","text":"<p>La curva cero cup\u00f3n se construye usando bootstrapping y el algoritmo de Newton-Raphson. En el siguiente loop se construye la curva inicial. Newton-Raphson comenzar\u00e1 sus iteraciones desde cada punto de esta curva.</p> <pre><code># Se define los vectores de plazos y tasas\nplazos = qcf.long_vec()\ntasas = qcf.double_vec()\n\n# Para rellenarlos se utiliza la informaci\u00f3n contenida \n# en las patas fijas.\nfor leg in fixed_rate_legs:\n    # N\u00famero de cupones de la pata\n    num_cup = leg.size()\n\n    # \u00daltimo cashflow de la pata\n    cashflow = leg.get_cashflow_at(num_cup - 1)\n\n    # Se calcula el n\u00famero de d\u00edas desde start_date \n    # hasta la \u00faltima settlement_date\n    plazo = common_params[\"start_date\"].day_diff(cashflow.get_settlement_date())\n    plazos.append(plazo)\n\n    # Se obtiene el valor de la tasa fija\n    tasa = cashflow.get_rate().get_value()\n    tasas.append(tasa)\n\n# Con la informaci\u00f3n anterior, se termina de construir la curva\ncurva = qcf.QCCurve(plazos, tasas)\ninterpolator = qcf.QCLinearInterpolator(curva)\ninitial_zcc = qcf.ZeroCouponCurve(\n    interpolator, \n    rate:=(qcf.QCInterestRate(\n        0.0, \n        qcf.QCAct365(), \n        qcf.QCContinousWf()\n    ))\n)\n</code></pre>"},{"location":"6_Curva_SOFR/#bootstrapping","title":"Bootstrapping","text":"<p>Se procede ahora a aplicar el bootstrapping. Se comienza dando de alta el objeto <code>PresentValue</code> de <code>qcfinancial</code>que permite valorizar todo tipo de patas.</p> <pre><code>pv = qcf.PresentValue()\n</code></pre> <p>El siguiente loop ejecuta el bootstrapping.</p> <pre><code># Se resuelve la ecuaci\u00f3n:\n# VP(pata_fija(i), z1,...,z(i),...,zN) - nocional = 0, para todo i\nfor i, leg in enumerate(fixed_rate_legs):\n\n    # Se define la funci\u00f3n objetivo\n    def obj(zcc):\n        # VP - nocional\n        return pv.pv(common_params[\"start_date\"], leg, zcc) - common_params[\"initial_notional\"]\n\n    # Aqu\u00ed comienza la resoluci\u00f3n\n    error = 1_000\n    epsilon = .00001\n    x = initial_zcc.get_rate_at(i)  # Valor inicial para Newton-Raphson\n    new_zcc = initial_zcc  # En new_zcc se almacena el resultado\n\n    # Se aplica Newton-Raphson\n    while error &gt; epsilon:\n        x = x - obj(new_zcc) / pv.get_derivatives()[i]  # La derivada del VP se calcula al momento de valorizar \n        tasas[i] = x\n        # Se reconstruye la curva con el valor de la iteraci\u00f3n\n        curva = qcf.QCCurve(plazos, tasas)\n        interpolator = qcf.QCLinearInterpolator(curva)\n        new_zcc = qcf.ZeroCouponCurve(\n            interpolator, \n            rate,\n        )\n        # Se calcula el nuevo error\n        error = abs(obj(new_zcc))\n</code></pre> <p>Una vez ejecutado el bootstrapping, verificamos que, para cada pata, se cumple la condici\u00f3n deseada.</p> <pre><code>check = []\nfor i, leg in enumerate(fixed_rate_legs):\n    check.append({\n        \"leg_number\": i, \n        \"present_value\": pv.pv(common_params['start_date'], leg, new_zcc),\n    })\ndf_check = pd.DataFrame(check)\ndf_check.style.format({\"present_value\": \"{:,.4f}\"})\n</code></pre> leg_number present_value 0 0 1,000,000.0000 1 1 1,000,000.0000 2 2 1,000,000.0000 3 3 1,000,000.0000 4 4 1,000,000.0000 5 5 1,000,000.0000 6 6 1,000,000.0000 7 7 1,000,000.0000 8 8 1,000,000.0000 9 9 1,000,000.0000 10 10 1,000,000.0000 11 11 1,000,000.0000 12 12 1,000,000.0000 13 13 1,000,000.0000 14 14 1,000,000.0000 15 15 1,000,000.0000 16 16 1,000,000.0000 17 17 1,000,000.0000 18 18 1,000,000.0000 19 19 1,000,000.0000 20 20 1,000,000.0000 21 21 1,000,000.0000 22 22 1,000,000.0000 23 23 1,000,000.0000 24 24 1,000,000.0000 25 25 1,000,000.0000 26 26 1,000,000.0000 27 27 1,000,000.0000 28 28 1,000,000.0000 29 29 1,000,000.0000 30 30 1,000,000.0000 <p>Finalmente, se despliega los valores de la curva obtenida.</p> <pre><code>df_curva = pd.concat([pd.DataFrame(plazos), pd.DataFrame(tasas)], axis=1)\ndf_curva.columns = ['plazo', 'tasa']\ndf_curva.style.format({'tasa':'{:.4%}'})\n</code></pre> plazo tasa 0 7 5.4055% 1 14 5.4060% 2 21 5.4073% 3 30 5.4064% 4 62 5.3948% 5 92 5.3802% 6 122 5.3430% 7 153 5.3095% 8 183 5.2743% 9 216 5.2276% 10 245 5.1797% 11 273 5.1384% 12 335 5.0365% 13 365 4.9912% 14 548 4.7223% 15 730 4.5116% 16 1095 4.2290% 17 1462 4.0595% 18 1826 3.9577% 19 2191 3.8983% 20 2556 3.8604% 21 2922 3.8367% 22 3289 3.8231% 23 3653 3.8163% 24 4383 3.8166% 25 5480 3.8225% 26 7307 3.7822% 27 9131 3.6529% 28 10957 3.5115% 29 14610 3.1854% 30 18262 2.8431% <pre><code>\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/","title":"Objetos Fundamentales","text":"<p>Para ejecutar todos los ejemplos se debe importar la librer\u00eda. Se sugiere utilizar siempre el alias <code>qcf</code>. </p> <pre><code>import qcfinancial as qcf\nimport pandas as pd\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#monedas","title":"Monedas","text":"<p>Objetos para representar una divisa. En estos momentos s\u00f3lo las siguientes divisas est\u00e1n implementadas:</p> <ul> <li>BRL</li> <li>CAD</li> <li>CLF (esta es una representaci\u00f3n del \u00edndice de inflaci\u00f3n chileno UF como divisa)</li> <li>CLP</li> <li>EUR</li> <li>GBP</li> <li>JPY</li> <li>MXN</li> <li>USD</li> </ul> <p>Si se requiere otra, solicitarlo ingresando un issue en el git repo del proyecto.</p> <p>El constructor por default retorna USD.</p> <pre><code>x = qcf.QCCurrency()\nx.get_iso_code()\n</code></pre> <pre><code>'USD'\n</code></pre> <p>Alta de divisas CLP, USD y JPY (USD se puede instanciar tambi\u00e9n de forma expl\u00edcita).</p> <pre><code>clp = qcf.QCCLP()\nusd = qcf.QCUSD()\njpy = qcf.QCJPY()\nmonedas = [clp, usd, jpy]\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#metodos-get_name-get_iso_code-get_iso_number-get_decimal_places-y-amount","title":"M\u00e9todos: <code>get_name</code>, <code>get_iso_code</code>, <code>get_iso_number</code>, <code>get_decimal_places</code> y <code>amount</code>.","text":"<p>El m\u00e9todo <code>amount</code>debe utilizarse cuando se debe pagar o recibir un monto resultado de un c\u00e1lculo. De esta forma, el monto se redondea al n\u00famero correcto de decimales en la divisa (que se obtiene con <code>get_decimal_places</code>). Por ejemplo, en CLP, se redondea a 0 decimales ya que en esta divisa no se utilizan los centavos.</p> <pre><code>cantidad = 100.123456\nfor moneda in monedas:\n    print(\"Nombre: {}\".format(moneda.get_name()))\n    print(\"C\u00f3digo ISO: {}\".format(moneda.get_iso_code()))\n    print(\"N\u00famero ISO: {}\".format(moneda.get_iso_number()))\n    print(\"N\u00famero de decimales: {}\".format(moneda.get_decimal_places()))\n    print(\n        \"Cantidad {} con el n\u00famero correcto de decimales: {}\".format(\n            cantidad, moneda.amount(100.123456)\n        )\n    )\n    print()\n</code></pre> <pre><code>Nombre: Chilean Peso\nC\u00f3digo ISO: CLP\nN\u00famero ISO: 152\nN\u00famero de decimales: 0\nCantidad 100.123456 con el n\u00famero correcto de decimales: 100.0\n\nNombre: U. S. Dollar\nC\u00f3digo ISO: USD\nN\u00famero ISO: 840\nN\u00famero de decimales: 2\nCantidad 100.123456 con el n\u00famero correcto de decimales: 100.12\n\nNombre: Japanese Yen\nC\u00f3digo ISO: JPY\nN\u00famero ISO: 392\nN\u00famero de decimales: 2\nCantidad 100.123456 con el n\u00famero correcto de decimales: 100.12\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#fechas","title":"Fechas","text":"<p>Las fechas se representan con objetos de tipo QCDate. Para inicializar un QCDate se requiere el d\u00eda, el mes y el a\u00f1o de la fecha.  Tambi\u00e9n se puede inicializar sin valor (default constructor) en cuyo caso se obtendr\u00e1 el 12-1-1969.</p>"},{"location":"Ejemplos_qcfinancial_1/#constructores","title":"Constructores","text":"<p>Inicializar sin valor. Se muestra adem\u00e1s los m\u00e9todos <code>description()</code> y <code>__str__()</code>.</p> <pre><code>fecha = qcf.QCDate()\nprint(fecha.description(True))\nprint(fecha.description(False))\nprint(fecha)\n</code></pre> <pre><code>12-01-1969\n1969-01-12\n1969-01-12\n</code></pre> <p>Inicializar con una fecha espec\u00edfica. En este caso, el contructor realiza una validaci\u00f3n de los par\u00e1metros iniciales.</p> <pre><code>fecha1 = qcf.QCDate(14, 9, 2018)  # d\u00eda, mes, a\u00f1o\nprint(\"M\u00e9todo description: {}\".format(fecha1.description(True)))\nprint(\"Print de Python: {}\".format(fecha1))\n</code></pre> <pre><code>M\u00e9todo description: 14-09-2018\nPrint de Python: 2018-09-14\n</code></pre> <p>Error al tratar de construir una fecha inv\u00e1lida.</p> <pre><code>try:\n    fecha0 = qcf.QCDate(31, 2, 2018)  # \u00a1\u00a1\u00a1 31 de febrero !!!\nexcept ValueError as e:\n    print(e)\n</code></pre> <pre><code>Invalid day for month = 2\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#getters-y-setters","title":"Getters y Setters","text":"<pre><code># M\u00e9todos: set_day, set_month, set_year\nfecha1.set_day(17)\nfecha1.set_month(10)\nfecha1.set_year(2019)\nprint(\"Fecha: {}\".format(fecha1.description(True)))\n</code></pre> <pre><code>Fecha: 17-10-2019\n</code></pre> <pre><code># M\u00e9todos day, month, year, weekday\nprint(\"D\u00eda: {}\".format(fecha1.day()))\nprint(\"Mes: {}\".format(fecha1.month()))\nprint(\"A\u00f1o: {}\".format(fecha1.year()))\n</code></pre> <pre><code>D\u00eda: 17\nMes: 10\nA\u00f1o: 2019\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#metodo-week_day","title":"M\u00e9todo <code>week_day</code>","text":"<p>Retorna una variable de tipo <code>enum QC_Financial.WeekDay</code> que representa el d\u00eda de la semana que corresponde a la fecha.</p> <pre><code>dia_semana = fecha1.week_day()\nprint(\"Tipo del retorno: {}\".format(type(dia_semana)))\nprint(\"D\u00eda de la semana: {}\".format(dia_semana))\n</code></pre> <pre><code>Tipo del retorno: &lt;class 'qcfinancial.WeekDay'&gt;\nD\u00eda de la semana: WeekDay.THU\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#metodo-add_months","title":"M\u00e9todo <code>add_months</code>","text":"<p>Suma n meses a <code>fecha1</code> y retorna esa nueva fecha sin cambiar el valor de <code>fecha1</code>.</p> <pre><code>num_meses = 1\nfecha2 = fecha1.add_months(num_meses)\nprint(\"fecha1: {}\".format(fecha1.description(True)))\nprint(\"fecha2: {}\".format(fecha2.description(True)))\n</code></pre> <pre><code>fecha1: 17-10-2019\nfecha2: 17-11-2019\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#metodo-add_days","title":"M\u00e9todo <code>add_days</code>","text":"<p>Suma n d\u00edas a <code>fecha1</code> sin cambiar el valor de <code>fecha1</code>.</p> <pre><code>num_dias = 30\nfecha3 = fecha1.add_days(num_dias)\nprint(\"fecha1: {}\".format(fecha1.description(True)))\nprint(\"fecha3: {}\".format(fecha3.description(True)))\n</code></pre> <pre><code>fecha1: 17-10-2019\nfecha3: 16-11-2019\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#metodo-day_dif","title":"M\u00e9todo <code>day_dif</code>","text":"<p>Calcula la diferencia en d\u00edas con otra fecha. Si la otra fecha es mayor el resultado es positivo, si no, es negativo.</p> <pre><code># Dado que fecha3 &gt; fecha1 entonces el resultado es positivo\nprint(\"fecha1.day_diff(fecha3): {} (d\u00edas)\".format(fecha1.day_diff(fecha3)))\n\n# Se invierten los roles y el resultado es negativo\nprint(\"fecha3.day_diff(fecha1): {} (d\u00edas)\".format(fecha3.day_diff(fecha1)))\n</code></pre> <pre><code>fecha1.day_diff(fecha3): 30 (d\u00edas)\nfecha3.day_diff(fecha1): -30 (d\u00edas)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#orden-en-qcdate","title":"Orden en <code>QCDate</code>","text":"<p>El orden de <code>QCDate</code> permite que las fechas pueden compararse entre si.</p> <pre><code>print(\"fecha1: {}\".format(fecha1))\nprint(\"fecha2: {}\".format(fecha2))\nprint(\"fecha1 == fecha2: {}\".format(fecha1 == fecha2))\nprint(\"fecha1 != fecha2: {}\".format(fecha1 != fecha2))\nprint(\"fecha1 &lt; fecha2: {}\".format(fecha1 &lt; fecha2))\nprint(\"fecha1 &lt;= fecha2: {}\".format(fecha1 &lt;= fecha2))\nprint(\"fecha1 &gt; fecha2: {}\".format(fecha1 &gt; fecha2))\nprint(\"fecha1 &gt;= fecha2: {}\".format(fecha1 &gt;= fecha2))\n</code></pre> <pre><code>fecha1: 2019-10-17\nfecha2: 2019-11-17\nfecha1 == fecha2: False\nfecha1 != fecha2: True\nfecha1 &lt; fecha2: True\nfecha1 &lt;= fecha2: True\nfecha1 &gt; fecha2: False\nfecha1 &gt;= fecha2: False\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#un-objeto-qcdate-es-hashable","title":"Un objeto <code>QCDate</code> es hashable","text":"<p>Esto permite que las fechas puedan usarse como <code>key</code> en un <code>dict</code>de Python. El hash que se utiliza coincide con la representaci\u00f3n como entero de uan fecha que se utiliza en Excel.</p> <pre><code>print(fecha1.__hash__())\n</code></pre> <pre><code>43755\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#metodo-build_qcdate_from_string","title":"M\u00e9todo <code>build_qcdate_from_string</code>","text":"<p>Se trata de un factory method que permite inicializar un objeto <code>QCDate</code> a partir de un <code>string</code>. El formato del <code>string</code> debe ser yyyy&amp;mm&amp;dd donde &amp; es un separador arbitrario.</p> <pre><code>str1 = \"2020-01-01\"\nstr2 = \"2020/01/02\"\nstr3 = \"2020&amp;01&amp;03\"\n\nfecha4 = qcf.build_qcdate_from_string(str1)\nprint((str1 + \": {}\").format(fecha4.description(False)))\n\nfecha4 = qcf.build_qcdate_from_string(str2)\nprint((str2 + \": {}\").format(fecha4.description(False)))\n\nfecha4 = qcf.build_qcdate_from_string(str3)\nprint((str3 + \": {}\").format(fecha4.description(False)))\n</code></pre> <pre><code>2020-01-01: 2020-01-01\n2020/01/02: 2020-01-02\n2020&amp;01&amp;03: 2020-01-03\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#calendarios","title":"Calendarios","text":"<p>Los calendarios se representan con objetos de tipo <code>BusinesssCalendar</code> y son listas de fechas arbitrarias que representan d\u00edas feriados en alguna ciudad, pa\u00eds, regi\u00f3n o uni\u00f3n de las anteriores. Para dar de alta un calendario se requiere una fecha inicial (<code>QCDate</code> y un n\u00famero entero positivo que representa el plazo inicial total del calendario en a\u00f1os). El objeto <code>BusinessCalendar</code> incluye expl\u00edcitamente todos los d\u00edas 1 de enero y considera siempre como feriado los d\u00edas s\u00e1bado y domingo (aunque no pertenecen de forma expl\u00edcita a la lista).   </p> <pre><code>scl = qcf.BusinessCalendar(fecha1, 10)\nfor holiday in scl.get_holidays():\n    print(holiday)\n</code></pre> <pre><code># M\u00e9todo add_holiday. Agrega una fecha a la lista.\nscl.add_holiday(qcf.QCDate(2, 1, 2018))\nfor holiday in scl.get_holidays():\n    print(holiday)\n</code></pre> <pre><code>2018-01-02\n</code></pre> <pre><code># M\u00e9todo next_busy_day. Dada una fecha, si \u00e9sta es h\u00e1bil retorna la misma fecha,\n## si, por el contrario, la fecha es inh\u00e1bil, devuelve la siguiente fecha h\u00e1bil del calendario.\nprint(\"next:\", scl.next_busy_day(qcf.QCDate(15, 9, 2018)))  # es s\u00e1bado\nprint(\"Se agrega el 17-9-2018 a la lista\")\nscl.add_holiday(qcf.QCDate(17, 9, 2018))\nprint(\"nuevo next:\", scl.next_busy_day(qcf.QCDate(15, 9, 2018)))\n</code></pre> <pre><code>next: 2018-09-17\nSe agrega el 17-9-2018 a la lista\nnuevo next: 2018-09-18\n</code></pre> <pre><code># M\u00e9todo mod_next_busy_day. Opera igual que la funci\u00f3n anterior a menos que la funci\u00f3n anterior retorne una fecha\n# del mes siguiente, en ese caso retorna la fecha h\u00e1bil anterior.\nprint(\"fecha: 2018-04-30\")\nabril30 = qcf.QCDate(30, 4, 2018)\nscl.add_holiday(abril30)\nprint(\"next:\", scl.next_busy_day(abril30))\nprint(\"mod next:\", scl.mod_next_busy_day(qcf.QCDate(30, 4, 2018)))\nprint(\"abril30:\", abril30)\n</code></pre> <pre><code>fecha: 2018-04-30\nnext: 2018-05-01\nmod next: 2018-04-27\nabril30: 2018-04-30\n</code></pre> <pre><code># M\u00e9todo prev_busy_day. Opera de forma an\u00e1loga a mod_busy_day, pero retornando la fecha h\u00e1bil anterior.\nprint(\"prev:\", scl.prev_busy_day(abril30).iso_code())\n</code></pre> <pre><code>prev: 2018-04-27\n</code></pre> <pre><code># M\u00e9todo shift. Suma un n\u00famero n de d\u00edas h\u00e1biles a una fecha.\nmayo2 = qcf.QCDate(2, 5, 2018)\nprint(scl.shift(mayo2, -1))\nprint(scl.shift(abril30, 0))\nprint(scl.shift(abril30, 1))\nprint(scl.shift(abril30, 5))\n</code></pre> <pre><code>2018-05-01\n2018-04-30\n2018-05-01\n2018-05-07\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#fracciones-de-ano","title":"Fracciones de A\u00f1o","text":"<pre><code># Existen Act/360, Act/365, 30/360 y Act/30\nact360 = qcf.QCAct360()\nact365 = qcf.QCAct365()\nt30360 = qcf.QC30360()\nact30 = qcf.QCAct30()\nyfs = [act360, act365, t30360, act30]\n</code></pre> <pre><code># M\u00e9todos yf (sobrecargado) y count_days\nfor yf in yfs:\n    print(yf.yf(30))\n    print(yf.yf(fecha1, fecha3))\n    print(yf.count_days(fecha1, fecha3))\n    print()\n</code></pre> <pre><code>0.08333333333333333\n0.08333333333333333\n30\n\n0.0821917808219178\n0.0821917808219178\n30\n\n0.08333333333333333\n0.08055555555555556\n29\n\n1.0\n1.0\n30\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#factores-de-capitalizacion","title":"Factores de Capitalizaci\u00f3n","text":"<pre><code># Existen: (yf es la fracci\u00f3n de a\u00f1o asociada a la tasa de valor r)\n#    QCLinearWf     ---&gt; (1 + r * yf)\n#    QCCompundWf    ---&gt; (1 + r)**yf\n#    QCContinousWf  ---&gt; exp(r * yf)\nlin_wf = qcf.QCLinearWf()\ncom_wf = qcf.QCCompoundWf()\nexp_wf = qcf.QCContinousWf()\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#tasas-de-interes","title":"Tasas de Inter\u00e9s","text":"<pre><code># Dar de alta una tasa de inter\u00e9s\ntasa_lin_act360 = qcf.QCInterestRate(0.1, act360, lin_wf)\ntasa_com_act365 = qcf.QCInterestRate(0.1, act365, com_wf)\ntasas = [tasa_lin_act360, tasa_com_act365]\n</code></pre> <pre><code># M\u00e9todos get_value, set_value, wf (sobrecargado), dwf (sobrecargado)\nfor tasa in tasas:\n    print(\"get\", tasa.get_value())\n    tasa.set_value(0.12)\n    print(\"get nuevo valor\", tasa.get_value())\n    print(\n        \"wf\", tasa.wf(fecha1, fecha3)\n    )  # Retorna el factor de capitalizaci\u00f3n entre las fechas\n    print(\n        \"dwf\", tasa.dwf(fecha1, fecha3)\n    )  # Retorna la derivada del factor de capitalizaci\u00f3n respecto al valor de la tasa\n    # entre las fechas\n    print(\n        \"wf1\", tasa.wf(365)\n    )  # Retorna el factor de capitalizaci\u00f3n para el n\u00famero de d\u00edas\n    print(\n        \"dwf1\", tasa.dwf(365)\n    )  # Retorna la derivada del factor de capitalizaci\u00f3n respecto al valor de la tasa\n    # para el n\u00famero de d\u00edas\n    print()\n</code></pre> <pre><code>get 0.1\nget nuevo valor 0.12\nwf 1.01\ndwf 0.08333333333333333\nwf1 1.1216666666666666\ndwf1 1.0138888888888888\n\nget 0.1\nget nuevo valor 0.12\nwf 1.0093582031654136\ndwf 0.07407227518337182\nwf1 1.12\ndwf1 1.0\n</code></pre> <pre><code>tasa_lin_act360.get_rate_from_wf(0.99, 100)\n</code></pre> <pre><code>-0.03600000000000003\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#tenor","title":"Tenor","text":"<p>Es una clase que representa el concepto de tenor (1D, 1M, 1Y ...).</p> <pre><code># Ejemplo de Tenor\none_d = qcf.Tenor(\"1d\")\none_m = qcf.Tenor(\"1M\")\none_y = qcf.Tenor(\"1y\")\nt1d1m1y = qcf.Tenor(\"1D1M1Y\")\nt2Y3M = qcf.Tenor(\"2yadv3m\")\ntenors = [one_d, one_m, one_y, t1d1m1y, t2Y3M]\n</code></pre> <pre><code># M\u00e9todos get_string, get_years, get_months, get_years\nfor tenor in tenors:\n    print(\"string:\", tenor.get_string())\n    print(\"dias:\", tenor.get_days())\n    print(\"meses:\", tenor.get_months())\n    print(\"a\u00f1os:\", tenor.get_years())\n    print()\n\n# M\u00e9todo set_tenor\nt2Y3M.set_tenor(\"1m32y\")\nprint(t2Y3M.get_string())\n</code></pre> <pre><code>string: 1D\ndias: 1\nmeses: 0\na\u00f1os: 0\n\nstring: 1M\ndias: 0\nmeses: 1\na\u00f1os: 0\n\nstring: 1Y\ndias: 0\nmeses: 0\na\u00f1os: 1\n\nstring: 1Y1M1D\ndias: 1\nmeses: 1\na\u00f1os: 1\n\nstring: 2Y3M\ndias: 0\nmeses: 3\na\u00f1os: 2\n\n32Y1M\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#fx-rate","title":"FX Rate","text":"<p>Es una clase que representa el concepto de tipo de cambio entre dos monedas. Para dar de alta un FXRate se requiere:</p> <ul> <li>QCCurrency: la moneda fuerte del par.</li> <li>QCCurrency: la moneda d\u00e9bl del par.</li> </ul> <pre><code># Ejemplo. USDCLP. M\u00e9todo get_code. Se retorna el c\u00f3digo del par seg\u00fan la convenci\u00f3n usual.\nusdclp = qcf.FXRate(usd, clp)\nprint(\"c\u00f3digo:\", usdclp.get_code())\n</code></pre> <pre><code>c\u00f3digo: USDCLP\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#fxrateindex","title":"FXRateIndex","text":"<p>Representa un \u00edndice de tipo de cambio.</p> <pre><code>usdclp\n</code></pre> <pre><code>&lt;qcfinancial.FXRate at 0x112bbdef0&gt;\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#indices","title":"\u00cdndices","text":"<p>Todo \u00edndice pertenece a un asset class. Los distintos asset class se representan con un el enum AssetClass. Los asset class disponibles son:</p> <ul> <li>InterestRate</li> <li>InterestRateVol</li> <li>Fx</li> <li>FxVol</li> <li>Equity</li> <li>EquityVol</li> <li>Commodity</li> <li>CommodityVol</li> <li>Credit</li> <li>CreditVol</li> </ul> <pre><code># AssetClass. Existen\nprint(qcf.AssetClass.InterestRate)\nprint(qcf.AssetClass.Fx)\n</code></pre> <pre><code>AssetClass.InterestRate\nAssetClass.Fx\n</code></pre> <p>Para dar de alta un FXRateIndex se requiere:</p> <ul> <li><code>FXRate</code>: el FXRate correspoondiente.</li> <li><code>str</code>: nombre del \u00edndice</li> <li><code>Tenor</code>: la regla de fixing, es 1D como el USD Observado o es 0D como un \u00ednidce de cierre de d\u00eda.</li> <li><code>Tenor</code>: la regla para la valuta. Es 1D como el USDCLP o 2D como el EURUSD.</li> <li><code>BusinessCalendar</code>: el calendario adecuado para aplicar las reglas de fixing y valuta.</li> </ul> <pre><code># Ejemplo.\nusdclp_obs = qcf.FXRateIndex(usdclp, \"USDOBS\", one_d, one_d, scl)\nprint(\"fecha de publicaci\u00f3n:\", fecha1.week_day(), fecha1)\nprint(\"fecha de fixing:\", usdclp_obs.fixing_date(fecha1))\nprint(\"fecha de valuta:\", usdclp_obs.value_date(fecha1))\n</code></pre> <pre><code>fecha de publicaci\u00f3n: WeekDay.THU 2019-10-17\nfecha de fixing: 2019-10-16\nfecha de valuta: 2019-10-17\n</code></pre> <pre><code>result = usdclp_obs.convert(1000, qcf.QCUSD(), 700)\nprint(f\"Monto en CLP es: {result:,.0f}\")\n</code></pre> <pre><code>Monto en CLP es: 700,000\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#qccurrencyconverter","title":"QCCurrencyConverter","text":"<p>Este es un objeto que permite realizar conversiones de una moneda a otra.</p> <pre><code>ccy_converter = qcf.QCCurrencyConverter()\n</code></pre> <pre><code>print(f'Monto en CLP: {ccy_converter.convert(1_000, usd, 800, usdclp_obs):,.0f}')\n</code></pre> <pre><code>Monto en CLP: 800,000\n</code></pre> <pre><code>print(f'Monto en USD: {ccy_converter.convert(800_000, clp, 800, usdclp_obs):,.0f}')\n</code></pre> <pre><code>Monto en USD: 1,000\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#enum-para-monedas","title":"Enum para Monedas","text":"<pre><code>qcf.QCCurrencyEnum.AUD\n</code></pre> <pre><code>&lt;QCCurrencyEnum.AUD: 0&gt;\n</code></pre> <pre><code>qcf.QCCurrencyEnum.USD\n</code></pre> <pre><code>&lt;QCCurrencyEnum.USD: 17&gt;\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#enum-para-fxrates","title":"Enum para FXRates","text":"<pre><code>qcf.QCFxRateEnum.USDCLP\n</code></pre> <pre><code>&lt;QCFxRateEnum.USDCLP: 14&gt;\n</code></pre> <pre><code>qcf.QCFxRateEnum.EURUSD\n</code></pre> <pre><code>&lt;QCFxRateEnum.EURUSD: 28&gt;\n</code></pre> <p>Ambos <code>enum</code> se pueden utilizar con el m\u00e9todo <code>convert</code>:</p> <pre><code>print(f'Monto en USD: {ccy_converter.convert(800_000, qcf.QCCurrencyEnum.CLP, 800, qcf.QCFxRateEnum.USDCLP):,.0f}')\n</code></pre> <pre><code>Monto en USD: 1,000\n</code></pre> <pre><code>print(f'Monto en USD: {ccy_converter.convert(1_000, qcf.QCCurrencyEnum.USD, 800, qcf.QCFxRateEnum.USDCLP):,.0f}')\n</code></pre> <pre><code>Monto en USD: 800,000\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#time-series","title":"Time Series","text":"<pre><code>ts = qcf.time_series()\nts[fecha1] = 10.0\n</code></pre> <pre><code>type(ts)\n</code></pre> <pre><code>qcfinancial.time_series\n</code></pre> <pre><code>for k, v in ts.items():\n    print(k, v)\n</code></pre> <pre><code>2019-10-17 10.0\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#cashflows","title":"Cashflows","text":""},{"location":"Ejemplos_qcfinancial_1/#simple-cashflow","title":"Simple Cashflow","text":"<p>Un objeto de tipo <code>SimpleCashflow</code> representa un flujo de caja cierto en una fecha y moneda.</p> <pre><code># Como se inicializa un objeto SimpleCashflow.\nsimple_cashflow = qcf.SimpleCashflow(\n    fecha1, 100, clp  # fecha del flujo  # monto\n)  # moneda\n</code></pre> <pre><code>simple_cashflow\n</code></pre> <pre><code>&lt;qcfinancial.SimpleCashflow at 0x129f98c30&gt;\n</code></pre> <pre><code># M\u00e9todos amount, ccy y date\nprint(simple_cashflow.amount())\nprint(simple_cashflow.ccy().get_iso_code())\nprint(simple_cashflow.date())\n</code></pre> <pre><code>100.0\nCLP\n2019-10-17\n</code></pre> <p>Primer ejemplo de la funci\u00f3n <code>show</code>. Envuelve de forma c\u00f3moda todo el flujo en una tupla. La funci\u00f3n show est\u00e1 sobregargada y admite muchos tipos de flujo.</p> <pre><code>qcf.show(simple_cashflow)\n</code></pre> <pre><code>('2019-10-17', 100.0, 'CLP')\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#simple-multicurrency-cashflow","title":"Simple Multicurrency Cashflow","text":"<p>Un objeto de tipo <code>SimpleMultiCurrencyCashflow</code> representa un flujo de caja cierto en una fecha y moneda, que, sin embargo, se liquidar\u00e1 en una segunda moneda utilizando el valor de un \u00edndice de tipo de cambio. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha final</li> <li><code>float</code>: nominal</li> <li><code>QCCurrency</code>: la moneda del nominal</li> <li><code>QCDate</code>: la fecha de publicaci\u00f3n del <code>FXRateIndex</code> que se usar\u00e1 en la conversi\u00f3n</li> <li><code>QCCurrency</code>: la moneda final del flujo</li> <li><code>FXRateIndex</code>: el \u00edndice de tipo de cambio a utilizar</li> <li><code>float</code>: el valor del \u00edndice de tipo de cambio</li> </ul> <pre><code># Ejemplo.\nsimple_mccy_cashflow = qcf.SimpleMultiCurrencyCashflow(\n    fecha3, 700.00, clp, fecha3, usd, usdclp_obs, 700.00\n)\nprint(\"fecha flujo:\", simple_mccy_cashflow.date())\nprint(\"nominal:\", simple_mccy_cashflow.nominal())\nprint(\"moneda nominal:\", simple_mccy_cashflow.ccy().get_iso_code())\nprint(\"flujo:\", simple_mccy_cashflow.amount())\nprint(\"moneda flujo:\", simple_mccy_cashflow.settlement_ccy().get_iso_code())\n</code></pre> <pre><code>fecha flujo: 2019-11-16\nnominal: 700.0\nmoneda nominal: CLP\nflujo: 1.0\nmoneda flujo: USD\n</code></pre> <pre><code># El valor del \u00edndice se puede alterar (existe un setter).\nsimple_mccy_cashflow.set_fx_rate_index_value(800.00)\nprint(\"flujo:\", simple_mccy_cashflow.amount())\n</code></pre> <pre><code>flujo: 0.875\n</code></pre> <pre><code># Ejemplo 2. Las monedas est\u00e1n invertidas respecto al caso anterior. El valor del \u00edndice se usa de la forma correcta.\nsimple_mccy_cashflow = qcf.SimpleMultiCurrencyCashflow(\n    fecha3, 1, usd, fecha3, clp, usdclp_obs, 700.00\n)\nprint(\"fecha flujo:\", simple_mccy_cashflow.date())\nprint(\"nominal:\", simple_mccy_cashflow.nominal())\nprint(\"moneda nominal:\", simple_mccy_cashflow.ccy().get_iso_code())\nprint(\"flujo:\", simple_mccy_cashflow.amount())\nprint(\"moneda flujo:\", simple_mccy_cashflow.settlement_ccy().get_iso_code())\n</code></pre> <pre><code>fecha flujo: 2019-11-16\nnominal: 1.0\nmoneda nominal: USD\nflujo: 700.0\nmoneda flujo: CLP\n</code></pre> <pre><code># Ejemplo 3. Hay inconsistencia entre las monedas y el tipo de cambio del \u00edndice.\neur = qcf.QCEUR()\ntry:\n    simple_mccy_cashflow = qcf.SimpleMultiCurrencyCashflow(\n        fecha3, 1, usd, fecha3, eur, usdclp_obs, 700.00\n    )\nexcept ValueError as e:\n    print(\"Error:\", e)\n</code></pre> <pre><code>Error: Fx Rate Index provided is not compatible with nominal and settlement currency.\n</code></pre> <pre><code># Funci\u00f3n show\nqcf.show(simple_mccy_cashflow)\n</code></pre> <pre><code>('2019-11-16', 1.0, 'USD', '2019-11-16', 'CLP', 'USDOBS', 700.0, 700.0)\n</code></pre> <pre><code>simple_mccy_cashflow.get_type()\n</code></pre> <pre><code>'SimpleMultiCurrencyCashflow'\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#fixed-rate-cashflow","title":"Fixed Rate Cashflow","text":"<p>Un objeto de tipo <code>FixedRateCashflow</code> representa un flujo de caja calculado a partir de la aplicaci\u00f3n de una tasa prefijada, entre dos fechas prefijadas a un nominal prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCInterestRate</code>: la tasa de inter\u00e9s a aplicar (su valor y convenciones)</li> <li><code>QCCurrency</code>: moneda del nominal y del flujo de caja</li> </ul> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\ntasa = qcf.QCInterestRate(0.1, act360, lin_wf)\nfixed_rate_cashflow = qcf.FixedRateCashflow(\n    fecha_inicio, \n    fecha_final, \n    fecha_pago, \n    1_000_000_000.0, \n    100_000_000.0, \n    True, \n    tasa, \n    clp\n)\n</code></pre> <pre><code># Getters\nprint(\"Fecha Inicio:\", fixed_rate_cashflow.get_start_date())\nprint(\"Fecha Final:\", fixed_rate_cashflow.get_end_date())\nprint(\"Fecha Pago:\", fixed_rate_cashflow.get_settlement_date())\nprint(\"Moneda:\", fixed_rate_cashflow.ccy().get_iso_code())\nprint(f\"Nominal: {fixed_rate_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {fixed_rate_cashflow.get_amortization():,.0f}\")\n</code></pre> <pre><code>Fecha Inicio: 2018-09-20\nFecha Final: 2019-09-20\nFecha Pago: 2019-09-23\nMoneda: CLP\nNominal: 1,000,000,000\nAmortizaci\u00f3n: 100,000,000\n</code></pre> <pre><code># Setters\n# TODO: set_rate\nnuevo_nominal = 2_000_000_000.0\nfixed_rate_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nuevo nominal: {fixed_rate_cashflow.get_nominal():,.0f}\")\n\nnueva_amortizacion = 200_000_000.0\nfixed_rate_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Nueva amortizaci\u00f3n: {fixed_rate_cashflow.get_amortization():,.0f}\")\n</code></pre> <pre><code>Nuevo nominal: 2,000,000,000\nNueva amortizaci\u00f3n: 200,000,000\n</code></pre> <pre><code># C\u00e1lculos\nprint(f\"Flujo Total: {fixed_rate_cashflow.amount():,.0f}\")\nprint(f\"Check: {fixed_rate_cashflow.get_nominal() * 0.1 * 365.0 / 360 + fixed_rate_cashflow.get_amortization():,.0f}\")\nprint()\nfecha_intermedia = qcf.QCDate(2, 1, 2019)\nprint(f\"Inter\u00e9s Devengado: {fixed_rate_cashflow.accrued_interest(fecha_intermedia):,.0f}\")\nprint(f\"Check: {fixed_rate_cashflow.get_nominal() * 0.1 * fecha_inicio.day_diff(fecha_intermedia) / 360.0:,.0f}\")\n</code></pre> <pre><code>Flujo Total: 402,777,778\nCheck: 402,777,778\n\nInter\u00e9s Devengado: 57,777,778\nCheck: 57,777,778\n</code></pre> <pre><code># Funci\u00f3n show\nprint(qcf.show(fixed_rate_cashflow))\n</code></pre> <pre><code>('2018-09-20', '2019-09-20', '2019-09-23', 2000000000.0, 200000000.0, 202777777.77777794, True, 402777777.7777779, 'CLP', 0.1, 'LinAct360')\n</code></pre> <pre><code>print(f\"Inter\u00e9s total: al {fixed_rate_cashflow.accrued_interest(fixed_rate_cashflow.get_end_date()):,.0f}\")\n</code></pre> <pre><code>Inter\u00e9s total: al 202,777,778\n</code></pre> <pre><code>fixed_rate_cashflow.get_type()\n</code></pre> <pre><code>'FixedRateCashflow'\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#fixed-rate-multi-currency-cashflow","title":"Fixed Rate Multi Currency Cashflow","text":"<p>Un objeto de tipo <code>FixedRateMultiCurrencyCashflow</code> representa un flujo de caja a tasa fija (<code>FixedRateCashflow</code>) que se liquidar\u00e1 en una moneda distinta de la moneda del nominal utilizando el valor a una cierta fecha de un \u00edndice de tipo de cambio prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCInterestRate</code>: la tasa de inter\u00e9s a aplicar (su valor y convenciones)</li> <li><code>QCCurrency</code>: moneda del nominal</li> <li><code>QCDate</code>: fecha de publicaci\u00f3n del \u00edndice de tipo de cambio</li> <li><code>QCCurrency</code>: moneda en la que se liquida el flujo</li> <li><code>FXRateIndex</code>: \u00edndice de tipo de cambio a utilizar</li> <li><code>float</code>: valor del \u00edndice de tipo de cambio</li> </ul> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\nfecha_publicacion = qcf.QCDate(23, 9, 2019)\nusd = qcf.QCUSD()\nindice = usdclp_obs\nvalor_indice = 20.0\nnominal = 1_000.0\namort = 1_000.0\nfixed_rate_mccy_cashflow = qcf.FixedRateMultiCurrencyCashflow(\n    fecha_inicio,\n    fecha_final,\n    fecha_pago,\n    nominal,\n    amort,\n    False,\n    tasa,\n    usd,\n    fecha_publicacion,\n    clp,\n    indice,\n    valor_indice,\n)\nprint(fixed_rate_mccy_cashflow)\n</code></pre> <pre><code>&lt;qcfinancial.FixedRateMultiCurrencyCashflow object at 0x129fb90b0&gt;\n</code></pre> <p>TODO: get_rate. Este getter no debe ser un getter tradicional, ya que no es necesario que retorne una referencia a todo el objeto <code>QCInterestRate</code>, basta con el valor y la descripci\u00f3n de yf y wf asociado (mejor llamarlo get_rate_info).</p> <pre><code># Getters\nprint(\"Fecha Inicio:\", fixed_rate_mccy_cashflow.get_start_date())\nprint(\"Fecha Final:\", fixed_rate_mccy_cashflow.get_end_date())\nprint(\"Fecha Pago:\", fixed_rate_mccy_cashflow.get_settlement_date())\nprint(\"Fecha Fijaci\u00f3n \u00cdndice FX:\", fixed_rate_mccy_cashflow.get_fx_fixing_date())\nprint(\"Moneda del Nominal:\", fixed_rate_mccy_cashflow.ccy())\nprint(f\"Nominal: {fixed_rate_mccy_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {fixed_rate_mccy_cashflow.get_amortization():,.0f}\")\nprint(\"Moneda de Liquidaci\u00f3n:\", fixed_rate_mccy_cashflow.settlement_currency())\n</code></pre> <pre><code>Fecha Inicio: 2018-09-20\nFecha Final: 2019-09-20\nFecha Pago: 2019-09-23\nFecha Fijaci\u00f3n \u00cdndice FX: 2019-09-23\nMoneda del Nominal: USD\nNominal: 1,000\nAmortizaci\u00f3n: 1,000\nMoneda de Liquidaci\u00f3n: CLP\n</code></pre> <p>TODO: set_rate_value. Debe establecer el valor de la tasa de inter\u00e9s.</p> <pre><code># Setters\nnuevo_nominal = 100.0\nfixed_rate_mccy_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nuevo nominal: {fixed_rate_mccy_cashflow.get_nominal():,.1f}\")\n\nnueva_amortizacion = 10.0\nfixed_rate_mccy_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Nueva amortizaci\u00f3n: {fixed_rate_mccy_cashflow.get_amortization():,.1f}\")\n</code></pre> <pre><code>Nuevo nominal: 100.0\nNueva amortizaci\u00f3n: 10.0\n</code></pre> <pre><code># C\u00e1lculos\nfixed_rate_mccy_cashflow.set_nominal(nominal)\nfixed_rate_mccy_cashflow.set_amortization(amort)\nprint(f\"Flujo Total: {fixed_rate_mccy_cashflow.amount():,.2f}\")\nprint(f\"Check: {(fixed_rate_mccy_cashflow.get_nominal() * 0.1 * 365.0 / 360) * valor_indice:,.2f}\")\nprint()\nfecha_intermedia = qcf.QCDate(2, 1, 2019)\nprint(f\"Inter\u00e9s Devengado: {fixed_rate_mccy_cashflow.accrued_interest(fecha_intermedia):,.02f}\")\nprint(f\"Check: {fixed_rate_mccy_cashflow.get_nominal() * 0.1 * fecha_inicio.day_diff(fecha_intermedia) / 360.0:,.02f}\")\n</code></pre> <pre><code>Flujo Total: 10.14\nCheck: 101.39\n\nInter\u00e9s Devengado: 2.89\nCheck: -7.25\n</code></pre> <pre><code>ts = qcf.time_series()\n</code></pre> <pre><code>ts[fecha_inicio] = 10\n</code></pre> <pre><code>ts[fecha_inicio]\n</code></pre> <pre><code>10.0\n</code></pre> <pre><code>ts[fecha_intermedia] = 15\n</code></pre> <pre><code>print(fixed_rate_mccy_cashflow.accrued_interest(fecha_intermedia, fecha_inicio, ts))\n</code></pre> <pre><code>28.888888888888964\n</code></pre> <pre><code>print(fixed_rate_mccy_cashflow.accrued_interest(fecha_intermedia, fecha_intermedia, ts))\n</code></pre> <pre><code>43.33333333333344\n</code></pre> <pre><code># Funci\u00f3n show\nprint(qcf.show(fixed_rate_mccy_cashflow))\n</code></pre> <pre><code>('2018-09-20', '2019-09-20', '2019-09-23', 100.0, 100.0, 10.138888888888896, False, 10.138888888888896, 'USD', 0.1, 'LinAct360', '2019-09-23', 'CLP', 'USDOBS', 20.0, 2000.0, 202.77777777777794)\n</code></pre> <pre><code>fixed_rate_mccy_cashflow.get_type()\n</code></pre> <pre><code>'FixedRateMultiCurrencyCashflow'\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#fixed-rate-cashflow-2","title":"Fixed Rate Cashflow 2","text":"<p>Un objeto de tipo <code>FixedRateCashflow2</code> representa un flujo de caja calculado a partir de la aplicaci\u00f3n de una tasa prefijada, entre dos fechas prefijadas a un nominal prefijado. Este tipo de cashflow puede ser quantizado, es decir, se puede cambiar su moneda de pago componi\u00e9ndolo con un objeto adicional. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCInterestRate</code>: la tasa de inter\u00e9s a aplicar (su valor y convenciones)</li> <li><code>QCCurrency</code>: moneda del nominal y del flujo de caja</li> </ul> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\ntasa = qcf.QCInterestRate(0.15, act360, lin_wf)\nfixed_rate_cashflow_2 = qcf.FixedRateCashflow2(\n    fecha_inicio, \n    fecha_final, \n    fecha_pago, \n    1_000_000_000.0,\n    100_000_000.0, \n    True, \n    tasa, \n    clp\n)\n</code></pre> <pre><code>print(f\"Accrued Fixing: {fixed_rate_cashflow_2.accrued_fixing(fecha_inicio):.2%}\")\n</code></pre> <pre><code>Accrued Fixing: 15.00%\n</code></pre> <pre><code>print(f\"amount: {fixed_rate_cashflow_2.amount():,.0f}\")\nprint(\"currency:\", fixed_rate_cashflow_2.ccy().get_iso_code())\nprint(\"date:\", fixed_rate_cashflow_2.date())\nprint(\"start date:\", fixed_rate_cashflow_2.get_start_date())\nprint(\"end date:\", fixed_rate_cashflow_2.get_end_date())\nprint(\"settlement date:\", fixed_rate_cashflow_2.get_settlement_date())\nprint(\"fixing dates:\")\nfor f in fixed_rate_cashflow_2.get_fixing_dates():\n    print(\"\\t\", f)\nprint(f\"nominal: {fixed_rate_cashflow_2.get_nominal():,.0f}\")\nprint(f\"amortization: {fixed_rate_cashflow_2.get_amortization():,.0f}\")\nprint(f\"interest (1st overload): {fixed_rate_cashflow_2.interest():,.0f}\")\n\nts = qcf.time_series()\nprint(f\"interest (2nd overload): {fixed_rate_cashflow_2.interest(ts):,.0f}\")\nprint(f\"fixing (1st overload): {fixed_rate_cashflow_2.fixing():.2%}\")\nprint(f\"fixing (2nd overload): {fixed_rate_cashflow_2.fixing(ts):.2%}\")\nfecha_intermedia = qcf.QCDate(20, 3, 2019)\nprint(f\"accrued interest (1st overload): {fixed_rate_cashflow_2.accrued_interest(fecha_intermedia):,.0f}\")\nprint(f\"accrued interest (2nd overload): {fixed_rate_cashflow_2.accrued_interest(fecha_intermedia, ts):,.0f}\")\nprint(f\"accrued fixing (1st overload): {fixed_rate_cashflow_2.accrued_fixing(fecha_intermedia):.2%}\")\nprint(f\"accrued fixing (2nd overload): {fixed_rate_cashflow_2.accrued_fixing(fecha_intermedia, ts):,.2%}\")\n</code></pre> <pre><code>amount: 252,083,333\ncurrency: CLP\ndate: 2019-09-23\nstart date: 2018-09-20\nend date: 2019-09-20\nsettlement date: 2019-09-23\nfixing dates:\n     2018-09-20\nnominal: 1,000,000,000\namortization: 100,000,000\ninterest (1st overload): 152,083,333\ninterest (2nd overload): 152,083,333\nfixing (1st overload): 15.00%\nfixing (2nd overload): 15.00%\naccrued interest (1st overload): 75,416,667\naccrued interest (2nd overload): 75,416,667\naccrued fixing (1st overload): 15.00%\naccrued fixing (2nd overload): 15.00%\n</code></pre> <pre><code>fixed_rate_cashflow_2.get_type()\n</code></pre> <pre><code>'FixedRateCashflow2'\n</code></pre> <pre><code>qcf.show(fixed_rate_cashflow_2)\n</code></pre> <pre><code>('2018-09-20',\n '2019-09-20',\n '2019-09-23',\n 1000000000.0,\n 100000000.0,\n 152083333.33333334,\n True,\n 252083333.33333334,\n 'CLP',\n 0.15,\n 'LinAct360')\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#ibor-cashflow","title":"Ibor Cashflow","text":"<p>Un objeto de tipo <code>IborCashflow</code> representa un flujo de caja calculado a partir de la aplicaci\u00f3n de una tasa flotante fijada en una cierta fecha (Libor, Euribor, TAB, ...) , entre dos fechas prefijadas a un nominal prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de fijaci\u00f3n del \u00edndice de tasa de inter\u00e9s </li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nominal y del flujo de caja</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n del \u00edndice</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n del \u00edndice</li> </ul> <p>Para dar de alta un <code>InterestRateIndex</code> se requiere:</p> <ul> <li><code>str</code>: c\u00f3digo del \u00edndice</li> <li><code>QCInterestRate</code>: un objeto tasa de inter\u00e9s que contenga las convenciones del \u00edndice</li> <li><code>Tenor</code>: el lag de inicio del \u00edndice respecto a la fecha de fixing (por ejemplo 2d para Libor USD)</li> <li><code>Tenor</code>: el tenor del \u00edndice (3M por ejemplo para Libor USD 3M)</li> <li><code>QCBusinessCalendar</code>: el calendario de fixing</li> <li><code>QCBusinessCalendar</code>: el calendario de pago</li> <li><code>QCCurrency</code>: la moneda a la que corresponde el \u00edndice (por ejemplo EUR para EURIBOR 3M)</li> </ul> <p>TODO: agregar end_date_adjustment al objeto (FOLLOW o MOD FOLLOW). Esto debiera tener un correspondiente cambio en la BBDD de Front Desk.</p> <pre><code># Se define el \u00edndice\ncodigo = \"LIBORUSD3M\"\nlin_act360 = qcf.QCInterestRate(0.0, act360, lin_wf)\nfixing_lag = qcf.Tenor(\"2d\")\ntenor = qcf.Tenor(\"3m\")\nfixing_calendar = scl  # No es el calendario correcto, pero sirve para el ejemplo\nsettlement_calendar = scl  # \u00cddem arriba\nlibor_usd_3m = qcf.InterestRateIndex(\n    codigo, \n    lin_act360, \n    fixing_lag, \n    tenor, \n    fixing_calendar, \n    settlement_calendar, \n    usd\n)\n\n# Getters\nprint(\"Tenor:\", libor_usd_3m.get_tenor())\nprint(\"Tasa:\", libor_usd_3m.get_rate())\nprint()\n\n# Para construir un fixing en particular\nlibor_usd_3m.set_rate_value(0.01)\nprint(\"Fixing Tasa:\", libor_usd_3m.get_rate())\nfecha_fixing = qcf.QCDate(20, 9, 2018)\nprint(\"Fecha Inicio:\", libor_usd_3m.get_start_date(fecha_fixing))\nprint(\"Fecha Final:\", libor_usd_3m.get_end_date(fecha_fixing))\n</code></pre> <pre><code>Tenor: 3M\nTasa: 0.000000 Act360 Lin\n\nFixing Tasa: 0.010000 Act360 Lin\nFecha Inicio: 2018-09-24\nFecha Final: 2018-12-24\n</code></pre> <pre><code>libor_usd_3m.get_code()\n</code></pre> <pre><code>'LIBORUSD3M'\n</code></pre> <pre><code>libor_usd_3m.set_rate_value(0.1)\n</code></pre> <pre><code>print(libor_usd_3m.get_rate())\n</code></pre> <pre><code>0.100000 Act360 Lin\n</code></pre> <pre><code>libor_usd_3m.get_rate()\n</code></pre> <pre><code>&lt;qcfinancial.QCInterestRate at 0x12aa57bf0&gt;\n</code></pre> <p>Con esto, veamos un ejemplo de construcci\u00f3n y uso de un <code>IborCashflow</code>.</p> <p>TODO: Se debe crear un mecanismo de WARNING para las eventuales inconsistencias entre las fechas de inicio y fin del <code>InterestRateIndex</code> y las fechas de inicio y fin del <code>IborCashflow</code>.</p> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\nfecha_fixing = qcf.QCDate(20, 9, 2018)\nnominal = 1_000_000.0\namort = 100_000.0\nspread = 0.0\ngearing = 1.0\nibor_cashflow = qcf.IborCashflow(\n    libor_usd_3m,\n    fecha_inicio,\n    fecha_final,\n    fecha_fixing,\n    fecha_pago,\n    nominal,\n    amort,\n    True,\n    usd,\n    spread,\n    gearing,\n)\n</code></pre> <pre><code># Getters\nprint(\"Fecha Fixing:\\t\", ibor_cashflow.get_fixing_date())\nprint(\"Fecha Inicio:\\t\", ibor_cashflow.get_start_date())\nprint(\"Fecha Final:\\t\", ibor_cashflow.get_end_date())\nprint(\"Fecha Pago:\\t\", ibor_cashflow.get_settlement_date())\nprint(f\"Nominal:\\t{ibor_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n:\\t{ibor_cashflow.get_amortization():,.0f}\")\nprint(\"Moneda:\\t\\t\", ibor_cashflow.ccy())\nprint(f\"Valor Tasa:\\t{ibor_cashflow.get_interest_rate_value():.2%}\")\n</code></pre> <pre><code>Fecha Fixing:    2018-09-20\nFecha Inicio:    2018-09-20\nFecha Final:     2019-09-20\nFecha Pago:  2019-09-23\nNominal:    1,000,000\nAmortizaci\u00f3n:   100,000\nMoneda:      USD\nValor Tasa: 10.00%\n</code></pre> <pre><code># Setters\nnuevo_nominal = 2_000_000.0\nibor_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nominal:\\t{ibor_cashflow.get_nominal():,.0f}\")\n\nnueva_amortizacion = 200_000.0\nibor_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Amortizaci\u00f3n:\\t{ibor_cashflow.get_amortization():,.0f}\")\n\nnuevo_valor_tasa = 0.02\nibor_cashflow.set_interest_rate_value(nuevo_valor_tasa)\nprint(f\"Valor Tasa: {ibor_cashflow.get_interest_rate_value():.2%}\")\n</code></pre> <pre><code>Nominal:    2,000,000\nAmortizaci\u00f3n:   200,000\nValor Tasa: 2.00%\n</code></pre> <pre><code># C\u00e1lculos\nprint(f\"Flujo: {ibor_cashflow.amount():,.0f}\")\n\nfecha_devengo = qcf.QCDate(20, 7, 2019)\nprint(f\"Inter\u00e9s Devengado al {fecha_devengo}: {ibor_cashflow.accrued_interest(fecha_devengo):,.0f}\")\ntasa = ibor_cashflow.get_interest_rate_value()\n\ncheck = tasa * fecha_inicio.day_diff(fecha_devengo) / 360.0 * ibor_cashflow.get_nominal()\nprint(f\"Check: {check:,.0f}\")\n</code></pre> <pre><code>Flujo: 240,556\nInter\u00e9s Devengado al 2019-07-20: 33,667\nCheck: 33,667\n</code></pre> <pre><code># Funci\u00f3n show\nprint(qcf.show(ibor_cashflow))\n</code></pre> <pre><code>('2018-09-20', '2019-09-20', '2018-09-20', '2019-09-23', 2000000.0, 200000.0, 40555.55555555568, True, 240555.55555555568, 'USD', 'LIBORUSD3M', 0.02, 0.0, 1.0, 'LinAct360')\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#ibor-cashflow-2","title":"Ibor Cashflow 2","text":"<p>Un objeto de tipo <code>IborCashflow2</code> representa un flujo de caja calculado a partir de la aplicaci\u00f3n de una tasa flotante fijada en una cierta fecha (Libor, Euribor, TAB, ...) , entre dos fechas prefijadas a un nominal prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de fijaci\u00f3n del \u00edndice de tasa de inter\u00e9s </li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nominal y del flujo de caja</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n del \u00edndice</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n del \u00edndice</li> </ul> <p>A diferencia de un <code>IborCashflow</code>, un <code>IborCashflow2</code> puede quantizarse.</p> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\nfecha_fixing = qcf.QCDate(20, 9, 2018)\nnominal = 1000000.0\namort = 100000.0\nspread = 0.0\ngearing = 1.0\nibor_cashflow_2 = qcf.IborCashflow2(\n    libor_usd_3m,\n    fecha_inicio,\n    fecha_final,\n    fecha_fixing,\n    fecha_pago,\n    nominal,\n    amort,\n    True,\n    usd,\n    spread,\n    gearing,\n)\n</code></pre> <pre><code># Getters\nprint(\"Fecha Fixing:\\t\", ibor_cashflow_2.get_fixing_dates())\nprint(\"Fecha Inicio:\\t\", ibor_cashflow_2.get_start_date())\nprint(\"Fecha Final:\\t\", ibor_cashflow_2.get_end_date())\nprint(\"Fecha Pago:\\t\", ibor_cashflow_2.get_settlement_date())\nprint(f\"Nominal:\\t{ibor_cashflow_2.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n:\\t{ibor_cashflow_2.get_amortization():,.0f}\")\nprint(\"Moneda:\\t\\t\", ibor_cashflow_2.ccy())\nprint(f\"Valor Tasa:\\t{ibor_cashflow_2.fixing():.2%}\")\n</code></pre> <pre><code>Fecha Fixing:    DateList[20-9-2018]\nFecha Inicio:    2018-09-20\nFecha Final:     2019-09-20\nFecha Pago:  2019-09-23\nNominal:    1,000,000\nAmortizaci\u00f3n:   100,000\nMoneda:      USD\nValor Tasa: 2.00%\n</code></pre> <pre><code># Funci\u00f3n show\nqcf.show(ibor_cashflow_2)\n</code></pre> <pre><code>('2018-09-20',\n '2019-09-20',\n '2018-09-20',\n '2019-09-23',\n 1000000.0,\n 100000.0,\n 20277.77777777784,\n True,\n 120277.77777777784,\n 'USD',\n 'LIBORUSD3M',\n 0.02,\n 0.0,\n 1.0,\n 'LinAct360')\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#ibor-multi-currency-cashflow","title":"Ibor Multi Currency Cashflow","text":"<p>Un objeto de tipo <code>IborMultiCurrencyCashflow</code> representa un flujo de caja a tasa variable (<code>IborCashflow</code>) que se liquidar\u00e1 en una moneda distinta de la moneda del nominal utilizando el valor a una cierta fecha de un \u00edndice de tipo de cambio prefijado. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de fijaci\u00f3n del \u00edndice de tasa de inter\u00e9s </li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nominal y del flujo de caja</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n del \u00edndice</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n del \u00edndice</li> <li><code>QCDate</code>: fecha de publicaci\u00f3n del \u00edndice de tipo de cambio</li> <li><code>QCCurrency</code>: moneda en la que se liquida el flujo</li> <li><code>FXRateIndex</code>: \u00edndice de tipo de cambio a utilizar</li> <li><code>float</code>: valor del \u00edndice de tipo de cambio</li> </ul> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2019)\nfecha_final = qcf.QCDate(20, 12, 2019)\nfecha_pago = qcf.QCDate(20, 12, 2019)\nfecha_fixing = qcf.QCDate(20, 9, 2019)\nnominal = 100.0\namort = 100.0\nspread = 0.02\ngearing = 1.0\nvalor_indice = 10.0\nfecha_publicacion = qcf.QCDate(20, 9, 2019)\nlibor_usd_3m.set_rate_value(0.01)\nibor_mccy_cashflow = qcf.IborMultiCurrencyCashflow(\n    libor_usd_3m,\n    fecha_inicio,\n    fecha_final,\n    fecha_fixing,\n    fecha_pago,\n    nominal,\n    amort,\n    True,\n    usd,\n    spread,\n    gearing,\n    fecha_publicacion,\n    clp,\n    indice,\n    valor_indice,\n)\nprint(ibor_mccy_cashflow)\n</code></pre> <pre><code>&lt;qcfinancial.IborMultiCurrencyCashflow object at 0x12aa60c70&gt;\n</code></pre> <pre><code>ibor_mccy_cashflow.set_interest_rate_value(0.01)\n</code></pre> <pre><code>print(qcf.show(ibor_mccy_cashflow))\n</code></pre> <pre><code>('2019-09-20', '2019-12-20', '2019-09-20', '2019-12-20', 100.0, 100.0, 0.7583333333333275, True, 1007.5833333333333, 'USD', 'LIBORUSD3M', 0.02, 1.0, 0.01, 'LinAct360', '2019-09-20', 'CLP', 'USDOBS', 10.0, 1000.0, 7.583333333333275)\n</code></pre> <pre><code>fecha_intermedia = qcf.QCDate(20, 10, 2019)\nprint(ibor_mccy_cashflow.accrued_interest(fecha_intermedia))\nprint(\n    (0.01 + spread)\n    * fecha_inicio.day_diff(fecha_intermedia)\n    / 360.0\n    * ibor_mccy_cashflow.get_nominal()\n)\n</code></pre> <pre><code>0.24999999999999467\n0.24999999999999997\n</code></pre> <pre><code>ts[fecha_inicio] = 1\nts[fecha_intermedia] = 3\nfor k in ts:\n    print(k)\nprint(fecha_intermedia.description(False))\nprint(ts[fecha_intermedia])\n</code></pre> <pre><code>2019-09-20\n2019-10-20\n2019-10-20\n3.0\n</code></pre> <pre><code>print(ibor_mccy_cashflow.accrued_interest(fecha_intermedia, fecha_intermedia, ts))\n</code></pre> <pre><code>0.749999999999984\n</code></pre> <pre><code>ibor_mccy_cashflow.get_type()\n</code></pre> <pre><code>'IborMultiCurrencyCashflow'\n</code></pre> <pre><code>qcf.show(ibor_mccy_cashflow)\n</code></pre> <pre><code>('2019-09-20',\n '2019-12-20',\n '2019-09-20',\n '2019-12-20',\n 100.0,\n 100.0,\n 0.7583333333333275,\n True,\n 1007.5833333333333,\n 'USD',\n 'LIBORUSD3M',\n 0.02,\n 1.0,\n 0.01,\n 'LinAct360',\n '2019-09-20',\n 'CLP',\n 'USDOBS',\n 10.0,\n 1000.0,\n 7.583333333333275)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#icp-clp-cashflow","title":"Icp Clp Cashflow","text":"<p>Un objeto de tipo <code>IcpClpCashflow</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un swap ICP (c\u00e1mara promedio) de Chile. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la TNA</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la TNA</li> <li><code>float</code>: el valor del ICP a fecha de inicio (u otro valor arbitrario si el valor es desconocido)</li> <li><code>float</code>: el valor del ICP a fecha final (u otro valor arbitrario si el valor es desconocido)</li> </ul> <p>Recordar que TNA significa Tasa Nominal Anual y se determina utilizando los valores del \u00edndice ICP en la fecha de inicio y fecha final del <code>IcpClpCashflow</code>.</p> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\nnominal = 1_000_000_000.0\namort = 100_000_000.0\nspread = 0.0\ngearing = 1.0\nicp_clp_cashflow = qcf.IcpClpCashflow(\n    fecha_inicio,\n    fecha_final,\n    fecha_pago,\n    nominal,\n    amort,\n    True,\n    spread,\n    gearing,\n    10_000.0,\n    10_250.0,\n)\n</code></pre> <pre><code># Getters\nprint(\"Fecha Inicio:\", icp_clp_cashflow.get_start_date())\nprint(\"Fecha Final:\", icp_clp_cashflow.get_end_date())\nprint(f\"ICP Fecha Inicio: {icp_clp_cashflow.get_start_date_icp():,.2f}\")\nprint(f\"ICP Fecha Final: {icp_clp_cashflow.get_end_date_icp():,.2f}\")\nprint(f\"Valor TNA Todo el Per\u00edodo: {icp_clp_cashflow.get_rate_value():.2%}\")\ncheck = round((10250.0 / 10000 - 1) * 360.0 / fecha_inicio.day_diff(fecha_final), 4)\nprint(f\"Check: {check:.2%}\")\nprint(f\"Nominal: {icp_clp_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {icp_clp_cashflow.get_amortization():,.0f}\")\nprint(\"Tipo de Tasa:\", icp_clp_cashflow.get_type_of_rate())\nprint(\"Moneda:\", icp_clp_cashflow.ccy())\n</code></pre> <pre><code>Fecha Inicio: 2018-09-20\nFecha Final: 2019-09-20\nICP Fecha Inicio: 10,000.00\nICP Fecha Final: 10,250.00\nValor TNA Todo el Per\u00edodo: 2.47%\nCheck: 2.47%\nNominal: 1,000,000,000\nAmortizaci\u00f3n: 100,000,000\nTipo de Tasa: LinAct360\nMoneda: CLP\n</code></pre> <pre><code># Setters\ndecimales_para_tna = 6\nicp_clp_cashflow.set_tna_decimal_places(decimales_para_tna)\nprint(f\"Nueva TNA: {icp_clp_cashflow.get_rate_value():.4%}\")\n\nnuevo_nominal = 100\nicp_clp_cashflow.set_nominal(nuevo_nominal)\nprint(\"Nuevo Nominal:\", icp_clp_cashflow.get_nominal())\n\nnueva_amortizacion = 10\nicp_clp_cashflow.set_amortization(nueva_amortizacion)\nprint(\"Nueva Amortizaci\u00f3n:\", icp_clp_cashflow.get_amortization())\n\nnuevo_icp_inicio = 20_000\nicp_clp_cashflow.set_start_date_icp(nuevo_icp_inicio)\nprint(f\"Nuevo ICP Inicio: {icp_clp_cashflow.get_start_date_icp():,.2f}\")\n\nnuevo_icp_final = 20_600\nicp_clp_cashflow.set_end_date_icp(nuevo_icp_final)\nprint(f\"Nuevo ICP Final: {icp_clp_cashflow.get_end_date_icp():,.2f}\")\nprint(f\"Check TNA Final: {icp_clp_cashflow.get_rate_value():.4%}\")\n</code></pre> <pre><code>Nueva TNA: 2.4658%\nNuevo Nominal: 100.0\nNueva Amortizaci\u00f3n: 10.0\nNuevo ICP Inicio: 20,000.00\nNuevo ICP Final: 20,600.00\nCheck TNA Final: 2.9589%\n</code></pre> <pre><code># C\u00e1lculos\ndecimales_para_tna = 4  # Se vuelve a 4 decimales de tasa\nicp_clp_cashflow.set_tna_decimal_places(decimales_para_tna)\n\nnuevo_icp_inicio = 10_000.0\nicp_clp_cashflow.set_start_date_icp(nuevo_icp_inicio)\n\nnuevo_icp_final = 10_250.0\nicp_clp_cashflow.set_end_date_icp(nuevo_icp_final)\n\nprint(f\"Flujo: {icp_clp_cashflow.amount():,.0f}\")\n\nfecha_devengo = qcf.QCDate(29, 3, 2019)\nicp_devengo = 10_125.0\ntna_devengo = icp_clp_cashflow.get_tna(fecha_devengo, icp_devengo)\nprint(f\"TNA fijada a {fecha_devengo.description(True)}: {tna_devengo:.2%}\")\ncheck = round(\n    (icp_devengo / nuevo_icp_inicio - 1) * 360.0 / fecha_inicio.day_diff(fecha_devengo),\n    decimales_para_tna,\n)\nprint(f\"Check: {check:.2%}\")\nprint(f\"Inter\u00e9s Devengado al {fecha_devengo.description(True)}: {icp_clp_cashflow.accrued_interest(fecha_devengo, icp_devengo):,.4f}\")\nprint(f\"Check: {100 * tna_devengo * fecha_inicio.day_diff(fecha_devengo) / 360.0:,.4f}\")\n</code></pre> <pre><code>Flujo: 13\nTNA fijada a 29-03-2019: 2.37%\nCheck: 2.37%\nInter\u00e9s Devengado al 29-03-2019: 1.2508\nCheck: 1.2508\n</code></pre> <pre><code>print(qcf.show(icp_clp_cashflow))\n</code></pre> <pre><code>('2018-09-20', '2019-09-20', '2019-09-23', 100.0, 10.0, True, 12.504305555555565, 'CLP', 10000.0, 10250.0, 0.0237, 2.504305555555564, 0.0, 1.0, 'LinAct360')\n</code></pre> <pre><code>icp_clp_cashflow.get_type()\n</code></pre> <pre><code>'IcpClpCashflow'\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#icp-clp-cashflow-2","title":"Icp Clp Cashflow 2","text":"<p>Un objeto de tipo <code>IcpClpCashflow2</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un swap ICP (c\u00e1mara promedio) de Chile. Este tipo de cashflow puede ser quantizado, es decir, se puede cambiar su moneda de pago componi\u00e9ndolo con un objeto adicional. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la TNA</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la TNA</li> <li><code>float</code>: el valor del ICP a fecha de inicio (u otro valor arbitrario si el valor es desconocido)</li> <li><code>float</code>: el valor del ICP a fecha final (u otro valor arbitrario si el valor es desconocido)</li> </ul> <p>Recordar que TNA significa Tasa Nominal Anual y se determina utilizando los valores del \u00edndice ICP en la fecha de inicio y fecha final del <code>IcpClpCashflow</code>.</p> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\nnominal = 1_000_000_000.0\namort = 100_000_000.0\nspread = 0.0\ngearing = 1.0\nicp_clp_cashflow2 = qcf.IcpClpCashflow2(\n    fecha_inicio,\n    fecha_final,\n    fecha_pago,\n    nominal,\n    amort,\n    True,\n    spread,\n    gearing,\n    True,\n    10_000.0,\n    10_250.0,\n)\n</code></pre> <pre><code># Getters\nprint(\"Fecha Inicio:\", icp_clp_cashflow2.get_start_date())\nprint(\"Fecha Final:\", icp_clp_cashflow2.get_end_date())\nprint(f\"ICP Fecha Inicio: {icp_clp_cashflow2.get_start_date_icp():,.2f}\")\nprint(f\"ICP Fecha Final: {icp_clp_cashflow2.get_end_date_icp():,.2f}\")\n\nprint()\nprint(f\"Valor TNA Todo el Per\u00edodo: {icp_clp_cashflow2.get_rate_value():.2%}\")\ncheck = round((10250.0 / 10000 - 1) * 360.0 / fecha_inicio.day_diff(fecha_final), 4)\nprint(f\"Check: {check:.2%}\")\nprint()\n\nprint(f\"Nominal: {icp_clp_cashflow2.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {icp_clp_cashflow2.get_amortization():,.0f}\")\nprint(\"Tipo de Tasa:\", icp_clp_cashflow2.get_type_of_rate())\nprint(\"Moneda:\", icp_clp_cashflow2.ccy())\n</code></pre> <pre><code>Fecha Inicio: 2018-09-20\nFecha Final: 2019-09-20\nICP Fecha Inicio: 10,000.00\nICP Fecha Final: 10,250.00\n\nValor TNA Todo el Per\u00edodo: 2.47%\nCheck: 2.47%\n\nNominal: 1,000,000,000\nAmortizaci\u00f3n: 100,000,000\nTipo de Tasa: LinAct360\nMoneda: CLP\n</code></pre> <pre><code># Setters\ndecimales_para_tna = 6\nicp_clp_cashflow2.set_tna_decimal_places(decimales_para_tna)\nprint(f\"Nueva TNA: {icp_clp_cashflow2.get_rate_value():.4%}\")\n\nnuevo_nominal = 100\nicp_clp_cashflow2.set_nominal(nuevo_nominal)\nprint(f\"Nuevo Nominal: {icp_clp_cashflow2.get_nominal():,.0f}\")\n\nnueva_amortizacion = 10\nicp_clp_cashflow2.set_amortization(nueva_amortizacion)\nprint(f\"Nueva Amortizaci\u00f3n: {icp_clp_cashflow2.get_amortization():,.0f}\")\n\nnuevo_icp_inicio = 20_000.0\nicp_clp_cashflow2.set_start_date_icp(nuevo_icp_inicio)\nprint(f\"Nuevo ICP Inicio: {icp_clp_cashflow2.get_start_date_icp():,.2f}\")\n\nnuevo_icp_final = 20_000.0\nicp_clp_cashflow2.set_end_date_icp(nuevo_icp_final)\nprint(f\"Nuevo ICP Final: {icp_clp_cashflow2.get_end_date_icp():,.2f}\")\nprint(f\"Check TNA Final: {icp_clp_cashflow2.get_rate_value():.4%}\")\n</code></pre> <pre><code>Nueva TNA: 2.4658%\nNuevo Nominal: 100\nNueva Amortizaci\u00f3n: 10\nNuevo ICP Inicio: 20,000.00\nNuevo ICP Final: 20,000.00\nCheck TNA Final: 0.0000%\n</code></pre> <pre><code># C\u00e1lculos\ndecimales_para_tna = 4  # Se vuelve a 4 decimales de tasa\nicp_clp_cashflow2.set_tna_decimal_places(decimales_para_tna)\n\nnuevo_icp_inicio = 10_000.0\nicp_clp_cashflow2.set_start_date_icp(nuevo_icp_inicio)\n\nnuevo_icp_final = 10_250.0\nicp_clp_cashflow2.set_end_date_icp(nuevo_icp_final)\n\nprint(f\"Flujo: {icp_clp_cashflow2.amount():,.2f}\")\nprint()\n\nfecha_devengo = qcf.QCDate(29, 3, 2019)\nicp_devengo = 10_125.0\ntna_devengo = icp_clp_cashflow2.get_tna(fecha_devengo, icp_devengo)\nprint(f\"TNA fijada al {fecha_devengo.description(True)}: {tna_devengo:.2%}\")\ncheck = round((icp_devengo / nuevo_icp_inicio - 1) * 360.0 / fecha_inicio.day_diff(fecha_devengo), decimales_para_tna)\nprint(f\"Check: {check:.2%}\")\nprint()\n\ndata = qcf.time_series()\ndata[fecha_devengo] = icp_devengo\nprint(f\"Inter\u00e9s Devengado al {fecha_devengo.description(True)}: {icp_clp_cashflow2.accrued_interest(fecha_devengo, data):,.6f}\")\ncheck = 100 * tna_devengo * fecha_inicio.day_diff(fecha_devengo) / 360.0\nprint(f\"Check: {check:,.6f}\")\n</code></pre> <pre><code>Flujo: 12.50\n\nTNA fijada al 29-03-2019: 2.37%\nCheck: 2.37%\n\nInter\u00e9s Devengado al 29-03-2019: 1.250833\nCheck: 1.250833\n</code></pre> <pre><code>print(qcf.show(icp_clp_cashflow2))\n</code></pre> <pre><code>('2018-09-20', '2019-09-20', '2019-09-23', 100.0, 10.0, True, 12.499999999999991, 'CLP', 10000.0, 10250.0, 0.0247, 2.504305555555564, 0.0, 1.0, 'LinAct360')\n</code></pre> <pre><code>icp_clp_cashflow2.get_type()\n</code></pre> <pre><code>'IcpClpCashflow'\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#overnight-index-cashflow","title":"Overnight Index Cashflow","text":"<p>Un objeto de tipo <code>OvernightIndexCashflow</code> representa un flujo de caja del tipo de la pata flotante de un swap ICP (c\u00e1mara promedio) de Chile usando cualquier tipo de \u00edndice similar (por ejemplo SOFRINDX) y cualquier moneda. Adicionalmente, permite definir en forma independiente a <code>start_date</code> y <code>end_date</code> las fechas inicial y final utilizadas para los valores del \u00edndice. Esto puede resultar \u00fatil cuando una de estas operaciones se utiliza para cubrir cr\u00e9ditos o bonos a tasa fija. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio devengo (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final devengo (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha inicio \u00edndice (para el valor del \u00edndice)</li> <li><code>QCDate</code>: fecha final \u00edndice (para el valor del \u00edndice)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>float</code>: nocional (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la tasa equivalente (TNA en el caso de un ICPCLP)</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la tasa equivalente</li> <li><code>QCInterestRate</code>: con este objeto se especifica en qu\u00e9 convenci\u00f3n se calcula la tasa equivalente</li> <li><code>string</code>: nombre del \u00edndice overnight a utilizar</li> <li><code>unsigned int</code>: n\u00famero de decimales a utilizar para determinar la tasa equivalente</li> </ul> <pre><code># Ejemplo\nfecha_inicio_devengo = qcf.QCDate(13, 11, 2023)\n\n# Notar que la fecha final de devengo es s\u00e1bado\nfecha_final_devengo = qcf.QCDate(18, 11, 2023)\n\nfecha_inicio_indice = qcf.QCDate(13, 11, 2023)\n\n# Notar que la fecha final de \u00edndice es el viernes\nfecha_final_indice = qcf.QCDate(17, 11, 2023)\n\n# La fecha de pago es el lunes siguiente\nfecha_pago = qcf.QCDate(20, 11, 2023)\n\nmoneda_nocional = qcf.QCUSD()\nnocional = 1_000_000_000.0\namort = 100_000_000.0\namort_es_flujo = True\nspread = 0.0\ngearing = 1.0\ntasa = qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\nnombre_indice = 'INDICE'\nnum_decimales = 8\nvalor_indice_inicio = 1.0\nvalor_indice_final = 1 + .1234 * 4 / 360 # Suponemos un valor constante de 10% por 4 d\u00edas del \u00edndice\n</code></pre> <pre><code>overnight_index_cashflow = qcf.OvernightIndexCashflow(\n    fecha_inicio_devengo,\n    fecha_final_devengo,\n    fecha_inicio_indice,\n    fecha_final_indice,\n    fecha_pago,\n    moneda_nocional,\n    nocional,\n    amort,\n    amort_es_flujo,\n    spread,\n    gearing,\n    tasa,\n    nombre_indice,\n    num_decimales,\n)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#getters","title":"Getters","text":"<pre><code>print(\"Fecha Inicio Devengo:\", overnight_index_cashflow.get_start_date())\nprint(\"Fecha Final Devengo:\", overnight_index_cashflow.get_end_date())\n\nprint(\"Fecha Inicio \u00cdndice:\", overnight_index_cashflow.get_index_start_date())\nprint(\"Fecha Final \u00cdndice:\", overnight_index_cashflow.get_index_end_date())\n\nprint(\"Fecha Pago:\", overnight_index_cashflow.get_settlement_date())\n\n\nprint(f\"\u00cdndice Fecha Inicio: {overnight_index_cashflow.get_start_date_index():,.8f}\")\nprint(f\"\u00efndice Fecha Final: {overnight_index_cashflow.get_end_date_index():,.8f}\")\n\nprint()\nprint(f\"Valor Tasa Equivalente Todo el Per\u00edodo: {overnight_index_cashflow.get_rate_value():.6%}\")\ncheck = round((\n    valor_indice_final / valor_indice_inicio - 1\n) * 360.0 / fecha_inicio_devengo.day_diff(fecha_final_devengo), num_decimales)\nprint(f\"Check: {check:.6%}\")\nprint()\n\nprint(f\"Nominal: {overnight_index_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {overnight_index_cashflow.get_amortization():,.0f}\")\nprint(\"Tipo de Tasa:\", overnight_index_cashflow.get_type_of_rate())\nprint(\"Moneda:\", overnight_index_cashflow.ccy())\n</code></pre> <pre><code>Fecha Inicio Devengo: 2023-11-13\nFecha Final Devengo: 2023-11-18\nFecha Inicio \u00cdndice: 2023-11-13\nFecha Final \u00cdndice: 2023-11-17\nFecha Pago: 2023-11-20\n\u00cdndice Fecha Inicio: 1.00000000\n\u00efndice Fecha Final: 1.00000000\n\nValor Tasa Equivalente Todo el Per\u00edodo: 0.000000%\nCheck: 9.872000%\n\nNominal: 1,000,000,000\nAmortizaci\u00f3n: 100,000,000\nTipo de Tasa: LinAct360\nMoneda: USD\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#setters","title":"Setters","text":"<pre><code>decimales_para_tasa_eq = 4\novernight_index_cashflow.set_eq_rate_decimal_places(decimales_para_tasa_eq)\nprint(f\"Nueva Tasa Eq: {overnight_index_cashflow.get_rate_value():.4%}\")\n</code></pre> <pre><code>Nueva Tasa Eq: 0.0000%\n</code></pre> <pre><code>new_notional = 123_456\novernight_index_cashflow.set_nominal(new_notional)\nprint(f\"Nuevo Nocional: {overnight_index_cashflow.get_nominal():,.2f}\")\n</code></pre> <pre><code>Nuevo Nocional: 123,456.00\n</code></pre> <pre><code>new_amortization = 100_000\novernight_index_cashflow.set_amortization(new_amortization)\nprint(f\"Nueva Amortizaci\u00f3n: {overnight_index_cashflow.get_amortization():,.2f}\")\n</code></pre> <pre><code>Nueva Amortizaci\u00f3n: 100,000.00\n</code></pre> <pre><code>nuevo_indice_inicio = 20_000.0\novernight_index_cashflow.set_start_date_index(nuevo_indice_inicio)\nprint(f\"Nuevo \u00cdndice Inicio: {overnight_index_cashflow.get_start_date_index():,.2f}\")\n</code></pre> <pre><code>Nuevo \u00cdndice Inicio: 20,000.00\n</code></pre> <pre><code>nuevo_indice_final = 20_010.0\novernight_index_cashflow.set_end_date_index(nuevo_indice_final)\nprint(f\"Nuevo \u00cdndice Final: {overnight_index_cashflow.get_end_date_index():,.2f}\")\nprint(f\"Check Tas Eq. Final: {overnight_index_cashflow.get_rate_value():.4%}\")\n</code></pre> <pre><code>Nuevo \u00cdndice Final: 20,010.00\nCheck Tas Eq. Final: 3.6000%\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#calculos","title":"C\u00e1lculos","text":"<pre><code>decimales_para_tasa = 8  # Se vuelve a 8 decimales de tasa\novernight_index_cashflow.set_eq_rate_decimal_places(decimales_para_tasa)\n\nnuevo_indice_inicio = 10_000.0\novernight_index_cashflow.set_start_date_index(nuevo_indice_inicio)\n\nnuevo_indice_final = 10_010.0\novernight_index_cashflow.set_end_date_index(nuevo_indice_final)\n\nprint(f\"Flujo: {overnight_index_cashflow.amount():,.2f}\")\nprint()\n</code></pre> <pre><code>Flujo: 100,123.46\n</code></pre> <pre><code>fecha_devengo = qcf.QCDate(16, 11, 2023)\nindice_devengo = 10_005.0\ntasa_devengo = overnight_index_cashflow.get_eq_rate(fecha_devengo, indice_devengo)\nprint(f\"Tasa Eq. fijada al {fecha_devengo.description(True)}: {tasa_devengo:.2%}\")\ncheck = round((\n    indice_devengo / nuevo_indice_inicio - 1\n) * 360.0 / fecha_inicio_devengo.day_diff(fecha_devengo), decimales_para_tasa)\nprint(f\"Check: {check:.2%}\")\nprint()\n</code></pre> <pre><code>Tasa Eq. fijada al 16-11-2023: 6.00%\nCheck: 6.00%\n</code></pre> <pre><code>data = qcf.time_series()\ndata[fecha_devengo] = indice_devengo\nprint(\n    f\"Inter\u00e9s Devengado al {fecha_devengo.description(True)}: {overnight_index_cashflow.accrued_interest(fecha_devengo, data):,.6f}\")\ncheck = new_notional * tasa_devengo * fecha_inicio_devengo.day_diff(fecha_devengo) / 360.0\nprint(f\"Check: {check:,.6f}\")\n</code></pre> <pre><code>Inter\u00e9s Devengado al 16-11-2023: 61.728000\nCheck: 61.728000\n</code></pre> <pre><code>overnight_index_cashflow.get_type()\n</code></pre> <pre><code>'OvernightIndexCashflow'\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#show","title":"Show","text":"<pre><code>data = [qcf.show(overnight_index_cashflow)]\npd.DataFrame(data, columns = qcf.get_column_names(\"OvernightIndexCashflow\", \"\"))\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa_equivalente tipo_tasa interes flujo spread gearing 0 2023-11-13 2023-11-18 2023-11-13 2023-11-17 2023-11-20 123456.0 100000.0 True USD INDICE 10000.0 10010.0 0.072 LinAct360 123.456 100123.456 0.0 1.0"},{"location":"Ejemplos_qcfinancial_1/#overnight-index-multi-currency-cashflow","title":"Overnight Index Multi Currency Cashflow","text":"<p>Un objeto de tipo <code>OvernightIndexMultiCurrencyCashflow</code> hereda de <code>OvernightIndexCashflow</code> y representa un flujo de caja del tipo de la pata flotante de un swap ICP (c\u00e1mara promedio) de Chile usando cualquier tipo de \u00edndice similar (por ejemplo SOFRINDX), cualquier moneda de nocional, pero con flujos de caja en una moneda distinta a la del nocional, por ejemplo un ICPCLP con contraparte en US que compensa en USD. Al heredar de <code>OvernightIndexCashflow</code>, tambi\u00e9n permite definir en forma independiente a <code>start_date</code> y <code>end_date</code> las fechas inicial y final utilizadas para los valores del \u00edndice. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio devengo (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final devengo (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha inicio \u00edndice (para el valor del \u00edndice)</li> <li><code>QCDate</code>: fecha final \u00edndice (para el valor del \u00edndice)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>float</code>: nocional (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la tasa equivalente (TNA en el caso de un ICPCLP)</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la tasa equivalente</li> <li><code>QCInterestRate</code>: con este objeto se especifica en qu\u00e9 convenci\u00f3n se calcula la tasa equivalente</li> <li><code>string</code>: nombre del \u00edndice overnight a utilizar</li> <li><code>unsigned int</code>: n\u00famero de decimales a utilizar para determinar la tasa equivalente</li> </ul> <p>Hasta ac\u00e1 son los mismos argumentos necesarios para construir un <code>OvernightIndexCAshflow</code>. Se a\u00f1aden los siguientes argumentos: - <code>QCDate</code>: fecha de fixing del \u00edndice de tipo de cambio. Esta fecha se refiere a la fecha de publicaci\u00f3n del \u00edndice, no a la fecha de fixing en sentido financiero. - <code>QCCurrency</code>: moneda de pago de los flujos de caja - <code>FXRateIndex&gt;</code>: \u00edndice de tipo de cambio utilizado para la conversi\u00f3n de los flujos a moneda de pago</p>"},{"location":"Ejemplos_qcfinancial_1/#ejemplo","title":"Ejemplo","text":"<pre><code>fecha_inicio_devengo = qcf.QCDate(13, 11, 2023)\n\n# Notar que la fecha final de devengo es s\u00e1bado\nfecha_final_devengo = qcf.QCDate(18, 11, 2023)\n\nfecha_inicio_indice = qcf.QCDate(13, 11, 2023)\n\n# Notar que la fecha final de \u00edndice es el viernes\nfecha_final_indice = qcf.QCDate(17, 11, 2023)\n\n# La fecha de pago es el lunes siguiente\nfecha_pago = qcf.QCDate(20, 11, 2023)\n\nmoneda_nocional = qcf.QCUSD()\nnocional = 1_000_000_000.0\namort = 100_000_000.0\namort_es_flujo = True\nspread = 0.0\ngearing = 1.0\ntasa = qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\nnombre_indice = 'INDICE'\nnum_decimales = 8\nvalor_indice_inicio = 1.0\nvalor_indice_final = 1 + .1234 * 4 / 360 # Suponemos un valor constante de 10% por 4 d\u00edas del \u00edndice\n\n# -------------------------------\nfecha_fixing_fx_index = fecha_final_devengo\nmoneda_pago = qcf.QCCLP()\nindice_fx = usdclp_obs\n</code></pre> <pre><code>overnight_index_mccy_cashflow = qcf.OvernightIndexMultiCurrencyCashflow(\n    fecha_inicio_devengo,\n    fecha_final_devengo,\n    fecha_inicio_indice,\n    fecha_final_indice,\n    fecha_pago,\n    moneda_nocional,\n    nocional,\n    amort,\n    amort_es_flujo,\n    spread,\n    gearing,\n    tasa,\n    nombre_indice,\n    num_decimales,\n    fecha_fixing_fx_index,\n    moneda_pago,\n    indice_fx,\n)\n</code></pre> <pre><code>type(overnight_index_mccy_cashflow)\n</code></pre> <pre><code>qcfinancial.OvernightIndexMultiCurrencyCashflow\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#funcion-show","title":"Funci\u00f3n <code>show</code>","text":"<pre><code>qcf.show(overnight_index_mccy_cashflow)\n</code></pre> <pre><code>('2023-11-13',\n '2023-11-18',\n '2023-11-13',\n '2023-11-17',\n '2023-11-20',\n 1000000000.0,\n 100000000.0,\n True,\n 'USD',\n 'INDICE',\n 1.0,\n 1.0,\n 0.0,\n 'LinAct360',\n 0.0,\n 100000000.0,\n 0.0,\n 1.0,\n 'CLP',\n 'USDOBS',\n '2023-11-18',\n 1.0,\n 0.0,\n 100000000.0,\n 100000000.0)\n</code></pre> <p>Se envuelve el resultado en un <code>pd.DataFrame</code>.</p> <pre><code>pd.DataFrame(\n    [qcf.show(overnight_index_mccy_cashflow),],\n    columns=qcf.get_column_names(\"OvernightIndexMultiCurrencyCashflow\", \"\")\n)\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice ... flujo spread gearing moneda_pago indice_fx fecha_fijacion_indice_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2023-11-13 2023-11-18 2023-11-13 2023-11-17 2023-11-20 1.000000e+09 100000000.0 True USD INDICE ... 100000000.0 0.0 1.0 CLP USDOBS 2023-11-18 1.0 0.0 100000000.0 100000000.0 <p>1 rows \u00d7 25 columns</p>"},{"location":"Ejemplos_qcfinancial_1/#nuevo-setter","title":"Nuevo Setter","text":"<p>Valor del \u00edndice de tipo de cambio.</p> <pre><code>overnight_index_mccy_cashflow.set_fx_rate_index_value(.5)\n</code></pre> <p>Ver el efecto en las \u00faltimas dos columnas.</p> <pre><code>pd.DataFrame(\n    [qcf.show(overnight_index_mccy_cashflow),],\n    columns=qcf.get_column_names(\"OvernightIndexMultiCurrencyCashflow\", \"\")\n)\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice ... flujo spread gearing moneda_pago indice_fx fecha_fijacion_indice_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2023-11-13 2023-11-18 2023-11-13 2023-11-17 2023-11-20 1.000000e+09 100000000.0 True USD INDICE ... 100000000.0 0.0 1.0 CLP USDOBS 2023-11-18 0.5 0.0 50000000.0 50000000.0 <p>1 rows \u00d7 25 columns</p>"},{"location":"Ejemplos_qcfinancial_1/#nuevos-getters","title":"Nuevos Getters","text":"<pre><code>overnight_index_mccy_cashflow.get_fx_rate_index()\n</code></pre> <pre><code>&lt;qcfinancial.FXRateIndex at 0x129f991f0&gt;\n</code></pre> <pre><code>overnight_index_mccy_cashflow.get_type()\n</code></pre> <pre><code>'OvernightIndexMultiCurrencyCashflow'\n</code></pre> <pre><code>overnight_index_mccy_cashflow.get_fx_rate_index_code()\n</code></pre> <pre><code>'USDOBS'\n</code></pre> <pre><code>overnight_index_mccy_cashflow.get_fx_rate_index_value()\n</code></pre> <pre><code>0.5\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#nuevos-calculos","title":"Nuevos C\u00e1lculos","text":"<p>Primero se fijan los valores del \u00edndice overnight.</p> <pre><code>overnight_index_mccy_cashflow.set_start_date_index(100)\novernight_index_mccy_cashflow.accrued_interest(fecha_final_devengo, 102)\n</code></pre> <pre><code>20000000.00000002\n</code></pre> <pre><code>overnight_index_mccy_cashflow.settlement_ccy_interest()\n</code></pre> <pre><code>-495000000.0\n</code></pre> <pre><code>overnight_index_mccy_cashflow.settlement_ccy_amortization()\n</code></pre> <pre><code>50000000.0\n</code></pre> <pre><code>overnight_index_mccy_cashflow.settlement_ccy_amount()\n</code></pre> <pre><code>-445000000.0\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#icp-clf-cashflow","title":"Icp Clf Cashflow","text":"<p>Un objeto de tipo <code>IcpClfCashflow</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un swap ICP (c\u00e1mara promedio) en UF de Chile. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>vector&lt;float&gt;</code>: objeto <code>double_vec</code> (en Python) que contiene ICP Inicio, ICP Final, UF Inicio, UF Final (se debe respetar el orden)</li> </ul> <p>Recordar que TRA significa Tasa Real Anual y se determina utilizando los valores del \u00edndice ICP y los valores de la UF en la fecha de inicio y fecha final del <code>IcpClfCashflow</code>.</p> <pre><code># Ejemplo\nfecha_inicio = qcf.QCDate(20, 9, 2018)\nfecha_final = qcf.QCDate(20, 9, 2019)\nfecha_pago = qcf.QCDate(23, 9, 2019)\nnominal = 300_000.0\namort = 100_000.0\nspread = 0.0\ngearing = 1.0\n\nicp_uf = qcf.double_vec()\n# Los primeros dos valores corresponden a icp_inicial e icp_final.\n# Los segundos dos valores corresponden a uf_inicial y uf_final\nicp_uf.append(10_000.0)\nicp_uf.append(10_250.0)\nicp_uf.append(35_000.0)\nicp_uf.append(35_500.0)\n\nicp_clf_cashflow = qcf.IcpClfCashflow(\n    fecha_inicio, \n    fecha_final, \n    fecha_pago, \n    nominal, \n    amort, \n    True, \n    spread, \n    gearing, \n    icp_uf\n)\n</code></pre> <pre><code># Getters\nprint(\"Fecha Inicio:\", icp_clf_cashflow.get_start_date())\nprint(\"Fecha Final:\", icp_clf_cashflow.get_end_date())\n\nprint(f\"ICP Fecha Inicio: {icp_clf_cashflow.get_start_date_icp():,.2f}\")\nprint(f\"ICP Fecha Final: {icp_clf_cashflow.get_end_date_icp():,.2f}\")\n\nprint(f\"UF Fecha Inicio: {icp_clf_cashflow.get_start_date_uf():,.2f}\")\nprint(f\"UF Fecha Final: {icp_clf_cashflow.get_end_date_uf():,.2f}\")\n\nprint(f\"Valor TRA Todo el Per\u00edodo: {icp_clf_cashflow.get_rate_value():.4%}\")\ntna = icp_clf_cashflow.get_tna(fecha_final, 10_250.0)\ndias = fecha_inicio.day_diff(fecha_final)\ntra = ((1 + tna * dias / 360.0) * 35_000.0 / 35_500.0 - 1) * 360.0 / dias\nprint(f\"Check TRA: {round(tra, 6):.4%}\")\n\nprint(f\"Nominal: {icp_clf_cashflow.get_nominal():,.0f}\")\nprint(f\"Amortizaci\u00f3n: {icp_clf_cashflow.get_amortization():,.0f}\")\nprint(\"Tipo de Tasa:\", icp_clf_cashflow.get_type_of_rate())\nprint(\"Moneda:\", icp_clf_cashflow.ccy())\n</code></pre> <pre><code>Fecha Inicio: 2018-09-20\nFecha Final: 2019-09-20\nICP Fecha Inicio: 10,000.00\nICP Fecha Final: 10,250.00\nUF Fecha Inicio: 35,000.00\nUF Fecha Final: 35,500.00\nValor TRA Todo el Per\u00edodo: 1.0461%\nCheck TRA: 1.0461%\nNominal: 300,000\nAmortizaci\u00f3n: 100,000\nTipo de Tasa: LinAct360\nMoneda: CLF\n</code></pre> <pre><code># Setters\ndecimales_para_tra = 8\nicp_clf_cashflow.set_tra_decimal_places(decimales_para_tra)\nprint(f\"Nueva TRA: {icp_clf_cashflow.get_rate_value():.6%}\")\n\nnuevo_nominal = 100_000.0\nicp_clf_cashflow.set_nominal(nuevo_nominal)\nprint(f\"Nuevo Nominal: {icp_clf_cashflow.get_nominal():,.0f}\")\n\nnueva_amortizacion = 10_000.0\nicp_clf_cashflow.set_amortization(nueva_amortizacion)\nprint(f\"Nueva Amortizaci\u00f3n: {icp_clf_cashflow.get_amortization():,.0f}\")\n\nnuevo_icp_inicio = 20_000.0\nicp_clf_cashflow.set_start_date_icp(nuevo_icp_inicio)\nprint(f\"Nuevo ICP Inicio: {icp_clf_cashflow.get_start_date_icp():,.2f}\")\n\nnuevo_icp_final = 20_500.0\nicp_clf_cashflow.set_end_date_icp(nuevo_icp_final)\nprint(f\"Nuevo ICP Final: {icp_clf_cashflow.get_end_date_icp():,.2f}\")\nprint(f\"Check TNA Final: {icp_clf_cashflow.get_tna(fecha_final, nuevo_icp_final):.6%}\")\n</code></pre> <pre><code>Nueva TRA: 1.046054%\nNuevo Nominal: 100,000\nNueva Amortizaci\u00f3n: 10,000\nNuevo ICP Inicio: 20,000.00\nNuevo ICP Final: 20,500.00\nCheck TNA Final: 2.470000%\n</code></pre> <pre><code>icp_clf_cashflow.get_type()\n</code></pre> <pre><code>'IcpClfCashflow'\n</code></pre> <pre><code>qcf.show(icp_clf_cashflow)\n</code></pre> <pre><code>('2018-09-20',\n '2019-09-20',\n '2019-09-23',\n 100000.0,\n 10000.0,\n True,\n 11056.338028169024,\n 'CLF',\n 20000.0,\n 20500.0,\n 35000.0,\n 35500.0,\n 0.01046054,\n 1060.582527777787,\n 0.0,\n 1.0,\n 'LinAct360')\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#compounded-overnight-rate-cashflow","title":"Compounded Overnight Rate Cashflow","text":"<p>Un objeto de tipo <code>CompoundedOvernightRateCashflow</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un OIS sobre cualquier \u00edndice overnight (SOFR, FF, EONIA). Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>DateList</code>: fechas de fixing del \u00edndice</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nocional de la operaci\u00f3n</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>bool</code>: si <code>True</code> la tasa equivalente se calcula en convenci\u00f3n Lin Act/360. En caso contrario es Lin 30/360</li> <li><code>unsigned int</code>: n\u00famero de decimales a usar en el c\u00e1lculo de la tasa equivalente. Por ejemplo para 0.12345678% este valor debe ser 10.</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lookback</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lockout</li> </ul> <p>El efecto de lookback y lockout a\u00fan no est\u00e1 implementado.</p>"},{"location":"Ejemplos_qcfinancial_1/#constructor","title":"Constructor","text":"<p>Se da de alta un \u00edndice overnight ficiticio de test.</p> <pre><code>codigo = \"OITEST\"\nlin_act360 = qcf.QCInterestRate(0.0, act360, lin_wf)\nfixing_lag = qcf.Tenor(\"0d\")\ntenor = qcf.Tenor(\"1d\")\nfixing_calendar = scl\nsettlement_calendar = scl\noitest = qcf.InterestRateIndex(\n    codigo, \n    lin_act360, \n    fixing_lag, \n    tenor, \n    fixing_calendar, \n    settlement_calendar, \n    usd\n)\n</code></pre> <pre><code>fixing_dates = qcf.DateList()\n</code></pre> <pre><code>fixing_dates.append(qcf.QCDate(27, 12, 2021))\nfixing_dates.append(qcf.QCDate(28, 12, 2021))\nfixing_dates.append(qcf.QCDate(29, 12, 2021))\nfixing_dates.append(qcf.QCDate(30, 12, 2021))\n</code></pre> <pre><code>cor_cashflow = qcf.CompoundedOvernightRateCashflow(\n    oitest,\n    qcf.QCDate(27, 12, 2021),\n    qcf.QCDate(31, 12, 2021),\n    qcf.QCDate(31, 12, 2021),\n    fixing_dates,\n    10_000_000.0,\n    100_000.0,\n    True,\n    qcf.QCCLP(),\n    spread:=0.001,\n    1.0,\n    True,\n    8,\n    0,\n    0,\n)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#getters_1","title":"Getters","text":"<pre><code>cor_cashflow.get_start_date().description(False)\n</code></pre> <pre><code>'2021-12-27'\n</code></pre> <pre><code>cor_cashflow.get_end_date().description(False)\n</code></pre> <pre><code>'2021-12-31'\n</code></pre> <pre><code>cor_cashflow.get_settlement_date().description(False)\n</code></pre> <pre><code>'2021-12-31'\n</code></pre> <pre><code>for d in cor_cashflow.get_fixing_dates():\n    print(d)\n</code></pre> <pre><code>2021-12-27\n2021-12-28\n2021-12-29\n2021-12-30\n</code></pre> <pre><code>print(f\"Nominal: {cor_cashflow.get_nominal():,.0f}\")\n</code></pre> <pre><code>Nominal: 10,000,000\n</code></pre> <pre><code>print(f\"Amortization: {cor_cashflow.get_amortization():,.0f}\")\n</code></pre> <pre><code>Amortization: 100,000\n</code></pre> <pre><code>cor_cashflow.get_initial_currency().get_iso_code()\n</code></pre> <pre><code>'CLP'\n</code></pre> <pre><code>print(f\"Spread: {cor_cashflow.get_spread():.2%}\")\n</code></pre> <pre><code>Spread: 0.10%\n</code></pre> <pre><code>cor_cashflow.get_gearing()\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>cor_cashflow.get_type()\n</code></pre> <pre><code>'CompoundedOvernightRateCashflow'\n</code></pre> <pre><code>cor_cashflow.get_eq_rate_decimal_places()\n</code></pre> <pre><code>8\n</code></pre> <pre><code>derivs = cor_cashflow.get_amount_derivatives()\n</code></pre> <pre><code>len(derivs)\n</code></pre> <pre><code>2\n</code></pre> <pre><code>for der in derivs:\n    print(der)\n</code></pre> <pre><code>0.0\n0.0\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#setters_1","title":"Setters","text":"<pre><code>cor_cashflow.set_nominal(1_000)\nprint(f\"Nominal: {cor_cashflow.get_nominal():,.0f}\")\n</code></pre> <pre><code>Nominal: 1,000\n</code></pre> <pre><code>cor_cashflow.set_amortization(0)\ncor_cashflow.get_amortization()\n</code></pre> <pre><code>0.0\n</code></pre> <p>Se reversa el ejemplo.</p> <pre><code>cor_cashflow.set_nominal(10_000_000.0)\ncor_cashflow.set_amortization(100_000.0)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#accrued-fixing","title":"Accrued Fixing","text":"<p>Para el c\u00e1lculo de <code>accrued_fixing</code> se requiere un objeto de tipo <code>TimeSeries</code> que contenga los datos hist\u00f3ricos del \u00edndice overnight.</p> <pre><code>cor_cashflow.accrued_fixing(qcf.QCDate(29, 12, 2021))\n</code></pre> <pre><code>---------------------------------------------------------------------------\n\nValueError                                Traceback (most recent call last)\n\nCell In[255], line 1\n----&gt; 1 cor_cashflow.accrued_fixing(qcf.QCDate(29, 12, 2021))\n\n\nValueError: A TimeSeries object with overnight rate values is needed.\n</code></pre> <pre><code>ts = qcf.time_series()\n</code></pre> <pre><code>ts[qcf.QCDate(27, 12, 2021)] = 0.01\nts[qcf.QCDate(28, 12, 2021)] = 0.02\nts[qcf.QCDate(29, 12, 2021)] = 0.03\nts[qcf.QCDate(30, 12, 2021)] = 0.04\n</code></pre> <pre><code>print(f\"Accrued fixing: {cor_cashflow.accrued_fixing(qcf.QCDate(29, 12, 2021), ts):.6%}\")\n</code></pre> <pre><code>Accrued fixing: 1.500028%\n</code></pre> <pre><code>check = ((1 + 0.01 / 360) * (1 + 0.02 / 360.0) - 1) * 360 / 2.0\nprint(f\"Check: {check:.6%}\")\n</code></pre> <pre><code>Check: 1.500028%\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#accrued-interest","title":"Accrued Interest","text":"<p>Para el c\u00e1lculo de <code>accrued_interest</code> se requiere un objeto de tipo <code>TimeSeries</code> que contenga los datos hist\u00f3ricos del \u00edndice overnight.</p> <pre><code>cor_cashflow.accrued_interest(qcf.QCDate(29, 12, 2021))\n</code></pre> <pre><code>---------------------------------------------------------------------------\n\nValueError                                Traceback (most recent call last)\n\nCell In[260], line 1\n----&gt; 1 cor_cashflow.accrued_interest(qcf.QCDate(29, 12, 2021))\n\n\nValueError: A TimeSeries object with overnight rate values is needed.\n</code></pre> <pre><code>print(f\"Accrued interest: {cor_cashflow.accrued_interest(qcf.QCDate(29, 12, 2021), ts):,.2f}\")\n</code></pre> <pre><code>Accrued interest: 888.90\n</code></pre> <pre><code>check = (\n    cor_cashflow.get_nominal()\n    * (cor_cashflow.accrued_fixing(qcf.QCDate(29, 12, 2021), ts) + spread)\n    * 2\n    / 360.0\n)\nprint(f\"Check: {check:,.2f}\")\n</code></pre> <pre><code>Check: 888.90\n</code></pre> <pre><code>print(f\"Amount: {cor_cashflow.amount():,.2f}\")\n</code></pre> <pre><code>Amount: 100,111.11\n</code></pre> <pre><code>cor_cashflow.date().description(False)\n</code></pre> <pre><code>'2021-12-31'\n</code></pre> <pre><code>cor_cashflow.fixing(ts)\n</code></pre> <pre><code>0.02500243\n</code></pre> <pre><code>print(f\"Interest: {cor_cashflow.interest():,.2f}\")\n</code></pre> <pre><code>Interest: 111.11\n</code></pre> <pre><code>cor_cashflow.is_expired(qcf.QCDate(29, 12, 2021))\n</code></pre> <pre><code>False\n</code></pre> <pre><code>cor_cashflow.is_expired(qcf.QCDate(31, 12, 2021))\n</code></pre> <pre><code>True\n</code></pre> <pre><code>cor_cashflow.is_expired(qcf.QCDate(1, 1, 2022))\n</code></pre> <pre><code>True\n</code></pre> <pre><code>cor_cashflow.get_type()\n</code></pre> <pre><code>'CompoundedOvernightRateCashflow'\n</code></pre> <pre><code>qcf.show(cor_cashflow)\n</code></pre> <pre><code>('2021-12-27',\n '2021-12-31',\n '2021-12-31',\n 10000000.0,\n 100000.0,\n 888.9044444448934,\n True,\n 102889.15896133445,\n 'CLP',\n 'OITEST',\n 0.025002430652003582,\n 0.001,\n 1.0,\n 'LinAct360')\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#compounded-overnight-rate-cashflow-2","title":"Compounded Overnight Rate Cashflow 2","text":"<p>Un objeto de tipo <code>CompoundedOvernightRateCashflow2</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un OIS sobre cualquier \u00edndice overnight (SOFR, FF, EONIA). Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>DateList</code>: fechas de fixing del \u00edndice</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nocional de la operaci\u00f3n</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>QCInterestRate</code>: permite especificar cu\u00e1l es la convenci\u00f3n de c\u00e1lculo de la tasa equivalente</li> <li><code>unsigned int</code>: n\u00famero de decimales a usar en el c\u00e1lculo de la tasa equivalente. Por ejemplo para 0.12345678% este valor debe ser 10.</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lookback</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lockout</li> </ul> <p>El efecto de lookback y lockout a\u00fan no est\u00e1 implementado.</p>"},{"location":"Ejemplos_qcfinancial_1/#constructor_1","title":"Constructor","text":"<p>Se da de alta un \u00edndice overnight ficiticio de test.</p> <pre><code>codigo = \"OITEST\"\nlin_act360 = qcf.QCInterestRate(0.0, act360, lin_wf)\nfixing_lag = qcf.Tenor(\"0d\")\ntenor = qcf.Tenor(\"1d\")\nfixing_calendar = scl\nsettlement_calendar = scl\noitest = qcf.InterestRateIndex(\n    codigo, \n    lin_act360, \n    fixing_lag, \n    tenor, \n    fixing_calendar, \n    settlement_calendar, \n    usd\n)\n</code></pre> <pre><code>fixing_dates = qcf.DateList()\n</code></pre> <pre><code>fixing_dates.append(qcf.QCDate(27, 12, 2021))\nfixing_dates.append(qcf.QCDate(28, 12, 2021))\nfixing_dates.append(qcf.QCDate(29, 12, 2021))\nfixing_dates.append(qcf.QCDate(30, 12, 2021))\n</code></pre> <pre><code>cor_cashflow_2 = qcf.CompoundedOvernightRateCashflow2(\n    oitest,\n    qcf.QCDate(27, 12, 2021),\n    qcf.QCDate(31, 12, 2021),\n    qcf.QCDate(31, 12, 2021),\n    fixing_dates,\n    10_000_000.0,\n    100_000.0,\n    True,\n    qcf.QCCLP(),\n    spread:=0.001,\n    1.0,\n    qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    8,\n    0,\n    0,\n)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#getters_2","title":"Getters","text":"<pre><code>cor_cashflow_2.get_start_date().description(False)\n</code></pre> <pre><code>'2021-12-27'\n</code></pre> <pre><code>cor_cashflow_2.get_end_date().description(False)\n</code></pre> <pre><code>'2021-12-31'\n</code></pre> <pre><code>cor_cashflow_2.get_settlement_date().description(False)\n</code></pre> <pre><code>'2021-12-31'\n</code></pre> <pre><code>for d in cor_cashflow_2.get_fixing_dates():\n    print(d)\n</code></pre> <pre><code>2021-12-27\n2021-12-28\n2021-12-29\n2021-12-30\n</code></pre> <pre><code>print(f\"Nocional: {cor_cashflow_2.get_nominal():,.0f}\")\n</code></pre> <pre><code>Nocional: 10,000,000\n</code></pre> <pre><code>print(f\"Amortization: {cor_cashflow_2.get_amortization():,.0f}\")\n</code></pre> <pre><code>Amortization: 100,000\n</code></pre> <pre><code>cor_cashflow_2.ccy().get_iso_code()\n</code></pre> <pre><code>'CLP'\n</code></pre> <pre><code>print(f\"Spread: {cor_cashflow_2.get_spread():.2%}\")\n</code></pre> <pre><code>Spread: 0.10%\n</code></pre> <pre><code>cor_cashflow_2.get_gearing()\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>cor_cashflow_2.get_type()\n</code></pre> <pre><code>'CompoundedOvernightRateCashflow2'\n</code></pre> <pre><code>cor_cashflow_2.get_eq_rate_decimal_places()\n</code></pre> <pre><code>8\n</code></pre> <pre><code>derivs = cor_cashflow_2.get_amount_derivatives()\n</code></pre> <pre><code>len(derivs)\n</code></pre> <pre><code>2\n</code></pre> <pre><code>for der in derivs:\n    print(der)\n</code></pre> <pre><code>0.0\n0.0\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#setters_2","title":"Setters","text":"<pre><code>cor_cashflow_2.set_notional(1_000)\nprint(f\"Nocional: {cor_cashflow_2.get_nominal():,.0f}\")\n</code></pre> <pre><code>Nocional: 1,000\n</code></pre> <pre><code>cor_cashflow_2.set_amortization(0)\ncor_cashflow_2.get_amortization()\n</code></pre> <pre><code>0.0\n</code></pre> <p>Se reversa el ejemplo.</p> <pre><code>cor_cashflow_2.set_notional(10_000_000.0)\ncor_cashflow_2.set_amortization(100_000.0)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#accrued-fixing_1","title":"Accrued Fixing","text":"<p>Para el c\u00e1lculo de <code>accrued_fixing</code> se requiere un objeto de tipo <code>TimeSeries</code> que contenga los datos hist\u00f3ricos del \u00edndice overnight.</p> <pre><code>ts = qcf.time_series()\n</code></pre> <pre><code>ts[qcf.QCDate(27, 12, 2021)] = 0.01\nts[qcf.QCDate(28, 12, 2021)] = 0.02\nts[qcf.QCDate(29, 12, 2021)] = 0.03\nts[qcf.QCDate(30, 12, 2021)] = 0.04\n</code></pre> <pre><code>print(f\"Accrued fixing: {cor_cashflow_2.accrued_fixing(qcf.QCDate(29, 12, 2021), ts):.6%}\")\n</code></pre> <pre><code>Accrued fixing: 1.500028%\n</code></pre> <pre><code>check = ((1 + 0.01 / 360) * (1 + 0.02 / 360.0) - 1) * 360 / 2.0\nprint(f\"Check: {check:.6%}\")\n</code></pre> <pre><code>Check: 1.500028%\n</code></pre>"},{"location":"Ejemplos_qcfinancial_1/#accrued-interest_1","title":"Accrued Interest","text":"<p>Para el c\u00e1lculo de <code>accrued_interest</code> se requiere un objeto de tipo <code>TimeSeries</code> que contenga los datos hist\u00f3ricos del \u00edndice overnight.</p> <pre><code>print(f\"Accrued interest: {cor_cashflow_2.accrued_interest(qcf.QCDate(29, 12, 2021), ts):,.2f}\")\n</code></pre> <pre><code>Accrued interest: 888.90\n</code></pre> <pre><code>check = (\n    cor_cashflow_2.get_nominal()\n    * (cor_cashflow_2.accrued_fixing(qcf.QCDate(29, 12, 2021), ts) + spread)\n    * 2\n    / 360.0\n)\nprint(f\"Check: {check:,.2f}\")\n</code></pre> <pre><code>Check: 888.90\n</code></pre> <pre><code>print(f\"Amount: {cor_cashflow_2.amount():,.2f}\")\n</code></pre> <pre><code>Amount: 100,111.11\n</code></pre> <pre><code>cor_cashflow_2.date().description(False)\n</code></pre> <pre><code>'2021-12-31'\n</code></pre> <pre><code>print(f\"Interest: {cor_cashflow_2.interest_from_spread():,.2f}\")\n</code></pre> <pre><code>Interest: 111.11\n</code></pre> <pre><code>cor_cashflow_2.is_expired(qcf.QCDate(29, 12, 2021))\n</code></pre> <pre><code>False\n</code></pre> <pre><code>cor_cashflow_2.is_expired(qcf.QCDate(31, 12, 2021))\n</code></pre> <pre><code>False\n</code></pre> <pre><code>cor_cashflow_2.is_expired(qcf.QCDate(1, 1, 2022))\n</code></pre> <pre><code>True\n</code></pre> <pre><code>cor_cashflow_2.get_type()\n</code></pre> <pre><code>'CompoundedOvernightRateCashflow2'\n</code></pre> <pre><code>qcf.show(cor_cashflow)\n</code></pre> <pre><code>('2021-12-27',\n '2021-12-31',\n '2021-12-31',\n 10000000.0,\n 100000.0,\n 888.9044444448934,\n True,\n 102889.15896133445,\n 'CLP',\n 'OITEST',\n 0.025002430652003582,\n 0.001,\n 1.0,\n 'LinAct360')\n</code></pre> <pre><code>pd.DataFrame([qcf.show(cor_cashflow)], columns=qcf.get_column_names(\"CompoundedOvernightRateCashflow2\", \"\"))\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion interes amort_es_flujo flujo moneda codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2021-12-27 2021-12-31 2021-12-31 10000000.0 100000.0 888.904444 True 102889.158961 CLP OITEST 0.025002 0.001 1.0 LinAct360"},{"location":"Ejemplos_qcfinancial_1/#compounded-overnight-rate-multi-currency-cashflow-2","title":"Compounded Overnight Rate Multi Currency Cashflow 2","text":"<p>Un objeto de tipo <code>CompoundedOvernightRateMultiCurrencyCashflow2</code> representa un flujo de caja calculado como un cup\u00f3n de la pata flotante de un OIS sobre cualquier \u00edndice overnight (SOFR, FF, EONIA) que se liquidar\u00e1 en una moneda distinta de la moneda del nominal utilizando el valor a una cierta fecha de un \u00edndice de tipo de cambio prefijado.. Para dar de alta uno de estos objetos se requiere:</p> <ul> <li><code>InterestRateIndex</code>: el \u00edndice de tasa de inter\u00e9s prefijado</li> <li><code>QCDate</code>: fecha inicio (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha final (para la aplicaci\u00f3n de la tasa)</li> <li><code>QCDate</code>: fecha de pago</li> <li><code>DateList</code>: fechas de fixing del \u00edndice</li> <li><code>float</code>: nominal (monto al que se le aplica la tasa)</li> <li><code>float</code>: amortizaci\u00f3n (eventual flujo de caja que corresponde a una porci\u00f3n del nominal)</li> <li><code>bool</code>: indica si la amortizaci\u00f3n anterior es un flujo de caja o s\u00f3lo una disminuci\u00f3n de nominal</li> <li><code>QCCurrency</code>: moneda del nocional de la operaci\u00f3n</li> <li><code>float</code>: spread aditivo a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>float</code>: spread multiplicativo o gearing a aplicar a la fijaci\u00f3n de la TRA</li> <li><code>QCInterestRate</code>: permite especificar cu\u00e1l es la convenci\u00f3n de c\u00e1lculo de la tasa equivalente</li> <li><code>unsigned int</code>: n\u00famero de decimales a usar en el c\u00e1lculo de la tasa equivalente. Por ejemplo para 0.12345678% este valor debe ser 10.</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lookback</li> <li><code>unsigned int</code>: n\u00famero de d\u00edas de lockout</li> <li><code>QCDate</code>: fecha de fixing del \u00edndice FX</li> <li><code>QCCurrency</code>: moneda de pago o settlement</li> <li><code>FXRateIndex</code>: \u00edndice de tipo de cambio a utilizar</li> </ul> <p>El efecto de lookback y lockout a\u00fan no est\u00e1 implementado.</p>"},{"location":"Ejemplos_qcfinancial_1/#constructor_2","title":"Constructor","text":"<p>Se da de alta un \u00edndice overnight ficiticio de test.</p> <pre><code>codigo = \"OITEST\"\nlin_act360 = qcf.QCInterestRate(0.0, act360, lin_wf)\nfixing_lag = qcf.Tenor(\"0d\")\ntenor = qcf.Tenor(\"1d\")\nfixing_calendar = scl\nsettlement_calendar = scl\noitest = qcf.InterestRateIndex(\n    codigo, \n    lin_act360, \n    fixing_lag, \n    tenor, \n    fixing_calendar, \n    settlement_calendar, \n    usd\n)\n</code></pre> <pre><code>fixing_dates = qcf.DateList()\n</code></pre> <pre><code>fixing_dates.append(qcf.QCDate(27, 12, 2021))\nfixing_dates.append(qcf.QCDate(28, 12, 2021))\nfixing_dates.append(qcf.QCDate(29, 12, 2021))\nfixing_dates.append(qcf.QCDate(30, 12, 2021))\n</code></pre> <pre><code>cor_cashflow_mccy_2 = qcf.CompoundedOvernightRateMultiCurrencyCashflow2(\n    oitest,\n    qcf.QCDate(27, 12, 2021),\n    qcf.QCDate(31, 12, 2021),\n    qcf.QCDate(31, 12, 2021),\n    fixing_dates,\n    10_000_000.0,\n    100_000.0,\n    True,\n    qcf.QCCLP(),\n    spread:=0.001,\n    1.0,\n    qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    8,\n    0,\n    0,\n    qcf.QCDate(31, 12, 2021),\n    qcf.QCUSD(),\n    usdclp_obs,\n)\n</code></pre> <pre><code>qcf.show(cor_cashflow_mccy_2)\n</code></pre> <pre><code>('2021-12-27',\n '2021-12-31',\n '2021-12-31',\n 10000000.0,\n 100000.0,\n 111.11111111183902,\n True,\n 100111.11111111184,\n 'CLP',\n 'OITEST',\n 'LinAct360',\n 0.001,\n 1.0,\n 0.0,\n 'USD',\n 'USDOBS',\n '2021-12-31',\n 1.0,\n 111.11111111183902,\n 100000.0,\n 100111.11111111184)\n</code></pre> <pre><code>pd.DataFrame([qcf.show(cor_cashflow_mccy_2)], columns=qcf.get_column_names(\"CompoundedOvernightRateMultiCurrencyCashflow2\", \"\"))\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion interes amort_es_flujo flujo moneda codigo_indice_tasa ... spread gearing tipo_tasa moneda_pago fx_rate_index fecha_fixing_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2021-12-27 2021-12-31 2021-12-31 10000000.0 100000.0 111.111111 True 100111.111111 CLP OITEST ... 0.001 1.0 0.0 USD USDOBS 2021-12-31 1.0 111.111111 100000.0 100111.111111 <p>1 rows \u00d7 21 columns</p> <pre><code>cor_cashflow_mccy_2.set_fx_rate_index_value(2.0)\n</code></pre> <pre><code>cor_cashflow_mccy_2.interest(ts)\n</code></pre> <pre><code>2889.158888887966\n</code></pre> <pre><code>cor_cashflow_mccy_2.to_settlement_currency(cor_cashflow_mccy_2.interest(ts))\n</code></pre> <pre><code>1444.579444443983\n</code></pre>"},{"location":"Ejemplos_qcfinancial_2/","title":"Construcci\u00f3n de Operaciones","text":"<p>Para ejecutar todos los ejemplos se debe importar la librer\u00eda. Se sugiere utilizar siempre el alias <code>qcf</code>. </p> <pre><code>import qcfinancial as qcf\n\n# Para el despliegue de tablas de desarrollo, se importa pandas de la forma usual.\nimport pandas as pd\n</code></pre> <p>El siguiente diccionario se utiliza para dar formato a las columnas de los <code>pandas.DataFrames</code>.</p> <pre><code>format_dict = {\n    'nominal': '{0:,.2f}', \n    'nocional': '{0:,.2f}', \n    'amort': '{0:,.2f}', \n    'amortizacion': '{0:,.2f}', \n    'interes': '{0:,.2f}', \n    'flujo': '{0:,.2f}',\n    'icp_inicial': '{0:,.2f}', \n    'icp_final': '{0:,.2f}',\n    'valor_tasa': '{0:,.4%}', \n    'valor_tasa_equivalente': '{0:,.6%}', \n    'spread': '{0:,.4%}', \n    'gearing': '{0:,.2f}',\n    'amort_moneda_pago': '{0:,.2f}', \n    'interes_moneda_pago': '{0:,.2f}', \n    'valor_indice_fx': '{0:,.2f}'\n}\n</code></pre>"},{"location":"Ejemplos_qcfinancial_2/#legs","title":"Legs","text":"<p>Los objetos de tipo <code>Leg</code> son una lista (o vector) de objetos <code>Cashflow</code> y representan una pata de un instrumento financiero. un objeto de tipo <code>Leg</code> puede construirse a mano es decir, dando de alta cashflows y agreg\u00e1ndolos uno a uno o con algunos m\u00e9todos de conveniencia cuyo funcionamiento se mostrar\u00e1.</p>"},{"location":"Ejemplos_qcfinancial_2/#construccion-manual","title":"Construcci\u00f3n Manual","text":"<p>Se ver\u00e1 como construir un <code>Leg</code> con 2 <code>SimpleCashflow</code> de forma manual. En particular, este objeto <code>Leg</code> podr\u00eda representar una operaci\u00f3n FX por entrega f\u00edsica.</p> <pre><code>fecha_vcto = qcf.QCDate(20, 9, 2018)\n\nsimple_cashflow_1 = qcf.SimpleCashflow(\n    fecha_vcto,  # fecha del flujo\n    100,         # monto\n    qcf.QCCLP()  # moneda\n) \n\nsimple_cashflow_2 = qcf.SimpleCashflow(\n    fecha_vcto,  # fecha del flujo\n    -70000,      # monto\n    qcf.QCUSD()  # moneda\n)\n\nleg = qcf.Leg()\nleg.append_cashflow(simple_cashflow_1)\nleg.append_cashflow(simple_cashflow_2)\n</code></pre> <pre><code># Se observa el resultado\nnum = leg.size()\nfor i in range(0, num):\n    print(qcf.show(leg.get_cashflow_at(i)))\n</code></pre> <pre><code>('2018-09-20', 100.0, 'CLP')\n('2018-09-20', -70000.0, 'USD')\n</code></pre>"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-fixedrateleg","title":"Construcci\u00f3n Asistida de un <code>FixedRateLeg</code>","text":"<p>Se ver\u00e1 como construir objetos <code>Leg</code> donde cada <code>Cashflow</code> es un objeto de tipo <code>FixedRateCashflow</code>, todos con la misma tasa fija. En el primer ejemplo se construye un <code>Leg</code> de tipo bullet: una \u00fanica amortizaci\u00f3n igual al capital vigente de todos los <code>FixedRateCasflow</code> en el \u00faltimo flujo. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal inicial</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal y de los flujos</li> <li><code>bool</code>: si es <code>True</code> fuerza a que las fechas de pago coincidan con las fechas finales. Esto para lograr una valorizaci\u00f3n acorde a las convenciones de los mercados de renta fija, en caso que la <code>Leg</code> represente un bono a tasa fija.</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros siguientes se puede visualizar el efecto de ellos en la construcci\u00f3n.</p> <pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(5, 11, 2019)\nfecha_final = qcf.QCDate(31, 5, 2023)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.LONGFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\ncalendario.add_holiday(qcf.QCDate(31, 12, 2019))\nlag_pago = 0\nnominal = 100000.0\namort_es_flujo = False\ntasa_cupon = qcf.QCInterestRate(.03, qcf.QCAct360(), qcf.QCLinearWf())\nmoneda = qcf.QCCLF()\nes_bono = False\n\nfixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda,\n    is_bond=es_bono\n)\n</code></pre> <p>Se puede lograr una visualizaci\u00f3n del resultado utilizando un Dataframe de pandas y el m\u00e9todo <code>show</code>.</p> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, fixed_rate_leg.size()):\n    tabla.append(qcf.show(fixed_rate_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_ini', 'fecha_fin', 'fecha_pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo', 'moneda',\n            'valor_tasa', 'tipo_tasa']\ndf = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\n# df.style.format(format_dict))\ndf\n</code></pre> fecha_ini fecha_fin fecha_pago nominal amort interes amort_es_flujo flujo moneda valor_tasa tipo_tasa 0 2019-11-05 2020-05-29 2020-05-29 100000.0 0.0 1716.666667 False 1716.666667 CLF 0.03 LinAct360 1 2020-05-29 2020-11-30 2020-11-30 100000.0 0.0 1541.666667 False 1541.666667 CLF 0.03 LinAct360 2 2020-11-30 2021-05-31 2021-05-31 100000.0 0.0 1516.666667 False 1516.666667 CLF 0.03 LinAct360 3 2021-05-31 2021-11-30 2021-11-30 100000.0 0.0 1525.000000 False 1525.000000 CLF 0.03 LinAct360 4 2021-11-30 2022-05-31 2022-05-31 100000.0 0.0 1516.666667 False 1516.666667 CLF 0.03 LinAct360 5 2022-05-31 2022-11-30 2022-11-30 100000.0 0.0 1525.000000 False 1525.000000 CLF 0.03 LinAct360 6 2022-11-30 2023-05-31 2023-05-31 100000.0 100000.0 1516.666667 False 1516.666667 CLF 0.03 LinAct360"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-fixedrateleg2","title":"Construcci\u00f3n Asistida de un <code>FixedRateLeg2</code>","text":"<p>Se ver\u00e1 como construir objetos <code>Leg</code> donde cada <code>Cashflow</code> es un objeto de tipo <code>FixedRateCashflow2</code>, todos con la misma tasa fija. En el primer ejemplo se construye un <code>Leg</code> de tipo bullet: una \u00fanica amortizaci\u00f3n igual al capital vigente de todos los <code>FixedRateCasflow2</code> en el \u00faltimo flujo. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal inicial</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal y de los flujos</li> <li><code>bool</code>: si es <code>True</code> fuerza a que las fechas de pago coincidan con las fechas finales. Esto para lograr una valorizaci\u00f3n acorde a las convenciones de los mercados de renta fija, en caso que la <code>Leg</code> represente un bono a tasa fija.</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros siguientes se puede visualizar el efecto de ellos en la construcci\u00f3n.</p> <pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(4, 4, 2018)\nfecha_final = qcf.QCDate(1, 3, 2021) \nbus_adj_rule = qcf.BusyAdjRules.NO\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\ncalendario.add_holiday(qcf.QCDate(31, 12, 2018))\nlag_pago = 0\nnominal = 100000.0\namort_es_flujo = False\ntasa_cupon = qcf.QCInterestRate(.03, qcf.QCAct360(), qcf.QCLinearWf())\nmoneda = qcf.QCCLF()\nes_bono = False\n\n# Se da de alta el objeto\nfixed_rate_leg_2 = qcf.LegFactory.build_bullet_fixed_rate_leg_2(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad,\n    periodo_irregular,\n    calendario,\n    lag_pago,\n    nominal,\n    amort_es_flujo,\n    tasa_cupon,\n    moneda,\n    es_bono\n)\n</code></pre> <pre><code>tabla = []\nfor i in range(fixed_rate_leg_2.size()):\n    tabla.append(qcf.show(fixed_rate_leg_2.get_cashflow_at(i)))\n\ndf2 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf2\n</code></pre> fecha_ini fecha_fin fecha_pago nominal amort interes amort_es_flujo flujo moneda valor_tasa tipo_tasa 0 2018-04-04 2018-09-01 2018-09-03 100000.0 0.0 1250.000000 False 1250.000000 CLF 0.03 LinAct360 1 2018-09-01 2019-03-01 2019-03-01 100000.0 0.0 1508.333333 False 1508.333333 CLF 0.03 LinAct360 2 2019-03-01 2019-09-01 2019-09-02 100000.0 0.0 1533.333333 False 1533.333333 CLF 0.03 LinAct360 3 2019-09-01 2020-03-01 2020-03-02 100000.0 0.0 1516.666667 False 1516.666667 CLF 0.03 LinAct360 4 2020-03-01 2020-09-01 2020-09-01 100000.0 0.0 1533.333333 False 1533.333333 CLF 0.03 LinAct360 5 2020-09-01 2021-03-01 2021-03-01 100000.0 100000.0 1508.333333 False 1508.333333 CLF 0.03 LinAct360"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-customamortfixedrateleg","title":"Construcci\u00f3n Asistida de un <code>CustomAmortFixedRateLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> donde la estructura de amortizaciones es customizada. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>CustomNotionalAndAmort</code>: vector de capital vigente y amortizaciones customizado</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal y de los flujos</li> <li><code>bool</code>: si es <code>True</code> fuerza a que las fechas de pago coincidan con las fechas finales. Esto para lograr una valorizaci\u00f3n acorde a las convenciones de los mercados de renta fija, en caso que la <code>Leg</code> represente un bono a tasa fija.</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros siguientes se puede visualizar el efecto de ellos en la construcci\u00f3n.</p> <pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 1969)\nfecha_final = qcf.QCDate(31, 1, 1974) \nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\ncustom_notional_amort = qcf.CustomNotionalAmort()\ncustom_notional_amort.set_size(10)\nfor i in range(0, 10):\n    custom_notional_amort.set_notional_amort_at(i, 1000.0 - i * 100.0, 100.0)\namort_es_flujo = False\ntasa_cupon = qcf.QCInterestRate(.03, qcf.QC30360(), qcf.QCLinearWf())\nmoneda = qcf.QCCLF()\nes_bono = False\n</code></pre> <pre><code># Se da de alta el objeto\nfixed_rate_custom_leg = qcf.LegFactory.build_custom_amort_fixed_rate_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    notional_and_amort=custom_notional_amort, # custom_notional_amort,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda\n)\n</code></pre> <pre><code>params = dict(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    notional_and_amort=custom_notional_amort, # custom_notional_amort,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda\n)\n</code></pre> <pre><code>fixed_rate_custom_leg = qcf.LegFactory.build_custom_amort_fixed_rate_leg(**params)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, fixed_rate_custom_leg.size()):\n    tabla.append(qcf.show(fixed_rate_custom_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_ini', 'fecha_fin', 'fecha_pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo', 'moneda',\n            'valor_tasa', 'tipo_tasa']\ndf3 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf3 # .style.format(format_dict)\n</code></pre> fecha_ini fecha_fin fecha_pago nominal amort interes amort_es_flujo flujo moneda valor_tasa tipo_tasa 0 1969-01-31 1969-07-31 1969-07-31 1000.0 100.0 15.000000 False 15.000000 CLF 0.03 Lin30360 1 1969-07-31 1970-01-30 1970-01-30 900.0 100.0 13.500000 False 13.500000 CLF 0.03 Lin30360 2 1970-01-30 1970-07-31 1970-07-31 800.0 100.0 12.000000 False 12.000000 CLF 0.03 Lin30360 3 1970-07-31 1971-01-29 1971-01-29 700.0 100.0 10.441667 False 10.441667 CLF 0.03 Lin30360 4 1971-01-29 1971-07-30 1971-07-30 600.0 100.0 9.050000 False 9.050000 CLF 0.03 Lin30360 5 1971-07-30 1972-01-31 1972-01-31 500.0 100.0 7.500000 False 7.500000 CLF 0.03 Lin30360 6 1972-01-31 1972-07-31 1972-07-31 400.0 100.0 6.000000 False 6.000000 CLF 0.03 Lin30360 7 1972-07-31 1973-01-31 1973-01-31 300.0 100.0 4.500000 False 4.500000 CLF 0.03 Lin30360 8 1973-01-31 1973-07-31 1973-07-31 200.0 100.0 3.000000 False 3.000000 CLF 0.03 Lin30360 9 1973-07-31 1974-01-31 1974-01-31 100.0 100.0 1.500000 False 1.500000 CLF 0.03 Lin30360 <p>Veamos un ejemplo de una para R con amortizaciones negativas (disposiciones), esto es, con nocional creciente en el tiempo.</p> <pre><code>custom_notional_amort.set_notional_amort_at(0, 1000.0, -100.0)\ncustom_notional_amort.set_notional_amort_at(1, 1100.0, -100.0)\ncustom_notional_amort.set_notional_amort_at(2, 1200.0, -100.0)\nfor i in range(3, 10):\n    custom_notional_amort.set_notional_amort_at(i, 1200.0, 0.0)\n</code></pre> <pre><code>params = dict(\n    rec_pay=qcf.RecPay.PAY, # rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    notional_and_amort=custom_notional_amort, # custom_notional_amort,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=moneda\n)\n</code></pre> <pre><code>fixed_rate_custom_leg = qcf.LegFactory.build_custom_amort_fixed_rate_leg(**params)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, fixed_rate_custom_leg.size()):\n    tabla.append(qcf.show(fixed_rate_custom_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_ini', 'fecha_fin', 'fecha_pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo', 'moneda',\n            'valor_tasa', 'tipo_tasa']\ndf3 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf3 # .style.format(format_dict)\n</code></pre> fecha_ini fecha_fin fecha_pago nominal amort interes amort_es_flujo flujo moneda valor_tasa tipo_tasa 0 1969-01-31 1969-07-31 1969-07-31 -1000.0 100.0 -15.0 False -15.0 CLF 0.03 Lin30360 1 1969-07-31 1970-01-30 1970-01-30 -1100.0 100.0 -16.5 False -16.5 CLF 0.03 Lin30360 2 1970-01-30 1970-07-31 1970-07-31 -1200.0 100.0 -18.0 False -18.0 CLF 0.03 Lin30360 3 1970-07-31 1971-01-29 1971-01-29 -1200.0 -0.0 -17.9 False -17.9 CLF 0.03 Lin30360 4 1971-01-29 1971-07-30 1971-07-30 -1200.0 -0.0 -18.1 False -18.1 CLF 0.03 Lin30360 5 1971-07-30 1972-01-31 1972-01-31 -1200.0 -0.0 -18.0 False -18.0 CLF 0.03 Lin30360 6 1972-01-31 1972-07-31 1972-07-31 -1200.0 -0.0 -18.0 False -18.0 CLF 0.03 Lin30360 7 1972-07-31 1973-01-31 1973-01-31 -1200.0 -0.0 -18.0 False -18.0 CLF 0.03 Lin30360 8 1973-01-31 1973-07-31 1973-07-31 -1200.0 -0.0 -18.0 False -18.0 CLF 0.03 Lin30360 9 1973-07-31 1974-01-31 1974-01-31 -1200.0 -0.0 -18.0 False -18.0 CLF 0.03 Lin30360"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-fixedratemulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>FixedRateMultiCurrencyLeg</code>","text":"<p>Se ver\u00e1 como construir objetos <code>Leg</code> donde cada <code>Cashflow</code> es un objeto de tipo <code>FixedRateMultiCurrencyCashflow</code>, todos con la misma tasa fija. En el primer ejemplo se construye un <code>Leg</code> de tipo bullet: una \u00fanica amortizaci\u00f3n igual al capital vigente de todos los <code>FixedRateMultiCurrencyCasflow</code> en el \u00faltimo flujo. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal inicial</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal</li> <li><code>QCCurrency</code>: moneda de los flujos</li> <li><code>FXRateIndex</code>: \u00edndice con el cual se transforma cada flujo a la moneda de pago.</li> <li><code>bool</code>: si es <code>True</code> fuerza a que las fechas de pago coincidan con las fechas finales. Esto para lograr una valorizaci\u00f3n acorde a las convenciones de los mercados de renta fija, en caso que la <code>Leg</code> represente un bono a tasa fija.</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros siguientes se puede visualizar el efecto de ellos en la construcci\u00f3n.</p> <pre><code># Primero se debe dar de alta un FXRateIndex\nusd = qcf.QCUSD()\nclp = qcf.QCCLP()\nusdclp = qcf.FXRate(usd, clp)\none_d = qcf.Tenor('1D')\nusdclp_obs = qcf.FXRateIndex(usdclp, 'USDOBS', one_d, one_d, calendario)\n\n# Luego se dan de alta los otros par\u00e1metros requeridos para la construcci\u00f3n\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 1969)\nfecha_final = qcf.QCDate(31, 1, 1974) \nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\nlag_pago = 1\nes_bono = False\n</code></pre> <pre><code># Se da de alta el objeto\nfixed_rate_mccy_leg = qcf.LegFactory.build_bullet_fixed_rate_mccy_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=usd,\n    settlement_currency=clp,\n    fx_rate_index=usdclp_obs,\n    fx_rate_index_fixing_lag=2,\n    is_bond=es_bono\n)\n</code></pre> <pre><code>params = dict(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=usd,\n    settlement_currency=clp,\n    fx_rate_index=usdclp_obs,\n    fx_rate_index_fixing_lag=2,\n    is_bond=es_bono\n)\n</code></pre> <pre><code>fixed_rate_mccy_leg = qcf.LegFactory.build_bullet_fixed_rate_mccy_leg(\n    **params\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, fixed_rate_mccy_leg.size()):\n    tabla.append(qcf.show(fixed_rate_mccy_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo', 'moneda_nominal',\n            'valor_tasa', 'tipo_tasa', 'fecha_fijacion_fx', 'moneda_pago', 'indice_fx', 'valor_indice_fx', 'amort_moneda_pago',\n           'interes_moneda_pago']\ndf4 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf4\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort interes amort_es_flujo flujo moneda_nominal valor_tasa tipo_tasa fecha_fijacion_fx moneda_pago indice_fx valor_indice_fx amort_moneda_pago interes_moneda_pago 0 1969-01-31 1969-07-31 1969-08-01 100000.0 0.0 1500.000000 False 1500.000000 USD 0.03 Lin30360 1969-07-30 CLP USDOBS 1.0 0.0 1500.000000 1 1969-07-31 1970-01-30 1970-02-02 100000.0 0.0 1500.000000 False 1500.000000 USD 0.03 Lin30360 1970-01-29 CLP USDOBS 1.0 0.0 1500.000000 2 1970-01-30 1970-07-31 1970-08-03 100000.0 0.0 1500.000000 False 1500.000000 USD 0.03 Lin30360 1970-07-30 CLP USDOBS 1.0 0.0 1500.000000 3 1970-07-31 1971-01-29 1971-02-01 100000.0 0.0 1491.666667 False 1491.666667 USD 0.03 Lin30360 1971-01-28 CLP USDOBS 1.0 0.0 1491.666667 4 1971-01-29 1971-07-30 1971-08-02 100000.0 0.0 1508.333333 False 1508.333333 USD 0.03 Lin30360 1971-07-29 CLP USDOBS 1.0 0.0 1508.333333 5 1971-07-30 1972-01-31 1972-02-01 100000.0 0.0 1500.000000 False 1500.000000 USD 0.03 Lin30360 1972-01-28 CLP USDOBS 1.0 0.0 1500.000000 6 1972-01-31 1972-07-31 1972-08-01 100000.0 0.0 1500.000000 False 1500.000000 USD 0.03 Lin30360 1972-07-28 CLP USDOBS 1.0 0.0 1500.000000 7 1972-07-31 1973-01-31 1973-02-01 100000.0 0.0 1500.000000 False 1500.000000 USD 0.03 Lin30360 1973-01-30 CLP USDOBS 1.0 0.0 1500.000000 8 1973-01-31 1973-07-31 1973-08-01 100000.0 0.0 1500.000000 False 1500.000000 USD 0.03 Lin30360 1973-07-30 CLP USDOBS 1.0 0.0 1500.000000 9 1973-07-31 1974-01-31 1974-02-01 100000.0 100000.0 1500.000000 False 1500.000000 USD 0.03 Lin30360 1974-01-30 CLP USDOBS 1.0 100000.0 1500.000000"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-customamortfixedratemulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>CustomAmortFixedRateMultiCurrencyLeg</code>","text":"<p>Se ver\u00e1 como construir objetos <code>Leg</code> donde cada <code>Cashflow</code> es un objeto de tipo <code>FixedRateMultiCurrencyCashflow</code>, todos con la misma tasa fija. En el primer ejemplo se construye un <code>Leg</code> de tipo bullet: una \u00fanica amortizaci\u00f3n igual al capital vigente de todos los <code>FixedRateMultiCurrencyCasflow</code> en el \u00faltimo flujo. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>CustomNotionalAndAmort</code>: vector de capital vigente y amortizaciones customizado</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n es un flujo de caja efectivo</li> <li><code>QCInterestRate</code>: la tasa a aplicar en cada flujo</li> <li><code>QCCurrency</code>: moneda del nominal</li> <li><code>QCCurrency</code>: moneda de los flujos</li> <li><code>FXRateIndex</code>: \u00edndice con el cual se transforma cada flujo a la moneda de pago.</li> <li><code>bool</code>: si es <code>True</code> fuerza a que las fechas de pago coincidan con las fechas finales. Esto para lograr una valorizaci\u00f3n acorde a las convenciones de los mercados de renta fija, en caso que la <code>Leg</code> represente un bono a tasa fija.</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros siguientes se puede visualizar el efecto de ellos en la construcci\u00f3n.</p> <pre><code># Primero se debe dar de alta un FXRateIndex\nusd = qcf.QCUSD()\nclp = qcf.QCCLP()\nusdclp = qcf.FXRate(usd, clp)\none_d = qcf.Tenor('1D')\nusdclp_obs = qcf.FXRateIndex(usdclp, 'USDOBS', one_d, one_d, calendario)\n\n# Luego se dan de alta los otros par\u00e1metros requeridos para la construcci\u00f3n\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 1969)\nfecha_final = qcf.QCDate(31, 1, 1974) \nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\nlag_pago = 1\nes_bono = False\n\n# Amortizaciones\ncustom_notional_amort = qcf.CustomNotionalAmort()\ncustom_notional_amort.set_size(10)\nfor i in range(0, 10):\n    custom_notional_amort.set_notional_amort_at(i, 1000.0 - i * 100.0, 100.0)\n\n# Se da de alta el objeto\nfixed_rate_mccy_leg = qcf.LegFactory.build_custom_amort_fixed_rate_mccy_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad,\n    stub_period=periodo_irregular,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    notional_and_amort=custom_notional_amort,\n    amort_is_cashflow=amort_es_flujo,\n    interest_rate=tasa_cupon,\n    notional_currency=usd,\n    settlement_currency=clp,\n    fx_rate_index=usdclp_obs,\n    fx_rate_index_fixing_lag=2,\n    is_bond=es_bono\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, fixed_rate_mccy_leg.size()):\n    tabla.append(qcf.show(fixed_rate_mccy_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo', 'moneda_nominal',\n            'valor_tasa', 'tipo_tasa', 'fecha_fijacion_fx', 'moneda_pago', 'indice_fx', 'valor_indice_fx', 'amort_moneda_pago',\n           'interes_moneda_pago']\ndf4 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf4\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort interes amort_es_flujo flujo moneda_nominal valor_tasa tipo_tasa fecha_fijacion_fx moneda_pago indice_fx valor_indice_fx amort_moneda_pago interes_moneda_pago 0 1969-01-31 1969-07-31 1969-08-01 1000.0 100.0 15.000000 False 15.000000 USD 0.03 Lin30360 1969-07-30 CLP USDOBS 1.0 100.0 15.000000 1 1969-07-31 1970-01-30 1970-02-02 900.0 100.0 13.500000 False 13.500000 USD 0.03 Lin30360 1970-01-29 CLP USDOBS 1.0 100.0 13.500000 2 1970-01-30 1970-07-31 1970-08-03 800.0 100.0 12.000000 False 12.000000 USD 0.03 Lin30360 1970-07-30 CLP USDOBS 1.0 100.0 12.000000 3 1970-07-31 1971-01-29 1971-02-01 700.0 100.0 10.441667 False 10.441667 USD 0.03 Lin30360 1971-01-28 CLP USDOBS 1.0 100.0 10.441667 4 1971-01-29 1971-07-30 1971-08-02 600.0 100.0 9.050000 False 9.050000 USD 0.03 Lin30360 1971-07-29 CLP USDOBS 1.0 100.0 9.050000 5 1971-07-30 1972-01-31 1972-02-01 500.0 100.0 7.500000 False 7.500000 USD 0.03 Lin30360 1972-01-28 CLP USDOBS 1.0 100.0 7.500000 6 1972-01-31 1972-07-31 1972-08-01 400.0 100.0 6.000000 False 6.000000 USD 0.03 Lin30360 1972-07-28 CLP USDOBS 1.0 100.0 6.000000 7 1972-07-31 1973-01-31 1973-02-01 300.0 100.0 4.500000 False 4.500000 USD 0.03 Lin30360 1973-01-30 CLP USDOBS 1.0 100.0 4.500000 8 1973-01-31 1973-07-31 1973-08-01 200.0 100.0 3.000000 False 3.000000 USD 0.03 Lin30360 1973-07-30 CLP USDOBS 1.0 100.0 3.000000 9 1973-07-31 1974-01-31 1974-02-01 100.0 100.0 1.500000 False 1.500000 USD 0.03 Lin30360 1974-01-30 CLP USDOBS 1.0 100.0 1.500000"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-bulletiborleg","title":"Construcci\u00f3n Asistida de un <code>BulletIborLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>IborCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>Tenor</code>: periodicidad de fijaci\u00f3n</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular para el calendario de fijaciones</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n</li> <li><code>unsigned int</code>: lag de fijaci\u00f3n expresado en d\u00edas</li> <li><code>InterestRateIndex</code>: \u00edndice de tasa de inter\u00e9s utilizado en cada <code>IborCashflow</code></li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>QCCurrency</code>: moneda del nominal y de los flujos</li> <li><code>float</code>: spread aditivo</li> <li><code>gearing</code>: spread multiplicativo</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros anteriores se puede visualizar el efecto de ellos en la construcci\u00f3n. </p> <p>NOTA: para construir un <code>Leg</code> con <code>IborCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_ibor_leg(...)</code>.</p> <pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 1969)\nfecha_final = qcf.QCDate(31, 1, 1974) \nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('3M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nperiodicidad_fijacion = qcf.Tenor('3M')\nperiodo_irregular_fijacion = qcf.StubPeriod.NO\n\n# vamos a usar el mismo calendario para pago y fijaciones\nlag_de_fijacion = 2\n\n# Definici\u00f3n del \u00edndice\ncodigo = 'LIBORUSD3M'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('2d')\ntenor = qcf.Tenor('3m')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\nlibor_usd_3m = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd\n)\n# Fin \u00edndice\n\nnominal = 1000000.0\namort_es_flujo = True \nmoneda = usd\nspread = .01\ngearing = 1.0\n\nibor_leg = qcf.LegFactory.build_bullet_ibor_leg(\n    rec_pay=rp, \n    start_date=fecha_inicio, \n    end_date=fecha_final, \n    bus_adj_rule=bus_adj_rule, \n    settlement_periodicity=periodicidad_pago,\n    stub_period=periodo_irregular_pago, \n    settlement_calendar=calendario, \n    settlement_lag=lag_pago,\n    fixing_periodicity=periodicidad_fijacion, \n    fixing_stub_period=periodo_irregular_fijacion,\n    fixing_calendar=calendario, \n    fixing_lag=lag_de_fijacion, \n    interest_rate_index=libor_usd_3m,\n    initial_notional=nominal, \n    amort_is_cashflow=amort_es_flujo, \n    notional_currency=moneda, \n    spread=spread, \n    gearing=gearing,\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, ibor_leg.size()):\n    tabla.append(qcf.show(ibor_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha_fixing', 'fecha__pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo',\n            'moneda', 'codigo_indice', 'valor_tasa', 'spread', 'gearing', 'tipo_tasa']\ndf5 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf5\n</code></pre> fecha_inicial fecha__final fecha_fixing fecha__pago nominal amort interes amort_es_flujo flujo moneda codigo_indice valor_tasa spread gearing tipo_tasa 0 1969-01-31 1969-04-30 1969-01-29 1969-04-30 1000000.0 0.0 2472.222222 True 2.472222e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 1 1969-04-30 1969-07-31 1969-04-28 1969-07-31 1000000.0 0.0 2555.555556 True 2.555556e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 2 1969-07-31 1969-10-31 1969-07-29 1969-10-31 1000000.0 0.0 2555.555556 True 2.555556e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 3 1969-10-31 1970-01-30 1969-10-29 1970-01-30 1000000.0 0.0 2527.777778 True 2.527778e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 4 1970-01-30 1970-04-30 1970-01-28 1970-04-30 1000000.0 0.0 2500.000000 True 2.500000e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 5 1970-04-30 1970-07-31 1970-04-28 1970-07-31 1000000.0 0.0 2555.555556 True 2.555556e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 6 1970-07-31 1970-10-30 1970-07-29 1970-10-30 1000000.0 0.0 2527.777778 True 2.527778e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 7 1970-10-30 1971-01-29 1970-10-28 1971-01-29 1000000.0 0.0 2527.777778 True 2.527778e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 8 1971-01-29 1971-04-30 1971-01-27 1971-04-30 1000000.0 0.0 2527.777778 True 2.527778e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 9 1971-04-30 1971-07-30 1971-04-28 1971-07-30 1000000.0 0.0 2527.777778 True 2.527778e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 10 1971-07-30 1971-10-29 1971-07-28 1971-10-29 1000000.0 0.0 2527.777778 True 2.527778e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 11 1971-10-29 1972-01-31 1971-10-27 1972-01-31 1000000.0 0.0 2611.111111 True 2.611111e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 12 1972-01-31 1972-04-28 1972-01-27 1972-04-28 1000000.0 0.0 2444.444444 True 2.444444e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 13 1972-04-28 1972-07-31 1972-04-26 1972-07-31 1000000.0 0.0 2611.111111 True 2.611111e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 14 1972-07-31 1972-10-31 1972-07-27 1972-10-31 1000000.0 0.0 2555.555556 True 2.555556e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 15 1972-10-31 1973-01-31 1972-10-27 1973-01-31 1000000.0 0.0 2555.555556 True 2.555556e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 16 1973-01-31 1973-04-30 1973-01-29 1973-04-30 1000000.0 0.0 2472.222222 True 2.472222e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 17 1973-04-30 1973-07-31 1973-04-26 1973-07-31 1000000.0 0.0 2555.555556 True 2.555556e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 18 1973-07-31 1973-10-31 1973-07-27 1973-10-31 1000000.0 0.0 2555.555556 True 2.555556e+03 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 19 1973-10-31 1974-01-31 1973-10-29 1974-01-31 1000000.0 1000000.0 2555.555556 True 1.002556e+06 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 <p>Ahora con amortizaci\u00f3n customizada.</p> <pre><code># Amortizaciones\ncustom_notional_amort = qcf.CustomNotionalAmort()\ncustom_notional_amort.set_size(20)\nfor i in range(0, 20):\n    custom_notional_amort.set_notional_amort_at(i, 2000.0 - i * 100.0, 100.0)\n</code></pre> <pre><code>custom_amort_ibor_leg = qcf.LegFactory.build_custom_amort_ibor_leg(\n    rec_pay=rp, \n    start_date=fecha_inicio, \n    end_date=fecha_final, \n    bus_adj_rule=bus_adj_rule, \n    settlement_periodicity=periodicidad_pago,\n    stub_period=periodo_irregular_pago, \n    settlement_calendar=calendario, \n    settlement_lag=lag_pago,\n    fixing_periodicity=periodicidad_fijacion, \n    fixing_stub_period=periodo_irregular_fijacion,\n    fixing_calendar=calendario, \n    fixing_lag=lag_de_fijacion, \n    interest_rate_index=libor_usd_3m,\n    notional_and_amort=custom_notional_amort, \n    amort_is_cashflow=amort_es_flujo, \n    notional_currency=moneda, \n    spread=spread, \n    gearing=gearing,\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, custom_amort_ibor_leg.size()):\n    tabla.append(qcf.show(custom_amort_ibor_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha_fixing', 'fecha__pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo',\n            'moneda', 'codigo_indice', 'valor_tasa', 'spread', 'gearing', 'tipo_tasa']\ndf5 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato \ndf5\n</code></pre> fecha_inicial fecha__final fecha_fixing fecha__pago nominal amort interes amort_es_flujo flujo moneda codigo_indice valor_tasa spread gearing tipo_tasa 0 1969-01-31 1969-04-30 1969-01-29 1969-04-30 2000.0 100.0 0.002472 True 100.002472 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 1 1969-04-30 1969-07-31 1969-04-28 1969-07-31 1900.0 100.0 0.002556 True 100.002556 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 2 1969-07-31 1969-10-31 1969-07-29 1969-10-31 1800.0 100.0 0.002556 True 100.002556 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 3 1969-10-31 1970-01-30 1969-10-29 1970-01-30 1700.0 100.0 0.002528 True 100.002528 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 4 1970-01-30 1970-04-30 1970-01-28 1970-04-30 1600.0 100.0 0.002500 True 100.002500 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 5 1970-04-30 1970-07-31 1970-04-28 1970-07-31 1500.0 100.0 0.002556 True 100.002556 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 6 1970-07-31 1970-10-30 1970-07-29 1970-10-30 1400.0 100.0 0.002528 True 100.002528 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 7 1970-10-30 1971-01-29 1970-10-28 1971-01-29 1300.0 100.0 0.002528 True 100.002528 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 8 1971-01-29 1971-04-30 1971-01-27 1971-04-30 1200.0 100.0 0.002528 True 100.002528 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 9 1971-04-30 1971-07-30 1971-04-28 1971-07-30 1100.0 100.0 0.002528 True 100.002528 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 10 1971-07-30 1971-10-29 1971-07-28 1971-10-29 1000.0 100.0 0.002528 True 100.002528 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 11 1971-10-29 1972-01-31 1971-10-27 1972-01-31 900.0 100.0 0.002611 True 100.002611 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 12 1972-01-31 1972-04-28 1972-01-27 1972-04-28 800.0 100.0 0.002444 True 100.002444 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 13 1972-04-28 1972-07-31 1972-04-26 1972-07-31 700.0 100.0 0.002611 True 100.002611 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 14 1972-07-31 1972-10-31 1972-07-27 1972-10-31 600.0 100.0 0.002556 True 100.002556 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 15 1972-10-31 1973-01-31 1972-10-27 1973-01-31 500.0 100.0 0.002556 True 100.002556 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 16 1973-01-31 1973-04-30 1973-01-29 1973-04-30 400.0 100.0 0.002472 True 100.002472 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 17 1973-04-30 1973-07-31 1973-04-26 1973-07-31 300.0 100.0 0.002556 True 100.002556 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 18 1973-07-31 1973-10-31 1973-07-27 1973-10-31 200.0 100.0 0.002556 True 100.002556 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360 19 1973-10-31 1974-01-31 1973-10-29 1974-01-31 100.0 100.0 0.002556 True 100.002556 USD LIBORUSD3M 0.0 0.01 1.0 LinAct360"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-bulletibormulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>BulletIborMultiCurrencyLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>IborMultiCurrencyCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>Tenor</code>: periodicidad de fijaci\u00f3n</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular para el calendario de fijaciones</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n</li> <li><code>unsigned int</code>: lag de fijaci\u00f3n expresado en d\u00edas</li> <li><code>InterestRateIndex</code>: \u00edndice de tasa de inter\u00e9s utilizado en cada <code>IborMultiCurrencyCashflow</code></li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>QCCurrency</code>: moneda del nominal</li> <li><code>float</code>: spread aditivo</li> <li><code>gearing</code>: spread multiplicativo</li> <li><code>QCCurrency</code>: moneda del nominal</li> <li><code>QCCurrency</code>: moneda de pago los flujos</li> <li><code>FXRateIndex</code>: \u00edndice con el cual se transforma cada flujo a la moneda de pago</li> <li><code>int</code>: lag de fijaci\u00f3n del FXRateIndex (respecto a settlement date)</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros anteriores se puede visualizar el efecto de ellos en la construcci\u00f3n. </p> <pre><code>ibor_mccy_leg = qcf.LegFactory.build_bullet_ibor_mccy_leg(\n    rec_pay=rp, \n    start_date=fecha_inicio, \n    end_date=fecha_final, \n    bus_adj_rule=bus_adj_rule, \n    settlement_periodicity=periodicidad_pago,\n    stub_period=periodo_irregular_pago, \n    settlement_calendar=calendario, \n    settlement_lag=1, #lag_pago,\n    fixing_periodicity=periodicidad_fijacion, \n    fixing_stub_period=periodo_irregular_fijacion,\n    fixing_calendar=calendario, \n    fixing_lag=lag_de_fijacion, \n    interest_rate_index=libor_usd_3m,\n    initial_notional=nominal, \n    amort_is_cashflow=amort_es_flujo, \n    notional_currency=usd, \n    spread=spread, \n    gearing=gearing,\n    settlement_currency=clp, \n    fx_rate_index=usdclp_obs, \n    fx_rate_index_fixing_lag=1\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, ibor_mccy_leg.size()):\n    ibor_mccy_leg.get_cashflow_at(i).set_fx_rate_index_value(10.0)\n    tabla.append(qcf.show(ibor_mccy_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha_fixing', 'fecha__pago',\n            'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo',\n            'moneda_nominal', 'codigo_indice_tasa', 'spread', 'gearing', 'valor_tasa', 'tipo_tasa',\n            'fecha_fijacion_fx', 'moneda_pago', 'codigo_indice_fx', 'valor_indice_fx',\n            'amort_moneda_pago', 'interes_moneda_pago']\ndf6 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf6.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha_fixing fecha__pago nominal amort interes amort_es_flujo flujo moneda_nominal codigo_indice_tasa spread gearing valor_tasa tipo_tasa fecha_fijacion_fx moneda_pago codigo_indice_fx valor_indice_fx amort_moneda_pago interes_moneda_pago 0 1969-01-31 1969-04-30 1969-01-29 1969-05-01 1,000,000.00 0.00 2,472.22 True 24,722.22 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1969-04-30 CLP USDOBS 10.00 0.00 24,722.22 1 1969-04-30 1969-07-31 1969-04-28 1969-08-01 1,000,000.00 0.00 2,555.56 True 25,555.56 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1969-07-31 CLP USDOBS 10.00 0.00 25,555.56 2 1969-07-31 1969-10-31 1969-07-29 1969-11-03 1,000,000.00 0.00 2,555.56 True 25,555.56 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1969-10-31 CLP USDOBS 10.00 0.00 25,555.56 3 1969-10-31 1970-01-30 1969-10-29 1970-02-02 1,000,000.00 0.00 2,527.78 True 25,277.78 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1970-01-30 CLP USDOBS 10.00 0.00 25,277.78 4 1970-01-30 1970-04-30 1970-01-28 1970-05-01 1,000,000.00 0.00 2,500.00 True 25,000.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1970-04-30 CLP USDOBS 10.00 0.00 25,000.00 5 1970-04-30 1970-07-31 1970-04-28 1970-08-03 1,000,000.00 0.00 2,555.56 True 25,555.56 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1970-07-31 CLP USDOBS 10.00 0.00 25,555.56 6 1970-07-31 1970-10-30 1970-07-29 1970-11-02 1,000,000.00 0.00 2,527.78 True 25,277.78 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1970-10-30 CLP USDOBS 10.00 0.00 25,277.78 7 1970-10-30 1971-01-29 1970-10-28 1971-02-01 1,000,000.00 0.00 2,527.78 True 25,277.78 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1971-01-29 CLP USDOBS 10.00 0.00 25,277.78 8 1971-01-29 1971-04-30 1971-01-27 1971-05-03 1,000,000.00 0.00 2,527.78 True 25,277.78 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1971-04-30 CLP USDOBS 10.00 0.00 25,277.78 9 1971-04-30 1971-07-30 1971-04-28 1971-08-02 1,000,000.00 0.00 2,527.78 True 25,277.78 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1971-07-30 CLP USDOBS 10.00 0.00 25,277.78 10 1971-07-30 1971-10-29 1971-07-28 1971-11-01 1,000,000.00 0.00 2,527.78 True 25,277.78 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1971-10-29 CLP USDOBS 10.00 0.00 25,277.78 11 1971-10-29 1972-01-31 1971-10-27 1972-02-01 1,000,000.00 0.00 2,611.11 True 26,111.11 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1972-01-31 CLP USDOBS 10.00 0.00 26,111.11 12 1972-01-31 1972-04-28 1972-01-27 1972-05-01 1,000,000.00 0.00 2,444.44 True 24,444.44 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1972-04-28 CLP USDOBS 10.00 0.00 24,444.44 13 1972-04-28 1972-07-31 1972-04-26 1972-08-01 1,000,000.00 0.00 2,611.11 True 26,111.11 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1972-07-31 CLP USDOBS 10.00 0.00 26,111.11 14 1972-07-31 1972-10-31 1972-07-27 1972-11-01 1,000,000.00 0.00 2,555.56 True 25,555.56 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1972-10-31 CLP USDOBS 10.00 0.00 25,555.56 15 1972-10-31 1973-01-31 1972-10-27 1973-02-01 1,000,000.00 0.00 2,555.56 True 25,555.56 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1973-01-31 CLP USDOBS 10.00 0.00 25,555.56 16 1973-01-31 1973-04-30 1973-01-29 1973-05-01 1,000,000.00 0.00 2,472.22 True 24,722.22 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1973-04-30 CLP USDOBS 10.00 0.00 24,722.22 17 1973-04-30 1973-07-31 1973-04-26 1973-08-01 1,000,000.00 0.00 2,555.56 True 25,555.56 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1973-07-31 CLP USDOBS 10.00 0.00 25,555.56 18 1973-07-31 1973-10-31 1973-07-27 1973-11-01 1,000,000.00 0.00 2,555.56 True 25,555.56 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1973-10-31 CLP USDOBS 10.00 0.00 25,555.56 19 1973-10-31 1974-01-31 1973-10-29 1974-02-01 1,000,000.00 1,000,000.00 2,555.56 True 10,025,555.56 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1974-01-31 CLP USDOBS 10.00 10,000,000.00 25,555.56 <p>Ahora con amortizaci\u00f3n customizada.</p> <pre><code>ibor_custom_amort_mccy_leg = qcf.LegFactory.build_custom_amort_ibor_mccy_leg(\n    rec_pay=rp, \n    start_date=fecha_inicio, \n    end_date=fecha_final, \n    bus_adj_rule=bus_adj_rule, \n    settlement_periodicity=periodicidad_pago,\n    stub_period=periodo_irregular_pago, \n    settlement_calendar=calendario, \n    settlement_lag=1, #lag_pago,\n    fixing_periodicity=periodicidad_fijacion, \n    fixing_stub_period=periodo_irregular_fijacion,\n    fixing_calendar=calendario, \n    fixing_lag=lag_de_fijacion, \n    interest_rate_index=libor_usd_3m,\n    notional_and_amort=custom_notional_amort, \n    amort_is_cashflow=amort_es_flujo, \n    notional_currency=usd, \n    spread=spread, \n    gearing=gearing,\n    settlement_currency=clp, \n    fx_rate_index=usdclp_obs, \n    fx_rate_index_fixing_lag=1\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, ibor_custom_amort_mccy_leg.size()):\n    ibor_mccy_leg.get_cashflow_at(i).set_fx_rate_index_value(10.0)\n    tabla.append(qcf.show(ibor_custom_amort_mccy_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha_fixing', 'fecha__pago',\n            'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo',\n            'moneda_nominal', 'codigo_indice_tasa', 'spread', 'gearing', 'valor_tasa', 'tipo_tasa',\n            'fecha_fijacion_fx', 'moneda_pago', 'codigo_indice_fx', 'valor_indice_fx',\n            'amort_moneda_pago', 'interes_moneda_pago']\ndf6 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf6.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha_fixing fecha__pago nominal amort interes amort_es_flujo flujo moneda_nominal codigo_indice_tasa spread gearing valor_tasa tipo_tasa fecha_fijacion_fx moneda_pago codigo_indice_fx valor_indice_fx amort_moneda_pago interes_moneda_pago 0 1969-01-31 1969-04-30 1969-01-29 1969-05-01 2,000.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1969-04-30 CLP USDOBS 1.00 100.00 0.00 1 1969-04-30 1969-07-31 1969-04-28 1969-08-01 1,900.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1969-07-31 CLP USDOBS 1.00 100.00 0.00 2 1969-07-31 1969-10-31 1969-07-29 1969-11-03 1,800.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1969-10-31 CLP USDOBS 1.00 100.00 0.00 3 1969-10-31 1970-01-30 1969-10-29 1970-02-02 1,700.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1970-01-30 CLP USDOBS 1.00 100.00 0.00 4 1970-01-30 1970-04-30 1970-01-28 1970-05-01 1,600.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1970-04-30 CLP USDOBS 1.00 100.00 0.00 5 1970-04-30 1970-07-31 1970-04-28 1970-08-03 1,500.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1970-07-31 CLP USDOBS 1.00 100.00 0.00 6 1970-07-31 1970-10-30 1970-07-29 1970-11-02 1,400.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1970-10-30 CLP USDOBS 1.00 100.00 0.00 7 1970-10-30 1971-01-29 1970-10-28 1971-02-01 1,300.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1971-01-29 CLP USDOBS 1.00 100.00 0.00 8 1971-01-29 1971-04-30 1971-01-27 1971-05-03 1,200.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1971-04-30 CLP USDOBS 1.00 100.00 0.00 9 1971-04-30 1971-07-30 1971-04-28 1971-08-02 1,100.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1971-07-30 CLP USDOBS 1.00 100.00 0.00 10 1971-07-30 1971-10-29 1971-07-28 1971-11-01 1,000.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1971-10-29 CLP USDOBS 1.00 100.00 0.00 11 1971-10-29 1972-01-31 1971-10-27 1972-02-01 900.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1972-01-31 CLP USDOBS 1.00 100.00 0.00 12 1972-01-31 1972-04-28 1972-01-27 1972-05-01 800.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1972-04-28 CLP USDOBS 1.00 100.00 0.00 13 1972-04-28 1972-07-31 1972-04-26 1972-08-01 700.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1972-07-31 CLP USDOBS 1.00 100.00 0.00 14 1972-07-31 1972-10-31 1972-07-27 1972-11-01 600.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1972-10-31 CLP USDOBS 1.00 100.00 0.00 15 1972-10-31 1973-01-31 1972-10-27 1973-02-01 500.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1973-01-31 CLP USDOBS 1.00 100.00 0.00 16 1973-01-31 1973-04-30 1973-01-29 1973-05-01 400.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1973-04-30 CLP USDOBS 1.00 100.00 0.00 17 1973-04-30 1973-07-31 1973-04-26 1973-08-01 300.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1973-07-31 CLP USDOBS 1.00 100.00 0.00 18 1973-07-31 1973-10-31 1973-07-27 1973-11-01 200.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1973-10-31 CLP USDOBS 1.00 100.00 0.00 19 1973-10-31 1974-01-31 1973-10-29 1974-02-01 100.00 100.00 0.00 True 100.00 USD LIBORUSD3M 1.0000% 1.00 0.0000% LinAct360 1974-01-31 CLP USDOBS 1.00 100.00 0.00"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-overnightindexleg","title":"Construcci\u00f3n Asistida de un <code>OvernightIndexLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>OvernightIndexCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en las fechas iniciales y finales de fijaci\u00f3n del \u00edndice en caso de d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n de \u00edndice</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nocional inicial</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>float</code>: spread aditivo</li> <li><code>float</code>: spread multiplicativo</li> <li><code>QCInterestRate</code>: indica el tipo de tasa equivalente</li> <li><code>string</code>: nombre del \u00edndice overnight</li> <li><code>unsigned int</code>: n\u00famero de decimales a usar en el c\u00e1lculo de la tasa equivalente</li> <li><code>QCCurrency</code>: moneda del nocional</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros anteriores se puede visualizar el efecto de ellos en la construcci\u00f3n. </p> <pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(12, 1, 1968)\nfecha_final = qcf.QCDate(12, 1, 1971) \nbus_adj_rule = qcf.BusyAdjRules.NO\nfix_adj_rule = qcf.BusyAdjRules.PREVIOUS\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 1000000.0\namort_es_flujo = True \nspread = .01\ngearing = 1.0\nrate = qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf())\nindice = 'INDICE'\nnum_decimales = 8\nmoneda = qcf.QCUSD()\n</code></pre> <pre><code>overnight_index_leg = qcf.LegFactory.build_bullet_overnight_index_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    fix_adj_rule=fix_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    fixing_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=rate,\n    index_name=indice,\n    eq_rate_decimal_places=num_decimales,\n    notional_currency=moneda \n)\n</code></pre> <pre><code>c = overnight_index_leg.get_cashflow_at(0)\nc.set_end_date_index(1.1)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, overnight_index_leg.size()):\n    tabla.append(qcf.show(overnight_index_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = qcf.get_column_names(\"OvernightIndexCashflow\", \"\")\ndf7 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf7.style.format(format_dict)\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa_equivalente tipo_tasa interes flujo spread gearing 0 1968-01-12 1968-07-12 1968-01-12 1968-07-12 1968-07-12 1,000,000.00 0.00 True USD INDICE 1.000000 1.100000 19.780220% LinAct360 105,055.56 105,055.56 1.0000% 1.00 1 1968-07-12 1969-01-12 1968-07-12 1969-01-10 1969-01-13 1,000,000.00 0.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 5,111.11 5,111.11 1.0000% 1.00 2 1969-01-12 1969-07-12 1969-01-10 1969-07-11 1969-07-14 1,000,000.00 0.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 5,027.78 5,027.78 1.0000% 1.00 3 1969-07-12 1970-01-12 1969-07-11 1970-01-12 1970-01-12 1,000,000.00 0.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 5,111.11 5,111.11 1.0000% 1.00 4 1970-01-12 1970-07-12 1970-01-12 1970-07-10 1970-07-13 1,000,000.00 0.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 5,027.78 5,027.78 1.0000% 1.00 5 1970-07-12 1971-01-12 1970-07-10 1971-01-12 1971-01-12 1,000,000.00 1,000,000.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 5,111.11 1,005,111.11 1.0000% 1.00 <p>Para construir una pata con amortizaciones hacemos lo siguiente:</p> <pre><code>custom_amort = qcf.CustomNotionalAmort(6)\nfor i in range(6):\n    custom_amort.set_notional_amort_at(i, 600 - i * 100, 100)\n</code></pre> <pre><code>custom_amort_overnight_index_leg = qcf.LegFactory.build_custom_amort_overnight_index_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    fix_adj_rule=fix_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    fixing_calendar=calendario,\n    settlement_lag=lag_pago,\n    notional_and_amort=custom_amort,\n    amort_is_cashflow=amort_es_flujo,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=rate,\n    index_name=indice,\n    eq_rate_decimal_places=num_decimales,\n    notional_currency=moneda \n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, custom_amort_overnight_index_leg.size()):\n    tabla.append(qcf.show(custom_amort_overnight_index_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = qcf.get_column_names(\"OvernightIndexCashflow\", \"\")\ndf7 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf7.style.format(format_dict)\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa_equivalente tipo_tasa interes flujo spread gearing 0 1968-01-12 1968-07-12 1968-01-12 1968-07-12 1968-07-12 600.00 100.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 3.03 103.03 1.0000% 1.00 1 1968-07-12 1969-01-12 1968-07-12 1969-01-10 1969-01-13 500.00 100.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 2.56 102.56 1.0000% 1.00 2 1969-01-12 1969-07-12 1969-01-10 1969-07-11 1969-07-14 400.00 100.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 2.01 102.01 1.0000% 1.00 3 1969-07-12 1970-01-12 1969-07-11 1970-01-12 1970-01-12 300.00 100.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 1.53 101.53 1.0000% 1.00 4 1970-01-12 1970-07-12 1970-01-12 1970-07-10 1970-07-13 200.00 100.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 1.01 101.01 1.0000% 1.00 5 1970-07-12 1971-01-12 1970-07-10 1971-01-12 1971-01-12 100.00 100.00 True USD INDICE 1.000000 1.000000 0.000000% LinAct360 0.51 100.51 1.0000% 1.00"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-overnightindexmulticurrencyleg","title":"Construcci\u00f3n Asistida de un <code>OvernightIndexMultiCurrencyLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>OvernightIndexMultiCurrencyCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en las fechas iniciales y finales de fijaci\u00f3n del \u00edndice en caso de d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de fijaci\u00f3n de \u00edndice</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nocional inicial</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>float</code>: spread aditivo</li> <li><code>float</code>: spread multiplicativo</li> <li><code>QCInterestRate</code>: indica el tipo de tasa equivalente</li> <li><code>string</code>: nombre del \u00edndice overnight</li> <li><code>unsigned int</code>: n\u00famero de decimales a usar en el c\u00e1lculo de la tasa equivalente</li> <li><code>QCCurrency</code>: moneda del nocional</li> <li><code>QCCurrency</code>: moneda de pago</li> <li><code>FXRateIndex</code>: \u00edndice de tipo de cambio</li> <li><code>unsigned int</code>: fx rate index fixing lag</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros siguientes se puede visualizar el efecto de ellos en la construcci\u00f3n. </p> <pre><code>params = dict(\n    rec_pay=qcf.RecPay.RECEIVE,\n    start_date=qcf.QCDate(12, 1, 1968),\n    end_date=qcf.QCDate(12, 1, 1971),\n    bus_adj_rule=qcf.BusyAdjRules.NO,\n    fix_adj_rule=qcf.BusyAdjRules.PREVIOUS,\n    settlement_periodicity=qcf.Tenor('6M'),\n    stub_period=qcf.StubPeriod.NO,\n    settlement_calendar=qcf.BusinessCalendar(fecha_inicio, 20),\n    fixing_calendar=qcf.BusinessCalendar(fecha_inicio, 20),\n    settlement_lag=0,\n    initial_notional=1000000.0,\n    amort_is_cashflow=True,\n    spread=.01,\n    gearing=1.0,\n    interest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    index_name='INDICE',\n    eq_rate_decimal_places=8,\n    notional_currency=qcf.QCUSD(),\n    settlement_currency=qcf.QCCLP(),\n    fx_rate_index=usdclp_obs, # definido m\u00e1s arriba\n    fx_rate_index_fixing_lag=1,\n)\n</code></pre> <pre><code>bullet_overnight_index_mccy_leg = qcf.LegFactory.build_bullet_overnight_index_multi_currency_leg(\n    **params\n)\n</code></pre> <pre><code>tabla = []\nfor i in range(bullet_overnight_index_mccy_leg.size()):\n    tabla.append(qcf.show(bullet_overnight_index_mccy_leg.get_cashflow_at(i)))\ndf_1 = pd.DataFrame(tabla, columns=qcf.get_column_names(\"OvernightIndexMultiCurrencyCashflow\", \"\"))\ndf_1\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice ... flujo spread gearing moneda_pago indice_fx fecha_fijacion_indice_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 1968-01-12 1968-07-12 1968-01-12 1968-07-12 1968-07-12 1000000.0 0.0 True USD INDICE ... 5.055556e+03 0.01 1.0 CLP USDOBS 1968-07-11 1.0 5056.0 0.0 5056.0 1 1968-07-12 1969-01-12 1968-07-12 1969-01-10 1969-01-13 1000000.0 0.0 True USD INDICE ... 5.111111e+03 0.01 1.0 CLP USDOBS 1969-01-10 1.0 5111.0 0.0 5111.0 2 1969-01-12 1969-07-12 1969-01-10 1969-07-11 1969-07-14 1000000.0 0.0 True USD INDICE ... 5.027778e+03 0.01 1.0 CLP USDOBS 1969-07-11 1.0 5028.0 0.0 5028.0 3 1969-07-12 1970-01-12 1969-07-11 1970-01-12 1970-01-12 1000000.0 0.0 True USD INDICE ... 5.111111e+03 0.01 1.0 CLP USDOBS 1970-01-09 1.0 5111.0 0.0 5111.0 4 1970-01-12 1970-07-12 1970-01-12 1970-07-10 1970-07-13 1000000.0 0.0 True USD INDICE ... 5.027778e+03 0.01 1.0 CLP USDOBS 1970-07-10 1.0 5028.0 0.0 5028.0 5 1970-07-12 1971-01-12 1970-07-10 1971-01-12 1971-01-12 1000000.0 1000000.0 True USD INDICE ... 1.005111e+06 0.01 1.0 CLP USDOBS 1971-01-11 1.0 5111.0 1000000.0 1005111.0 <p>6 rows \u00d7 25 columns</p> <p>Veamos ahora el caso Multi Currency.</p> <pre><code>custom_amort = qcf.CustomNotionalAmort(6)\nfor i in range(6):\n    custom_amort.set_notional_amort_at(i, 600 - i * 100, 100)\n</code></pre> <pre><code>params = dict(\n    rec_pay=qcf.RecPay.RECEIVE,\n    start_date=qcf.QCDate(12, 1, 1968),\n    end_date=qcf.QCDate(12, 1, 1971),\n    bus_adj_rule=qcf.BusyAdjRules.NO,\n    fix_adj_rule=qcf.BusyAdjRules.PREVIOUS,\n    settlement_periodicity=qcf.Tenor('6M'),\n    stub_period=qcf.StubPeriod.NO,\n    settlement_calendar=qcf.BusinessCalendar(fecha_inicio, 20),\n    fixing_calendar=qcf.BusinessCalendar(fecha_inicio, 20),\n    settlement_lag=0,\n    notional_and_amort=custom_amort,\n    amort_is_cashflow=True,\n    spread=.01,\n    gearing=1.0,\n    interest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    index_name='INDICE',\n    eq_rate_decimal_places=8,\n    notional_currency=qcf.QCUSD(),\n    settlement_currency=qcf.QCCLP(),\n    fx_rate_index=usdclp_obs, # definido m\u00e1s arriba\n    fx_rate_index_fixing_lag=1,\n)\n</code></pre> <pre><code>custom_overnight_index_mccy_leg = qcf.LegFactory.build_custom_amort_overnight_index_multi_currency_leg(\n    **params\n)\n</code></pre> <pre><code>tabla = []\nfor i in range(custom_overnight_index_mccy_leg.size()):\n    tabla.append(qcf.show(custom_overnight_index_mccy_leg.get_cashflow_at(i)))\ndf_1 = pd.DataFrame(tabla, columns=qcf.get_column_names(\"OvernightIndexMultiCurrencyCashflow\", \"\"))\ndf_1\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice ... flujo spread gearing moneda_pago indice_fx fecha_fijacion_indice_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 1968-01-12 1968-07-12 1968-01-12 1968-07-12 1968-07-12 600.0 100.0 True USD INDICE ... 103.033333 0.01 1.0 CLP USDOBS 1968-07-11 1.0 3.0 100.0 103.0 1 1968-07-12 1969-01-12 1968-07-12 1969-01-10 1969-01-13 500.0 100.0 True USD INDICE ... 102.555556 0.01 1.0 CLP USDOBS 1969-01-10 1.0 3.0 100.0 103.0 2 1969-01-12 1969-07-12 1969-01-10 1969-07-11 1969-07-14 400.0 100.0 True USD INDICE ... 102.011111 0.01 1.0 CLP USDOBS 1969-07-11 1.0 2.0 100.0 102.0 3 1969-07-12 1970-01-12 1969-07-11 1970-01-12 1970-01-12 300.0 100.0 True USD INDICE ... 101.533333 0.01 1.0 CLP USDOBS 1970-01-09 1.0 2.0 100.0 102.0 4 1970-01-12 1970-07-12 1970-01-12 1970-07-10 1970-07-13 200.0 100.0 True USD INDICE ... 101.005556 0.01 1.0 CLP USDOBS 1970-07-10 1.0 1.0 100.0 101.0 5 1970-07-12 1971-01-12 1970-07-10 1971-01-12 1971-01-12 100.0 100.0 True USD INDICE ... 100.511111 0.01 1.0 CLP USDOBS 1971-01-11 1.0 1.0 100.0 101.0 <p>6 rows \u00d7 25 columns</p>"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-icpclpleg","title":"Construcci\u00f3n Asistida de un <code>IcpClpLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>IcpClpCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>float</code>: spread aditivo</li> <li><code>gearing</code>: spread multiplicativo</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros anteriores se puede visualizar el efecto de ellos en la construcci\u00f3n. </p> <p>NOTA: para construir un <code>Leg</code> con <code>IcpClpCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_icp_clp_leg(...)</code>.</p> <pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 1969)\nfecha_final = qcf.QCDate(31, 1, 1974) \nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('3M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 1000000.0\namort_es_flujo = True \nspread = .01\ngearing = 1.0\n\nicp_clp_leg = qcf.LegFactory.build_bullet_icp_clp_leg(\n    rp, \n    fecha_inicio, \n    fecha_final, \n    bus_adj_rule, \n    periodicidad_pago,\n    periodo_irregular_pago, \n    calendario, \n    lag_pago,\n    nominal, \n    amort_es_flujo, \n    spread, \n    gearing\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, icp_clp_leg.size()):\n    tabla.append(qcf.show(icp_clp_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'amort_es_flujo', 'flujo',\n            'moneda', 'icp_inicial', 'icp_final', 'valor_tasa', 'interes', 'spread', 'gearing', 'tipo_tasa']\ndf7 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf7.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort amort_es_flujo flujo moneda icp_inicial icp_final valor_tasa interes spread gearing tipo_tasa 0 1969-01-31 1969-04-30 1969-04-30 1,000,000.00 0.00 True 2,472.22 CLP 10,000.00 10,000.00 0.0000% 2,472.22 1.0000% 1.00 LinAct360 1 1969-04-30 1969-07-31 1969-07-31 1,000,000.00 0.00 True 2,555.56 CLP 10,000.00 10,000.00 0.0000% 2,555.56 1.0000% 1.00 LinAct360 2 1969-07-31 1969-10-31 1969-10-31 1,000,000.00 0.00 True 2,555.56 CLP 10,000.00 10,000.00 0.0000% 2,555.56 1.0000% 1.00 LinAct360 3 1969-10-31 1970-01-30 1970-01-30 1,000,000.00 0.00 True 2,527.78 CLP 10,000.00 10,000.00 0.0000% 2,527.78 1.0000% 1.00 LinAct360 4 1970-01-30 1970-04-30 1970-04-30 1,000,000.00 0.00 True 2,500.00 CLP 10,000.00 10,000.00 0.0000% 2,500.00 1.0000% 1.00 LinAct360 5 1970-04-30 1970-07-31 1970-07-31 1,000,000.00 0.00 True 2,555.56 CLP 10,000.00 10,000.00 0.0000% 2,555.56 1.0000% 1.00 LinAct360 6 1970-07-31 1970-10-30 1970-10-30 1,000,000.00 0.00 True 2,527.78 CLP 10,000.00 10,000.00 0.0000% 2,527.78 1.0000% 1.00 LinAct360 7 1970-10-30 1971-01-29 1971-01-29 1,000,000.00 0.00 True 2,527.78 CLP 10,000.00 10,000.00 0.0000% 2,527.78 1.0000% 1.00 LinAct360 8 1971-01-29 1971-04-30 1971-04-30 1,000,000.00 0.00 True 2,527.78 CLP 10,000.00 10,000.00 0.0000% 2,527.78 1.0000% 1.00 LinAct360 9 1971-04-30 1971-07-30 1971-07-30 1,000,000.00 0.00 True 2,527.78 CLP 10,000.00 10,000.00 0.0000% 2,527.78 1.0000% 1.00 LinAct360 10 1971-07-30 1971-10-29 1971-10-29 1,000,000.00 0.00 True 2,527.78 CLP 10,000.00 10,000.00 0.0000% 2,527.78 1.0000% 1.00 LinAct360 11 1971-10-29 1972-01-31 1972-01-31 1,000,000.00 0.00 True 2,611.11 CLP 10,000.00 10,000.00 0.0000% 2,611.11 1.0000% 1.00 LinAct360 12 1972-01-31 1972-04-28 1972-04-28 1,000,000.00 0.00 True 2,444.44 CLP 10,000.00 10,000.00 0.0000% 2,444.44 1.0000% 1.00 LinAct360 13 1972-04-28 1972-07-31 1972-07-31 1,000,000.00 0.00 True 2,611.11 CLP 10,000.00 10,000.00 0.0000% 2,611.11 1.0000% 1.00 LinAct360 14 1972-07-31 1972-10-31 1972-10-31 1,000,000.00 0.00 True 2,555.56 CLP 10,000.00 10,000.00 0.0000% 2,555.56 1.0000% 1.00 LinAct360 15 1972-10-31 1973-01-31 1973-01-31 1,000,000.00 0.00 True 2,555.56 CLP 10,000.00 10,000.00 0.0000% 2,555.56 1.0000% 1.00 LinAct360 16 1973-01-31 1973-04-30 1973-04-30 1,000,000.00 0.00 True 2,472.22 CLP 10,000.00 10,000.00 0.0000% 2,472.22 1.0000% 1.00 LinAct360 17 1973-04-30 1973-07-31 1973-07-31 1,000,000.00 0.00 True 2,555.56 CLP 10,000.00 10,000.00 0.0000% 2,555.56 1.0000% 1.00 LinAct360 18 1973-07-31 1973-10-31 1973-10-31 1,000,000.00 0.00 True 2,555.56 CLP 10,000.00 10,000.00 0.0000% 2,555.56 1.0000% 1.00 LinAct360 19 1973-10-31 1974-01-31 1974-01-31 1,000,000.00 1,000,000.00 True 1,002,555.56 CLP 10,000.00 10,000.00 0.0000% 2,555.56 1.0000% 1.00 LinAct360"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-icpclp2leg","title":"Construcci\u00f3n Asistida de un <code>IcpClp2Leg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>IcpClpCashflow2</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>float</code>: spread aditivo</li> <li><code>gearing</code>: spread multiplicativo</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros anteriores se puede visualizar el efecto de ellos en la construcci\u00f3n. </p> <p>NOTA: para construir un <code>Leg</code> con <code>IcpClpCashflow2</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_icp_clp2_leg(...)</code>.</p> <pre><code># Se da de alta los par\u00e1metros requeridos\nicp_clp2_leg = qcf.LegFactory.build_bullet_icp_clp2_leg(\n    rp, \n    fecha_inicio:=qcf.QCDate(26, 3, 2019), \n    fecha_final:=qcf.QCDate(26, 3, 2025), \n    bus_adj_rule, \n    periodicidad_pago:=qcf.Tenor(\"6M\"),\n    periodo_irregular_pago, \n    calendario, \n    lag_pago,\n    nominal, \n    amort_es_flujo, \n    spread:=0, \n    gearing, \n    True\n)\n</code></pre> <pre><code>bus_adj_rule\n</code></pre> <pre><code>&lt;BusyAdjRules.MODFOLLOW: 2&gt;\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, icp_clp2_leg.size()):\n    tabla.append(qcf.show(icp_clp2_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'amort_es_flujo', 'flujo',\n            'moneda', 'icp_inicial', 'icp_final', 'valor_tasa', 'interes', 'spread', 'gearing', 'tipo_tasa']\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort amort_es_flujo flujo moneda icp_inicial icp_final valor_tasa interes spread gearing tipo_tasa 0 2019-03-26 2019-09-26 2019-09-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 1 2019-09-26 2020-03-26 2020-03-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 2 2020-03-26 2020-09-28 2020-09-28 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 3 2020-09-28 2021-03-26 2021-03-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 4 2021-03-26 2021-09-27 2021-09-27 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 5 2021-09-27 2022-03-28 2022-03-28 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 6 2022-03-28 2022-09-26 2022-09-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 7 2022-09-26 2023-03-27 2023-03-27 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 8 2023-03-27 2023-09-26 2023-09-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 9 2023-09-26 2024-03-26 2024-03-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 10 2024-03-26 2024-09-26 2024-09-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 11 2024-09-26 2025-03-26 2025-03-26 1,000,000.00 1,000,000.00 True 1,000,000.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 <p>Se puede customizar la amortizaci\u00f3n de la siguiente forma:</p> <pre><code>cna = qcf.CustomNotionalAmort()\ncna.set_size(19)\n</code></pre> <pre><code>cna.set_notional_amort_at(0, 1000000, 0)\nfor i in range(1, icp_clp2_leg.size()):\n    prev_amort = cna.get_amort_at(i - 1)\n    prev_notional = cna.get_notional_at(i - 1)\n    if i == 10 or i == icp_clp2_leg.size() - 1:\n        cna.set_notional_amort_at(i, prev_notional - prev_amort, 500000)\n    else:\n        cna.set_notional_amort_at(i, prev_notional - prev_amort, 0)\n\nfor i in range(icp_clp2_leg.size()):\n    cshflw = icp_clp2_leg.get_cashflow_at(i)\n    cshflw.set_nominal(cna.get_notional_at(i))\n    cshflw.set_amortization(cna.get_amort_at(i))\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, icp_clp2_leg.size()):\n    tabla.append(qcf.show(icp_clp2_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'amort_es_flujo', 'flujo',\n            'moneda', 'icp_inicial', 'icp_final', 'valor_tasa', 'interes', 'spread', 'gearing', 'tipo_tasa']\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort amort_es_flujo flujo moneda icp_inicial icp_final valor_tasa interes spread gearing tipo_tasa 0 2019-03-26 2019-09-26 2019-09-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 1 2019-09-26 2020-03-26 2020-03-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 2 2020-03-26 2020-09-28 2020-09-28 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 3 2020-09-28 2021-03-26 2021-03-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 4 2021-03-26 2021-09-27 2021-09-27 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 5 2021-09-27 2022-03-28 2022-03-28 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 6 2022-03-28 2022-09-26 2022-09-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 7 2022-09-26 2023-03-27 2023-03-27 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 8 2023-03-27 2023-09-26 2023-09-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 9 2023-09-26 2024-03-26 2024-03-26 1,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 10 2024-03-26 2024-09-26 2024-09-26 1,000,000.00 500,000.00 True 500,000.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 11 2024-09-26 2025-03-26 2025-03-26 500,000.00 500,000.00 True 500,000.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-icpclfleg","title":"Construcci\u00f3n Asistida de un <code>IcpClfLeg</code>","text":"<p>En este ejemplo se construye un <code>Leg</code> con <code>IcpClfCashflow</code> y amortizaci\u00f3n bullet. Se requieren los siguientes par\u00e1metros:</p> <ul> <li><code>RecPay</code>: enum que indica si los flujos se reciben o pagan</li> <li><code>QCDate</code>: fecha de inicio del primer flujo</li> <li><code>QCDate</code>: fecha final del \u00faltimo flujo sin considerar ajustes de d\u00edas feriados</li> <li><code>BusyAdRules</code>: enum que representa el tipo de ajuste en la fecha final para d\u00edas feriados</li> <li><code>Tenor</code>: la periodicidad de pago</li> <li><code>QCInterestRateLeg::QCStubPeriod</code>: enum que representa el tipo de per\u00edodo irregular (si aplica)</li> <li><code>QCBusinessCalendar</code>: calendario que aplica para las fechas de pago</li> <li><code>unsigned int</code>: lag de pago expresado en d\u00edas</li> <li><code>float</code>: nominal</li> <li><code>bool</code>: si es <code>True</code> significa que la amortizaci\u00f3n final es un flujo de caja efectivo</li> <li><code>float</code>: spread aditivo</li> <li><code>gearing</code>: spread multiplicativo</li> </ul> <p>Vamos a un ejemplo. Cambiando los par\u00e1metros anteriores se puede visualizar el efecto de ellos en la construcci\u00f3n. </p> <p>NOTA: para construir un <code>Leg</code> con <code>IcpClfCashflow</code> y amortizaci\u00f3n customizada, s\u00f3lo se debe cambiar el par\u00e1metro nominal por CustomNotionalAndAmort e invocar el m\u00e9todo <code>qcf.LegFactory.build_custom_amort_icp_clf_leg(...)</code>.</p> <pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 1, 1969)\nfecha_final = qcf.QCDate(31, 1, 1974)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('3M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 1000000.0\namort_es_flujo = True\nspread = .01\ngearing = 1.0\n\nicp_clf_leg = qcf.LegFactory.build_bullet_icp_clf_leg(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad_pago,\n    periodo_irregular_pago,\n    calendario,\n    lag_pago,\n    nominal,\n    amort_es_flujo,\n    spread,\n    gearing\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, icp_clf_leg.size()):\n    tabla.append(qcf.show(icp_clf_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'amort_es_flujo', 'flujo',\n            'moneda', 'icp_inicial', 'icp_final', 'uf_inicial', 'uf_final',\n            'valor_tasa', 'interes', 'spread', 'gearing', 'tipo_tasa']\ndf8 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf8.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort amort_es_flujo flujo moneda icp_inicial icp_final uf_inicial uf_final valor_tasa interes spread gearing tipo_tasa 0 1969-01-31 1969-04-30 1969-04-30 1,000,000.00 0.00 True 2,472.22 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,472.22 1.0000% 1.00 LinAct360 1 1969-04-30 1969-07-31 1969-07-31 1,000,000.00 0.00 True 2,555.56 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,555.56 1.0000% 1.00 LinAct360 2 1969-07-31 1969-10-31 1969-10-31 1,000,000.00 0.00 True 2,555.56 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,555.56 1.0000% 1.00 LinAct360 3 1969-10-31 1970-01-30 1970-01-30 1,000,000.00 0.00 True 2,527.78 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,527.78 1.0000% 1.00 LinAct360 4 1970-01-30 1970-04-30 1970-04-30 1,000,000.00 0.00 True 2,500.00 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,500.00 1.0000% 1.00 LinAct360 5 1970-04-30 1970-07-31 1970-07-31 1,000,000.00 0.00 True 2,555.56 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,555.56 1.0000% 1.00 LinAct360 6 1970-07-31 1970-10-30 1970-10-30 1,000,000.00 0.00 True 2,527.78 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,527.78 1.0000% 1.00 LinAct360 7 1970-10-30 1971-01-29 1971-01-29 1,000,000.00 0.00 True 2,527.78 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,527.78 1.0000% 1.00 LinAct360 8 1971-01-29 1971-04-30 1971-04-30 1,000,000.00 0.00 True 2,527.78 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,527.78 1.0000% 1.00 LinAct360 9 1971-04-30 1971-07-30 1971-07-30 1,000,000.00 0.00 True 2,527.78 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,527.78 1.0000% 1.00 LinAct360 10 1971-07-30 1971-10-29 1971-10-29 1,000,000.00 0.00 True 2,527.78 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,527.78 1.0000% 1.00 LinAct360 11 1971-10-29 1972-01-31 1972-01-31 1,000,000.00 0.00 True 2,611.11 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,611.11 1.0000% 1.00 LinAct360 12 1972-01-31 1972-04-28 1972-04-28 1,000,000.00 0.00 True 2,444.44 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,444.44 1.0000% 1.00 LinAct360 13 1972-04-28 1972-07-31 1972-07-31 1,000,000.00 0.00 True 2,611.11 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,611.11 1.0000% 1.00 LinAct360 14 1972-07-31 1972-10-31 1972-10-31 1,000,000.00 0.00 True 2,555.56 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,555.56 1.0000% 1.00 LinAct360 15 1972-10-31 1973-01-31 1973-01-31 1,000,000.00 0.00 True 2,555.56 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,555.56 1.0000% 1.00 LinAct360 16 1973-01-31 1973-04-30 1973-04-30 1,000,000.00 0.00 True 2,472.22 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,472.22 1.0000% 1.00 LinAct360 17 1973-04-30 1973-07-31 1973-07-31 1,000,000.00 0.00 True 2,555.56 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,555.56 1.0000% 1.00 LinAct360 18 1973-07-31 1973-10-31 1973-10-31 1,000,000.00 0.00 True 2,555.56 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,555.56 1.0000% 1.00 LinAct360 19 1973-10-31 1974-01-31 1974-01-31 1,000,000.00 1,000,000.00 True 1,002,555.56 CLF 10,000.00 10,000.00 35000.000000 35000.000000 1.0000% 2,555.56 1.0000% 1.00 LinAct360"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-compoundedovernightrateleg","title":"Construcci\u00f3n Asistida de un <code>CompoundedOvernightRateLeg</code>","text":"<pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(3, 1, 2022)\nfecha_final = qcf.QCDate(3, 1, 2023)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('3M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\n\n######################################################################\n# Definici\u00f3n del \u00edndice\n\ncodigo = 'OISTEST'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('0d')\ntenor = qcf.Tenor('1d')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\noistest = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd)\n\n# Fin \u00edndice\n######################################################################\n\nnominal = 1000000.0\namort_es_flujo = True\nmoneda = usd\nspread = .01\ngearing = 1.0\n\ncor_leg = qcf.LegFactory.build_bullet_compounded_overnight_rate_leg(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad_pago,\n    periodo_irregular_pago,\n    calendario,\n    lag_pago,\n    calendario,\n    oistest,\n    nominal,\n    amort_es_flujo,\n    usd,\n    spread,\n    gearing,\n    True,\n    8,\n    0,\n    0\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, cor_leg.size()):\n    tabla.append(qcf.show(cor_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo',\n            'moneda', 'indice', 'valor_tasa', 'spread', 'gearing', 'tipo_tasa']\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort interes amort_es_flujo flujo moneda indice valor_tasa spread gearing tipo_tasa 0 2022-01-03 2022-04-04 2022-04-04 1,000,000.00 0.00 2,527.78 True 2,527.78 USD OISTEST 0.0000% 1.0000% 1.00 LinAct360 1 2022-04-04 2022-07-04 2022-07-04 1,000,000.00 0.00 2,527.78 True 2,527.78 USD OISTEST 0.0000% 1.0000% 1.00 LinAct360 2 2022-07-04 2022-10-03 2022-10-03 1,000,000.00 0.00 2,527.78 True 2,527.78 USD OISTEST 0.0000% 1.0000% 1.00 LinAct360 3 2022-10-03 2023-01-03 2023-01-03 1,000,000.00 1,000,000.00 2,555.56 True 1,002,555.56 USD OISTEST 0.0000% 1.0000% 1.00 LinAct360"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-compoundedovernightrateleg2","title":"Construcci\u00f3n Asistida de un <code>CompoundedOvernightRateLeg2</code>","text":"<pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(3, 1, 2022)\nfecha_final = qcf.QCDate(3, 1, 2023)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('3M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\n\n######################################################################\n# Definici\u00f3n del \u00edndice\n\ncodigo = 'OISTEST'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('0d')\ntenor = qcf.Tenor('1d')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\noistest = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd)\n\n# Fin \u00edndice\n######################################################################\n\nnominal = 1000000.0\namort_es_flujo = True\nmoneda = usd\nspread = .01\ngearing = 1.0\n\ncor_leg_2 = qcf.LegFactory.build_bullet_compounded_overnight_rate_leg_2(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    fixing_calendar=calendario,\n    interest_rate_index=oistest,\n    initial_notional=nominal,\n    cashflow_is_amort=amort_es_flujo,\n    notional_currency=usd,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    eq_rate_decimal_places=8,\n    lookback=0,\n    lockout=0,\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, cor_leg_2.size()):\n    tabla.append(qcf.show(cor_leg_2.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = qcf.get_column_names(\"CompoundedOvernightRateCashflow2\", \"\")\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion interes amort_es_flujo flujo moneda codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2022-01-03 2022-04-04 2022-04-04 1000000.0 0.0 2527.777778 True 2.527778e+03 USD OISTEST LinAct360 0.01 1.0 1.0 1 2022-04-04 2022-07-04 2022-07-04 1000000.0 0.0 2527.777778 True 2.527778e+03 USD OISTEST LinAct360 0.01 1.0 1.0 2 2022-07-04 2022-10-03 2022-10-03 1000000.0 0.0 2527.777778 True 2.527778e+03 USD OISTEST LinAct360 0.01 1.0 1.0 3 2022-10-03 2023-01-03 2023-01-03 1000000.0 1000000.0 2555.555556 True 1.002556e+06 USD OISTEST LinAct360 0.01 1.0 1.0 <p>Para hacer una amortizable:</p> <pre><code>custom_amort = qcf.CustomNotionalAmort(4)\nfor i in range(4):\n    custom_amort.set_notional_amort_at(i, 400 - i * 100, 100)\n</code></pre> <pre><code>amort_cor_leg_2 = qcf.LegFactory.build_custom_amort_compounded_overnight_rate_leg_2(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    fixing_calendar=calendario,\n    interest_rate_index=oistest,\n    notional_and_amort=custom_amort,\n    cashflow_is_amort=amort_es_flujo,\n    notional_currency=usd,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    eq_rate_decimal_places=8,\n    lookback=0,\n    lockout=0,\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, cor_leg.size()):\n    tabla.append(qcf.show(amort_cor_leg_2.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = qcf.get_column_names(\"CompoundedOvernightRateCashflow2\", \"\")\ndf10 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf10\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion interes amort_es_flujo flujo moneda codigo_indice_tasa valor_tasa spread gearing tipo_tasa 0 2022-01-03 2022-04-04 2022-04-04 400.0 100.0 0.002528 True 101.011111 USD OISTEST LinAct360 0.01 1.0 1.0 1 2022-04-04 2022-07-04 2022-07-04 300.0 100.0 0.002528 True 100.758333 USD OISTEST LinAct360 0.01 1.0 1.0 2 2022-07-04 2022-10-03 2022-10-03 200.0 100.0 0.002528 True 100.505556 USD OISTEST LinAct360 0.01 1.0 1.0 3 2022-10-03 2023-01-03 2023-01-03 100.0 100.0 0.002556 True 100.255556 USD OISTEST LinAct360 0.01 1.0 1.0 <p>En <code>qcfinancial</code> falta implementar el MultiCurrency.</p>"},{"location":"Ejemplos_qcfinancial_2/#construccion-asistida-de-un-compoundedovernightratemulticurrencyleg2","title":"Construcci\u00f3n Asistida de un <code>CompoundedOvernightRateMultiCurrencyLeg2</code>","text":"<pre><code>bullet_cor2_mccy_leg = qcf.LegFactory.build_bullet_compounded_overnight_rate_mccy_leg_2(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    fixing_calendar=calendario,\n    interest_rate_index=oistest,\n    initial_notional=1_000_000,\n    cashflow_is_amort=amort_es_flujo,\n    notional_currency=usd,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    eq_rate_decimal_places=8,\n    lookback=0,\n    lockout=0,\n    fx_rate_index_fixing_lag=2,\n    settlement_currency=clp,\n    fx_rate_index=usdclp_obs,\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, bullet_cor2_mccy_leg.size()):\n    tabla.append(qcf.show(bullet_cor2_mccy_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = qcf.get_column_names(\"CompoundedOvernightRateMultiCurrencyCashflow2\", \"\")\ndf11 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf11\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion interes amort_es_flujo flujo moneda codigo_indice_tasa ... spread gearing tipo_tasa moneda_pago fx_rate_index fecha_fixing_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2022-01-03 2022-04-04 2022-04-04 1000000.0 0.0 2527.777778 True 2.527778e+03 USD OISTEST ... 0.01 1.0 0.0 CLP USDOBS 2022-03-31 1.0 2527.777778 0.0 2.527778e+03 1 2022-04-04 2022-07-04 2022-07-04 1000000.0 0.0 2527.777778 True 2.527778e+03 USD OISTEST ... 0.01 1.0 0.0 CLP USDOBS 2022-06-30 1.0 2527.777778 0.0 2.527778e+03 2 2022-07-04 2022-10-03 2022-10-03 1000000.0 0.0 2527.777778 True 2.527778e+03 USD OISTEST ... 0.01 1.0 0.0 CLP USDOBS 2022-09-29 1.0 2527.777778 0.0 2.527778e+03 3 2022-10-03 2023-01-03 2023-01-03 1000000.0 1000000.0 2555.555556 True 1.002556e+06 USD OISTEST ... 0.01 1.0 0.0 CLP USDOBS 2022-12-30 1.0 2555.555556 1000000.0 1.002556e+06 <p>4 rows \u00d7 21 columns</p> <p>Para <code>CustomAmort</code>:</p> <pre><code>custom_amort = qcf.CustomNotionalAmort(4)\nfor i in range(4):\n    custom_amort.set_notional_amort_at(i, 400 - i * 100, 100)\n</code></pre> <pre><code>custom_cor2_mccy_leg = qcf.LegFactory.build_custom_amort_compounded_overnight_rate_multi_currency_leg_2(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    settlement_stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    settlement_lag=lag_pago,\n    fixing_calendar=calendario,\n    interest_rate_index=oistest,\n    notional_and_amort=custom_amort,\n    cashflow_is_amort=amort_es_flujo,\n    notional_currency=usd,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    eq_rate_decimal_places=8,\n    lookback=0,\n    lockout=0,\n    fx_rate_index_fixing_lag=2,\n    settlement_currency=clp,\n    fx_rate_index=usdclp_obs,\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, custom_cor2_mccy_leg.size()):\n    tabla.append(qcf.show(custom_cor2_mccy_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = qcf.get_column_names(\"CompoundedOvernightRateMultiCurrencyCashflow2\", \"\")\ndf12 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf12\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion interes amort_es_flujo flujo moneda codigo_indice_tasa ... spread gearing tipo_tasa moneda_pago fx_rate_index fecha_fixing_fx valor_indice_fx interes_moneda_pago amortizacion_moneda_pago flujo_moneda_pago 0 2022-01-03 2022-04-04 2022-04-04 400.0 100.0 0.002528 True 101.011111 USD OISTEST ... 0.01 1.0 0.0 CLP USDOBS 2022-03-31 1.0 0.002528 100.0 100.002528 1 2022-04-04 2022-07-04 2022-07-04 300.0 100.0 0.002528 True 100.758333 USD OISTEST ... 0.01 1.0 0.0 CLP USDOBS 2022-06-30 1.0 0.002528 100.0 100.002528 2 2022-07-04 2022-10-03 2022-10-03 200.0 100.0 0.002528 True 100.505556 USD OISTEST ... 0.01 1.0 0.0 CLP USDOBS 2022-09-29 1.0 0.002528 100.0 100.002528 3 2022-10-03 2023-01-03 2023-01-03 100.0 100.0 0.002556 True 100.255556 USD OISTEST ... 0.01 1.0 0.0 CLP USDOBS 2022-12-30 1.0 0.002556 100.0 100.002556 <p>4 rows \u00d7 21 columns</p>"},{"location":"Ejemplos_qcfinancial_3/","title":"Valorizaci\u00f3n y Sensibilidad","text":""},{"location":"Ejemplos_qcfinancial_3/#configuracion","title":"Configuraci\u00f3n","text":"<p>Para ejecutar todos los ejemplos se debe importar la librer\u00eda. Se sugiere utilizar siempre el alias <code>qcf</code>. </p> <pre><code>import qcfinancial as qcf\n</code></pre> <p>Librer\u00edas adicionales.</p> <pre><code>import pandas as pd\n</code></pre> <p>Para formateo de <code>pandas.DataFrames</code>.</p> <pre><code>format_dict = {\n    'nominal': '{0:,.2f}',\n    'amort': '{0:,.2f}',\n    'interes': '{0:,.2f}',\n    'flujo': '{0:,.2f}',\n    'amortizacion': '{0:,.2f}',\n    'icp_inicial': '{0:,.2f}',\n    'icp_final': '{0:,.2f}',\n    'uf_inicial': '{0:,.2f}',\n    'uf_final': '{0:,.2f}',\n    'valor_tasa': '{0:,.4%}',\n    'spread': '{0:,.4%}',\n    'gearing': '{0:,.2f}',\n    'amort_moneda_pago': '{0:,.2f}',\n    'interes_moneda_pago': '{0:,.2f}',\n    'valor_indice_fx': '{0:,.2f}'\n}\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#construccion-de-la-curva","title":"Construcci\u00f3n de la Curva","text":"<p>La construcci\u00f3n de una curva se hace en varios pasos.</p>"},{"location":"Ejemplos_qcfinancial_3/#vectores-de-float-e-int","title":"Vectores de <code>Float</code> e <code>Int</code>","text":"<pre><code># Este es un vector de n\u00fameros enteros (grandes, de ah\u00ed la l (long))\nlvec = qcf.long_vec()\n</code></pre> <pre><code># Agregar un elemento\nlvec.append(1000)\n</code></pre> <pre><code># Este es un vector de n\u00fameros double.\nvec = qcf.double_vec()\n</code></pre> <pre><code># Agregar un elemento\nvec.append(.025)\n</code></pre> <pre><code># Obtener ese elemento\nprint(\"Tasa: {0:,.2%}\".format(vec[0]))\n</code></pre> <pre><code>Tasa: 2.50%\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#objeto-curva","title":"Objeto Curva","text":"<p>Es simplemente un <code>long_vec</code> que representa las abscisas de la curva y un <code>double_vec</code> que representa las ordenadas. Ambos vectores deben tener el mismo largo. </p> <pre><code>zcc = qcf.QCCurve(lvec, vec)\n</code></pre> <p>Un elemento de una curva se representa como un par abscisa, ordenada.</p> <pre><code>zcc.get_values_at(0)\n</code></pre> <pre><code>(1000, 0.025)\n</code></pre> <p>Se obtiene el plazo en una posici\u00f3n de la curva.</p> <pre><code>print(zcc.get_values_at(0))\n</code></pre> <pre><code>(1000, 0.025)\n</code></pre> <p>Se obtiene la tasa en una posici\u00f3n de la curva.</p> <pre><code>zcc.get_values_at(0)[1]\n</code></pre> <pre><code>0.025\n</code></pre> <p>Se agrega un par (plazo, valor) a la curva.</p> <pre><code>zcc.set_pair(100, .026)\n</code></pre> <p>Se verifica.</p> <pre><code># Plazo\nzcc.get_values_at(1)[0]\n</code></pre> <pre><code>1000\n</code></pre> <pre><code># Valor\nzcc.get_values_at(1)[1]\n</code></pre> <pre><code>0.025\n</code></pre> <p>Se agrega un par m\u00e1s.</p> <pre><code>zcc.set_pair(370, .03)\n</code></pre> <p>Se itera sobre la curva mostrando sus valores</p> <pre><code>for i in range(0, zcc.get_length()):\n    pair = zcc.get_values_at(i)\n    print(\"Tenor: {0:} Valor: {1:.4%}\".format(pair[0], pair[1]))\n</code></pre> <pre><code>Tenor: 100 Valor: 2.6000%\nTenor: 370 Valor: 3.0000%\nTenor: 1000 Valor: 2.5000%\n</code></pre> <p>Se define un interpolador. En este caso, un interpolador lineal.</p> <pre><code>lin = qcf.QCLinearInterpolator(zcc)\n</code></pre> <p>Se hace una prueba.</p> <pre><code>plazo = 120\nprint(f\"Tasa a {plazo:.0f} d\u00edas es igual a {lin.interpolate_at(plazo):.4%}\")\n</code></pre> <pre><code>Tasa a 120 d\u00edas es igual a 2.6296%\n</code></pre> <p>Para completar el proceso se define una fracci\u00f3n de a\u00f1o, un factor de capitalizaci\u00f3n y un tipo de tasa. Con estos objetos se termina de dar de alta una curva cero.</p> <pre><code>yf = qcf.QCAct360()\nwf = qcf.QCLinearWf()\ntasa = qcf.QCInterestRate(.01, yf, wf)\n</code></pre> <pre><code>zz = qcf.ZeroCouponCurve(lin, tasa)\n</code></pre> <p>El interpolador permite obtener una tasa a cualquier plazo.</p> <pre><code>plazo = 365\nprint(\"Tasa en {0:} es igual a {1:.4%}\".format(plazo, zz.get_rate_at(plazo)))\n</code></pre> <pre><code>Tasa en 365 es igual a 2.9926%\n</code></pre> <pre><code>type(zz)\n</code></pre> <pre><code>qcfinancial.ZeroCouponCurve\n</code></pre> <pre><code>zz.get_discount_factor_at(1)\n</code></pre> <pre><code>0.9999277829934504\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#otros-metodos","title":"Otros m\u00e9todos:","text":"<p>Tasa Forward</p> <pre><code>d1 = 30\nd2 = 90\nprint(\"Tasa forward entre los d\u00edas {0:} y {1:}: {2:.4%}\".format(\n    d1, d2, zz.get_forward_rate(d1, d2)))\n</code></pre> <pre><code>Tasa forward entre los d\u00edas 30 y 90: 2.5944%\n</code></pre> <p>Derivada del factor de capitalizaci\u00f3n de la Tasa Forward. El argumento representa el \u00edndice de la tasa de la curva.</p> <pre><code>zz.fwd_wf_derivative_at(0)\n</code></pre> <pre><code>0.1659467849041197\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#valorizar","title":"Valorizar","text":"<p>Se da de alta un objeto <code>PresentValue</code>.</p> <pre><code>pv = qcf.PresentValue()\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#deposito-a-plazo","title":"Dep\u00f3sito a Plazo","text":"<p>Se utilizar\u00e1 como instrumento un dep\u00f3sito a plazo en CLP o USD. Este instrumento se modela como un <code>SimpleCashflow</code>. Este, a su vez se construye con un monto, una fecha y una moneda.</p> <pre><code># Con estas variables vamos a construir\nfecha_vcto = qcf.QCDate(12, 1, 2021)\nmonto = 10_000_000.0\nclp = qcf.QCCLP()\n\n# Se construye el dep\u00f3sito\ndepo = qcf.SimpleCashflow(fecha_vcto, monto, clp)\n</code></pre> <pre><code>print(\"Monto del dep\u00f3sito: {0:,.0f}\".format(depo.amount()))\n</code></pre> <pre><code>Monto del dep\u00f3sito: 10,000,000\n</code></pre> <p>Se define una fecha de valorizaci\u00f3n y se calcula el valor presente del depo.</p> <pre><code>fecha_hoy = qcf.QCDate(17, 1, 2020)\nprint(\"Valor presente depo: {0:,.2f}\".format(pv.pv(fecha_hoy, depo, zz)))\n</code></pre> <pre><code>Valor presente depo: 9,709,212.68\n</code></pre> <p>Se verifica a mano el resultado.</p> <pre><code>plazo = fecha_hoy.day_diff(fecha_vcto)\nprint(\"Plazo:\", plazo)\n</code></pre> <pre><code>Plazo: 361\n</code></pre> <pre><code>tasa_int = zz.get_rate_at(plazo)\nprint(\"Tasa: {0:,.4%}\".format(tasa_int))\n</code></pre> <pre><code>Tasa: 2.9867%\n</code></pre> <pre><code>valor_presente = monto / (1 + tasa_int * plazo / 360)\nprint(\"Valor presente a mano: {0:,.2f}\".format(valor_presente))\n</code></pre> <pre><code>Valor presente a mano: 9,709,212.68\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#renta-fija-local","title":"Renta Fija Local","text":"<p>Se muestra el ejemplo de valorizaci\u00f3n de un bono bullet a tasa fija con las convenciones de la Bolsa de Comercio. Para el ejemplo usamos las caracter\u00edsticas del BTU0150326.</p> <p>Se dan de alta los par\u00e1metros requeridos para instanciar un objeto de tipo <code>FixedRateLeg</code>.</p> <pre><code>rp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(1, 3, 2015)\nfecha_final = qcf.QCDate(1, 3, 2026)\nbus_adj_rule = qcf.BusyAdjRules.NO\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 100.0\namort_es_flujo = True\nvalor_tasa_fija = .015\ntasa_cupon = qcf.QCInterestRate(\n    valor_tasa_fija, \n    qcf.QC30360(),\n    qcf.QCLinearWf()\n)\nmoneda = qcf.QCCLP()\nes_bono = True\n\n# Se da de alta el objeto\npata_bono = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad,\n    periodo_irregular,\n    calendario,\n    lag_pago,\n    nominal,\n    amort_es_flujo,\n    tasa_cupon,\n    moneda,\n    es_bono\n)\n</code></pre> <p>Se da de alta el valor de la TERA y luego se construye un objeto de tipo <code>ChileanFixedRateBond</code>.</p> <pre><code>tera = qcf.QCInterestRate(.015044, qcf.QCAct365(), qcf.QCCompoundWf())\nbono_chileno = qcf.ChileanFixedRateBond(pata_bono, tera)\n</code></pre> <p>Se valoriza al 2021-09-28 a una TIR de mercado del 1.61%.</p> <pre><code>fecha_valor = qcf.QCDate(28, 9, 2021)\ntir = qcf.QCInterestRate(.0161, qcf.QCAct365(), qcf.QCCompoundWf())\n\nvalor_presente = bono_chileno.present_value(fecha_valor, tir)\nprecio = bono_chileno.precio(fecha_valor, tir)\nvalor_par = bono_chileno.valor_par(fecha_valor)\n\nprint(f'Valor presente: {valor_presente:,.8f}')\nprint(f'Precio: {precio:,.2%}')\nprint(f'Valor par: {valor_par:,.18f}')\n</code></pre> <pre><code>Valor presente: 99.67188455\nPrecio: 99.56%\nValor par: 100.110516628864033351\n</code></pre> <p>Con esto el valor a pagar es:</p> <pre><code>valor_uf = 30_080.37\nvalor_pago = precio * valor_par * valor_uf\nprint(f'Valor a pagar: {valor_pago:,.0f}')\n</code></pre> <pre><code>Valor a pagar: 2,998,111\n</code></pre> <p>Con 4 decimales en el precio (4 decimales porcentuales, 6 decimales en el n\u00famero):</p> <pre><code>precio2 = bono_chileno.precio2(fecha_valor, tir, 6)\nprint(f'Precio a 4 decmales: {precio2:.4%}')\n</code></pre> <pre><code>Precio a 4 decmales: 99.5619%\n</code></pre> <p>La funci\u00f3n <code>precio2</code> entrega el mismo resultado que la funci\u00f3n precio cuando se utiliza con 2 decimales porcentuales.</p> <pre><code>precio22 = bono_chileno.precio2(fecha_valor, tir, 4)\nprint(f'Precio a 4 decmales: {precio22:.4%}')\n</code></pre> <pre><code>Precio a 4 decmales: 99.5600%\n</code></pre> <p>Se muestran las diferencias con la convenci\u00f3n de precio usual en mercados desarrollados.</p> <pre><code>bono = qcf.FixedRateBond(pata_bono)\nprint(f'Valor presente: {bono.present_value(fecha_valor, tir):,.8f}')\nprint(f'Precio: {bono.price(fecha_valor, tir):,.8f}')\n</code></pre> <pre><code>Valor presente: 99.67188455\nPrecio: 99.55938455\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#curvas-reales","title":"Curvas Reales","text":"<p>Construyamos dos curvas a partir de data real. Primero la curva CAMARACLP.</p> <pre><code>curva = pd.read_excel(\"./input/curva_clp.xlsx\")\ncurva\n</code></pre> curva fecha plazo tasa 0 CAMARACLP 2020-03-05 1 0.017500 1 CAMARACLP 2020-03-05 4 0.017501 2 CAMARACLP 2020-03-05 96 0.014867 3 CAMARACLP 2020-03-05 188 0.013049 4 CAMARACLP 2020-03-05 279 0.012870 5 CAMARACLP 2020-03-05 369 0.013002 6 CAMARACLP 2020-03-05 553 0.013035 7 CAMARACLP 2020-03-05 734 0.012951 8 CAMARACLP 2020-03-05 1099 0.014440 9 CAMARACLP 2020-03-05 1465 0.016736 10 CAMARACLP 2020-03-05 1830 0.019860 11 CAMARACLP 2020-03-05 2195 0.022766 12 CAMARACLP 2020-03-05 2560 0.025812 13 CAMARACLP 2020-03-05 2926 0.028216 14 CAMARACLP 2020-03-05 3291 0.030373 15 CAMARACLP 2020-03-05 3656 0.032154 16 CAMARACLP 2020-03-05 4387 0.034525 17 CAMARACLP 2020-03-05 5482 0.037636 18 CAMARACLP 2020-03-05 7309 0.041641 <p>Se da de alta un vector con los plazos (variable de tipo <code>long</code>) y un vector con las tasas (variable de tipo <code>double</code>).</p> <pre><code>lvec1 = qcf.long_vec()\nvec1 = qcf.double_vec()\nfor index, row in curva.iterrows():\n    lvec1.append(int(row['plazo']))\n    vec1.append(row['tasa'])\n</code></pre> <p>Luego, con una curva, un interpolador y un objeto <code>QCInterestRate</code>(que indica la convenci\u00f3n de las tasas de la curva) se construye una curva cup\u00f3n cero.</p> <pre><code>zcc1 = qcf.QCCurve(lvec1, vec1)\nlin1 = qcf.QCLinearInterpolator(zcc1)\nzz1 = qcf.ZeroCouponCurve(lin1, tasa)\n</code></pre> <p>Luego, la curva LIBORUSD3M.</p> <pre><code>curva_libor = pd.read_excel(\"./input/curva_usd.xlsx\")\ncurva_libor.style.format({\"tasa\": \"{0:,.4%}\"})\n</code></pre> curva fecha plazo tasa 0 LIBORUSD3MBBG 2020-01-22 00:00:00 3 1.5362% 1 LIBORUSD3MBBG 2020-01-22 00:00:00 4 1.1521% 2 LIBORUSD3MBBG 2020-01-22 00:00:00 7 1.5536% 3 LIBORUSD3MBBG 2020-01-22 00:00:00 14 1.5850% 4 LIBORUSD3MBBG 2020-01-22 00:00:00 31 1.6595% 5 LIBORUSD3MBBG 2020-01-22 00:00:00 60 1.7698% 6 LIBORUSD3MBBG 2020-01-22 00:00:00 91 1.8010% 7 LIBORUSD3MBBG 2020-01-22 00:00:00 123 1.7711% 8 LIBORUSD3MBBG 2020-01-22 00:00:00 152 1.7542% 9 LIBORUSD3MBBG 2020-01-22 00:00:00 182 1.7394% 10 LIBORUSD3MBBG 2020-01-22 00:00:00 213 1.7288% 11 LIBORUSD3MBBG 2020-01-22 00:00:00 244 1.7183% 12 LIBORUSD3MBBG 2020-01-22 00:00:00 276 1.7027% 13 LIBORUSD3MBBG 2020-01-22 00:00:00 305 1.6917% 14 LIBORUSD3MBBG 2020-01-22 00:00:00 335 1.6820% 15 LIBORUSD3MBBG 2020-01-22 00:00:00 367 1.6722% 16 LIBORUSD3MBBG 2020-01-22 00:00:00 549 1.6207% 17 LIBORUSD3MBBG 2020-01-22 00:00:00 731 1.5947% 18 LIBORUSD3MBBG 2020-01-22 00:00:00 1096 1.5788% 19 LIBORUSD3MBBG 2020-01-22 00:00:00 1461 1.5906% 20 LIBORUSD3MBBG 2020-01-22 00:00:00 1827 1.6190% 21 LIBORUSD3MBBG 2020-01-22 00:00:00 2558 1.7028% 22 LIBORUSD3MBBG 2020-01-22 00:00:00 3653 1.8533% 23 LIBORUSD3MBBG 2020-01-22 00:00:00 4385 1.9547% 24 LIBORUSD3MBBG 2020-01-22 00:00:00 5479 2.0893% 25 LIBORUSD3MBBG 2020-01-22 00:00:00 7305 2.2831% 26 LIBORUSD3MBBG 2020-01-22 00:00:00 9132 2.4306% 27 LIBORUSD3MBBG 2020-01-22 00:00:00 10958 2.5576% <pre><code>lvec2 = qcf.long_vec()\nvec2 = qcf.double_vec()\nfor index, row in curva_libor.iterrows():\n    lvec2.append(int(row['plazo']))\n    vec2.append(row['tasa'])\n\nzcc2 = qcf.QCCurve(lvec2, vec2)\nlin2 = qcf.QCLinearInterpolator(zcc2)\nzz2 = qcf.ZeroCouponCurve(lin2, tasa)\n</code></pre> <p>Finalmente, la curva CAMARACLF.</p> <pre><code>curva_camara_clf = pd.read_excel(\"./input/curva_clf.xlsx\")\ncurva_camara_clf.style.format({\"tasa\": \"{0:,.4%}\"})\n</code></pre> curva fecha plazo tasa 0 CAMARACLF 2020-03-05 00:00:00 1 -5.6780% 1 CAMARACLF 2020-03-05 00:00:00 4 -5.6744% 2 CAMARACLF 2020-03-05 00:00:00 35 -0.9340% 3 CAMARACLF 2020-03-05 00:00:00 64 -2.1183% 4 CAMARACLF 2020-03-05 00:00:00 96 -2.0079% 5 CAMARACLF 2020-03-05 00:00:00 126 -2.0762% 6 CAMARACLF 2020-03-05 00:00:00 155 -1.9197% 7 CAMARACLF 2020-03-05 00:00:00 188 -1.9347% 8 CAMARACLF 2020-03-05 00:00:00 218 -1.7626% 9 CAMARACLF 2020-03-05 00:00:00 249 -1.7987% 10 CAMARACLF 2020-03-05 00:00:00 279 -1.9335% 11 CAMARACLF 2020-03-05 00:00:00 309 -1.8159% 12 CAMARACLF 2020-03-05 00:00:00 341 -1.5940% 13 CAMARACLF 2020-03-05 00:00:00 369 -1.5994% 14 CAMARACLF 2020-03-05 00:00:00 400 -1.5068% 15 CAMARACLF 2020-03-05 00:00:00 428 -1.6115% 16 CAMARACLF 2020-03-05 00:00:00 461 -1.5923% 17 CAMARACLF 2020-03-05 00:00:00 491 -1.5780% 18 CAMARACLF 2020-03-05 00:00:00 522 -1.5186% 19 CAMARACLF 2020-03-05 00:00:00 553 -1.5533% 20 CAMARACLF 2020-03-05 00:00:00 582 -1.5649% 21 CAMARACLF 2020-03-05 00:00:00 734 -1.6594% 22 CAMARACLF 2020-03-05 00:00:00 1099 -1.4881% 23 CAMARACLF 2020-03-05 00:00:00 1465 -1.2740% 24 CAMARACLF 2020-03-05 00:00:00 1830 -1.0201% 25 CAMARACLF 2020-03-05 00:00:00 2195 -0.8009% 26 CAMARACLF 2020-03-05 00:00:00 2560 -0.5868% 27 CAMARACLF 2020-03-05 00:00:00 2926 -0.4145% 28 CAMARACLF 2020-03-05 00:00:00 3291 -0.3047% 29 CAMARACLF 2020-03-05 00:00:00 3656 -0.2242% 30 CAMARACLF 2020-03-05 00:00:00 4387 -0.1871% 31 CAMARACLF 2020-03-05 00:00:00 5482 -0.1056% 32 CAMARACLF 2020-03-05 00:00:00 7309 -0.0639% <pre><code>lvec3 = qcf.long_vec()\nvec3 = qcf.double_vec()\nfor index, row in curva_camara_clf.iterrows():\n    lvec3.append(int(row['plazo']))\n    vec3.append(row['tasa'])\n\nzcc3 = qcf.QCCurve(lvec3, vec3)\nlin3 = qcf.QCLinearInterpolator(zcc3)\nzz3 = qcf.ZeroCouponCurve(lin3, tasa)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#curvas-para-sensibilidad","title":"Curvas para Sensibilidad","text":"<p>Se define que v\u00e9rtice de la curva se quiere desplazar.</p> <pre><code>vertice = 13\n</code></pre> <p>Se construyen las curvas con ese v\u00e9rtice 1 punto b\u00e1sico m\u00e1s arriba y 1 punto b\u00e1sico m\u00e1s abajo.</p> <pre><code>bp = .0001\nvec_sens_up = qcf.double_vec()\nvec_sens_down = qcf.double_vec()\nfor index, row in curva.iterrows():\n    if index == vertice:\n        vec_sens_up.append(row['tasa'] + bp)\n        vec_sens_down.append(row['tasa'] - bp)\n    else:\n        vec_sens_up.append(row['tasa'])\n        vec_sens_down.append(row['tasa'])\n\nzcc_sens_up = qcf.QCCurve(lvec1, vec_sens_up)\nlin_sens_up = qcf.QCLinearInterpolator(zcc_sens_up)\nzz_sens_up = qcf.ZeroCouponCurve(lin_sens_up, tasa)\n\nzcc_sens_down = qcf.QCCurve(lvec1, vec_sens_down)\nlin_sens_down = qcf.QCLinearInterpolator(zcc_sens_down)\nzz_sens_down = qcf.ZeroCouponCurve(lin_sens_down, tasa)\n</code></pre> <pre><code>vec2_sens_up = qcf.double_vec()\nvec2_sens_down = qcf.double_vec()\nfor index, row in curva_libor.iterrows():\n    if index == vertice:\n        vec2_sens_up.append(row['tasa'] + bp)\n        vec2_sens_down.append(row['tasa'] - bp)\n    else:\n        vec2_sens_up.append(row['tasa'])\n        vec2_sens_down.append(row['tasa'])\n\nzcc2_sens_up = qcf.QCCurve(lvec2, vec2_sens_up)\nlin2_sens_up = qcf.QCLinearInterpolator(zcc2_sens_up)\nzz2_sens_up = qcf.ZeroCouponCurve(lin2_sens_up, tasa)\n\nzcc2_sens_down = qcf.QCCurve(lvec2, vec2_sens_down)\nlin2_sens_down = qcf.QCLinearInterpolator(zcc2_sens_down)\nzz2_sens_down = qcf.ZeroCouponCurve(lin2_sens_down, tasa)\n</code></pre> <pre><code>vec3_sens_up = qcf.double_vec()\nvec3_sens_down = qcf.double_vec()\nfor index, row in curva_camara_clf.iterrows():\n    if index == vertice:\n        vec3_sens_up.append(row['tasa'] + bp)\n        vec3_sens_down.append(row['tasa'] - bp)\n    else:\n        vec3_sens_up.append(row['tasa'])\n        vec3_sens_down.append(row['tasa'])\n\nzcc3_sens_up = qcf.QCCurve(lvec3, vec3_sens_up)\nlin3_sens_up = qcf.QCLinearInterpolator(zcc3_sens_up)\nzz3_sens_up = qcf.ZeroCouponCurve(lin3_sens_up, tasa)\n\nzcc3_sens_down = qcf.QCCurve(lvec3, vec3_sens_down)\nlin3_sens_down = qcf.QCLinearInterpolator(zcc3_sens_down)\nzz3_sens_down = qcf.ZeroCouponCurve(lin3_sens_down, tasa)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#fixedratecashflow-leg","title":"FixedRateCashflow Leg","text":"<p>Se da de alta una pata fija:</p> <pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(12, 11, 2019)\nfecha_final = qcf.QCDate(12, 11, 2020)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad = qcf.Tenor('6M')\nperiodo_irregular = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 20_000_000.0\namort_es_flujo = True\nvalor_tasa_fija = .01774\ntasa_cupon = qcf.QCInterestRate(\n    valor_tasa_fija, \n    qcf.QC30360(), \n    qcf.QCLinearWf()\n)\nmoneda = qcf.QCUSD()\nes_bono = False\n\n# Se da de alta el objeto\nfixed_rate_leg = qcf.LegFactory.build_bullet_fixed_rate_leg(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad,\n    periodo_irregular,\n    calendario,\n    lag_pago,\n    nominal,\n    amort_es_flujo,\n    tasa_cupon,\n    moneda,\n    es_bono\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, fixed_rate_leg.size()):\n    tabla.append(qcf.show(fixed_rate_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = list(qcf.get_column_names(\"FixedRateCashflow\", \"\"))\ndf = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf.style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion interes amort_es_flujo flujo moneda valor_tasa tipo_tasa 0 2019-11-12 2020-05-12 2020-05-12 20,000,000.00 0.00 177,400.00 True 177,400.00 USD 1.7740% Lin30360 1 2020-05-12 2020-11-12 2020-11-12 20,000,000.00 20,000,000.00 177,400.00 True 20,177,400.00 USD 1.7740% Lin30360 <p>Se calcula ahora el valor presente:</p> <pre><code>vp_fija = pv.pv(fecha_hoy, fixed_rate_leg, zz2)\nprint(\"Valor presente de la pata fija es: {0:,.0f}\".format(vp_fija))\n</code></pre> <pre><code>Valor presente de la pata fija es: 20,072,981\n</code></pre> <p>Al calcular el valor presente, tambi\u00e9n se calculan las derivadas del valor presente respecto a cada uno de los v\u00e9rtices de la curva.</p> <pre><code>der = pv.get_derivatives()\n</code></pre> <p>Con esas derivadas, se puede calcular la sensibilidad a la curva cup\u00f3n cero a un movimiento de 1 punto b\u00e1sico.</p> <pre><code>i = 0\nbp = .0001\ntotal = 0\nfor d in der:\n    total += d * bp\n    print(\"Sensibilidad en {0:}: {1:0,.0f}\".format(i, d * bp))\n    i += 1\nprint(\"Sensibilidad total: {0:,.0f}\".format(total))\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: 0\nSensibilidad en 3: 0\nSensibilidad en 4: 0\nSensibilidad en 5: 0\nSensibilidad en 6: -1\nSensibilidad en 7: -4\nSensibilidad en 8: 0\nSensibilidad en 9: 0\nSensibilidad en 10: 0\nSensibilidad en 11: 0\nSensibilidad en 12: -282\nSensibilidad en 13: -1,353\nSensibilidad en 14: 0\nSensibilidad en 15: 0\nSensibilidad en 16: 0\nSensibilidad en 17: 0\nSensibilidad en 18: 0\nSensibilidad en 19: 0\nSensibilidad en 20: 0\nSensibilidad en 21: 0\nSensibilidad en 22: 0\nSensibilidad en 23: 0\nSensibilidad en 24: 0\nSensibilidad en 25: 0\nSensibilidad en 26: 0\nSensibilidad en 27: 0\nSensibilidad total: -1,641\n</code></pre> <p>Se puede verificar la sensibilidad por diferencias finitas.</p> <p>Se calcula el valor presente con las curvas desplazadas.</p> <pre><code>vp_fija_sens_up = pv.pv(fecha_hoy, fixed_rate_leg, zz2_sens_up)\nvp_fija_sens_down = pv.pv(fecha_hoy, fixed_rate_leg, zz2_sens_down)\nprint(\"Valor presente up de la pata fija es: {0:,.0f}\".format(vp_fija_sens_up))\nprint(\"Valor presente down de la pata fija es: {0:,.0f}\".format(\n    vp_fija_sens_down))\n</code></pre> <pre><code>Valor presente up de la pata fija es: 20,071,628\nValor presente down de la pata fija es: 20,074,334\n</code></pre> <p>Finalmente, se calcula la sensibilidad (usando la aproximaci\u00f3n central por diferencias finitas).</p> <pre><code>print(\"Sensibilidad por diferencias finitas: {0:,.0f}\".format(\n    (vp_fija_sens_up - vp_fija_sens_down) / 2))\n</code></pre> <pre><code>Sensibilidad por diferencias finitas: -1,353\n</code></pre> <p>Tanto el VP como la sensibilidad coinciden con lo que muestra FD en la pata fija de la operaci\u00f3n 2879.</p>"},{"location":"Ejemplos_qcfinancial_3/#icpclpcashflow2-leg","title":"IcpClpCashflow2 Leg","text":"<pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(10,1,2019)\nfecha_final = qcf.QCDate(10,7,2029)\nbus_adj_rule = qcf.BusyAdjRules.FOLLOW\nperiodicidad_pago = qcf.Tenor('2Y')\nperiodo_irregular_pago = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 38_000_000_000.0\namort_es_flujo = True\nspread = .0\ngearing = 1.0\n\nicp_clp2_leg = qcf.LegFactory.build_bullet_icp_clp2_leg(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad_pago,\n    periodo_irregular_pago,\n    calendario,\n    lag_pago,\n    nominal,\n    amort_es_flujo,\n    spread,\n    gearing,\n    True\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, icp_clp2_leg.size()):\n    tabla.append(qcf.show(icp_clp2_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = list(qcf.get_column_names(\"IcpClpCashflow2\", \"\"))\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9.style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion amort_es_flujo flujo moneda icp_inicial icp_final valor_tasa interes spread gearing tipo_tasa 0 2019-01-10 2019-07-10 2019-07-10 38,000,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 1 2019-07-10 2021-07-12 2021-07-12 38,000,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 2 2021-07-12 2023-07-10 2023-07-10 38,000,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 3 2023-07-10 2025-07-10 2025-07-10 38,000,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 4 2025-07-10 2027-07-12 2027-07-12 38,000,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 5 2027-07-12 2029-07-10 2029-07-10 38,000,000,000.00 38,000,000,000.00 True 38,000,000,000.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 <p>Notar que al dar de alta un Leg con IcpClpCashflow2, los valores futuros de los ICP son los default (=10,000.00). Por lo tanto, el primer paso para valorizar estos cashflows, es calcular los valores forward de los \u00edndices.</p> <p>Se comienza dando de alta un objeto de tipo <code>ForwardRates</code>.</p> <pre><code>fwd_rates = qcf.ForwardRates()\n</code></pre> <p>Se calculan los \u00edndices forward.</p> <pre><code>icp_val = 18_890.34 # icp a la fecha de proceso\nfecha_hoy = qcf.QCDate(5, 3, 2020)\n\nfor i in range(icp_clp2_leg.size()):\n    cashflow = icp_clp2_leg.get_cashflow_at(i)\n    if cashflow.get_start_date() &lt;= fecha_hoy &lt;= cashflow.get_end_date():\n            index = i\n\nicp_fecha_inicio_cupon_vigente = 18_376.69\nicp_clp2_leg.get_cashflow_at(index).set_start_date_icp(icp_fecha_inicio_cupon_vigente)\n\nfwd_rates.set_rates_icp_clp_leg(fecha_hoy, icp_val, icp_clp2_leg, zz1)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, icp_clp2_leg.size()):\n    tabla.append(qcf.show(icp_clp2_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = list(qcf.get_column_names(\"IcpClpCashflow2\", \"\"))\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9.style.format(format_dict)\n</code></pre> fecha_inicial fecha_final fecha_pago nominal amortizacion amort_es_flujo flujo moneda icp_inicial icp_final valor_tasa interes spread gearing tipo_tasa 0 2019-01-10 2019-07-10 2019-07-10 38,000,000,000.00 0.00 True 0.00 CLP 10,000.00 10,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 1 2019-07-10 2021-07-12 2021-07-12 38,000,000,000.00 0.00 True 1,760,277,860.28 CLP 18,376.69 19,227.96 2.2800% 1,764,086,666.67 0.0000% 1.00 LinAct360 2 2021-07-12 2023-07-10 2023-07-10 38,000,000,000.00 0.00 True 1,260,461,341.38 CLP 19,227.96 19,865.75 1.6400% 1,260,248,888.89 0.0000% 1.00 LinAct360 3 2023-07-10 2025-07-10 2025-07-10 38,000,000,000.00 0.00 True 2,219,270,452.18 CLP 19,865.75 21,025.94 2.8800% 2,222,240,000.00 0.0000% 1.00 LinAct360 4 2025-07-10 2027-07-12 2027-07-12 38,000,000,000.00 0.00 True 2,921,878,806.15 CLP 21,025.94 22,642.66 3.7800% 2,920,680,000.00 0.0000% 1.00 LinAct360 5 2027-07-12 2029-07-10 2029-07-10 38,000,000,000.00 38,000,000,000.00 True 41,014,662,342.55 CLP 22,642.66 24,438.98 3.9200% 3,016,440,000.00 0.0000% 1.00 LinAct360 <p>Con esto, podemos calcular el valor presente.</p> <pre><code>vp_icp_clp = pv.pv(fecha_hoy, icp_clp2_leg, zz1)\nprint(\"Valor presente pata ICPCLP: {0:,.0f}\".format(vp_icp_clp))\n</code></pre> <pre><code>Valor presente pata ICPCLP: 39,062,144,488\n</code></pre> <pre><code>csh = icp_clp2_leg.get_cashflow_at(5)\n</code></pre> <pre><code>pv.pv(fecha_hoy, csh, zz1)\n</code></pre> <pre><code>31702674802.50826\n</code></pre> <p>Tambi\u00e9n en este caso es posible calcular la sensibilidad a la curva de descuento.</p> <pre><code>der = pv.get_derivatives()\ni = 0\nbp = .0001\nfor d in der:\n    print(\"Sensibilidad en {0:}: {1:0,.0f}\".format(i, d * bp))\n    i += 1\n</code></pre> <pre><code>Sensibilidad en 0: -0\nSensibilidad en 1: -0\nSensibilidad en 2: -0\nSensibilidad en 3: -0\nSensibilidad en 4: -0\nSensibilidad en 5: -0\nSensibilidad en 6: -0\nSensibilidad en 7: -0\nSensibilidad en 8: -0\nSensibilidad en 9: -0\nSensibilidad en 10: -0\nSensibilidad en 11: -0\nSensibilidad en 12: -0\nSensibilidad en 13: -0\nSensibilidad en 14: -15,407,642\nSensibilidad en 15: -7,831,157\nSensibilidad en 16: -0\nSensibilidad en 17: -0\nSensibilidad en 18: -0\n</code></pre> <p>Podemos ver la sensibilidad total:</p> <pre><code>sens_disc = [d * bp for d in der]\nprint(\"Sensibilidad de descuento: {0:,.0f} CLP\".format(sum(sens_disc)))\n</code></pre> <pre><code>Sensibilidad de descuento: -23,238,799 CLP\n</code></pre> <p>La estructura es la misma que para una pata fija, lo que indica que se debe tambi\u00e9n incluir la sensibilidad a la curva de proyecci\u00f3n.</p> <pre><code>import numpy as np\nbp = .0001\nresult = []\nfor i in range(icp_clp2_leg.size()):\n    cshflw = icp_clp2_leg.get_cashflow_at(i)\n    amt_der = cshflw.get_amount_derivatives()\n    df = zz1.get_discount_factor_at(fecha_hoy.day_diff(cshflw.get_settlement_date()))\n    amt_der = [a * bp * df for a in amt_der]\n    if len(amt_der) &gt; 0:\n        result.append(np.array(amt_der))\ntotal = result[0] * 0\n\nfor r in result:\n    total += r\n\nfor i in range(len(total)):\n    print(\"Sensibilidad en {0:}: {1:0,.0f}\".format(i, total[i]))\n\nprint(\"Sensibilidad de proyecci\u00f3n: {0:,.0f} CLP\".format(sum(total)))\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: 0\nSensibilidad en 3: 0\nSensibilidad en 4: 0\nSensibilidad en 5: 74,757\nSensibilidad en 6: 158,384\nSensibilidad en 7: 0\nSensibilidad en 8: 256,858\nSensibilidad en 9: 130,015\nSensibilidad en 10: 644,319\nSensibilidad en 11: 327,485\nSensibilidad en 12: 998,768\nSensibilidad en 13: 518,033\nSensibilidad en 14: 15,407,642\nSensibilidad en 15: 7,831,157\nSensibilidad en 16: 0\nSensibilidad en 17: 0\nSensibilidad en 18: 0\nSensibilidad de proyecci\u00f3n: 26,347,418 CLP\n</code></pre> <p>Como se espera de una pata ICPCLP (con lag de pago igual a 0 y spread igual a 0), ambas sensibilidades se cancelan.</p>"},{"location":"Ejemplos_qcfinancial_3/#se-verifica-la-sensibilidad-de-proyeccion-por-diferencias-finitas","title":"Se verifica la sensibilidad de proyecci\u00f3n por diferencias finitas:","text":"<pre><code>fwd_rates.set_rates_icp_clp_leg(fecha_hoy, icp_val, icp_clp2_leg, zz_sens_up)\nvp_icp_clp_up = pv.pv(fecha_hoy, icp_clp2_leg, zz1)\n\nfwd_rates.set_rates_icp_clp_leg(fecha_hoy, icp_val, icp_clp2_leg, zz_sens_down)\nvp_icp_clp_down = pv.pv(fecha_hoy, icp_clp2_leg, zz1)\n\nprint(\"Sensibilidad en v\u00e9rtice {0:}: {1:,.0f} CLP\".format(\n    vertice, (vp_icp_clp_up - vp_icp_clp_down) / 2))\n</code></pre> <pre><code>Sensibilidad en v\u00e9rtice 13: 518,033 CLP\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#overnightindex-leg","title":"OvernightIndex Leg","text":"<pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(10,1,2019)\nfecha_final = qcf.QCDate(10,7,2029)\nbus_adj_rule = qcf.BusyAdjRules.FOLLOW\nfix_adj_rule = qcf.BusyAdjRules.PREVIOUS\nperiodicidad_pago = qcf.Tenor('2Y')\nperiodo_irregular_pago = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 38_000_000_000.0\namort_es_flujo = True\nspread = .0\ngearing = 1.0\n\novernight_index_leg = qcf.LegFactory.build_bullet_overnight_index_leg(\n    rec_pay=rp,\n    start_date=fecha_inicio,\n    end_date=fecha_final,\n    bus_adj_rule=bus_adj_rule,\n    fix_adj_rule=fix_adj_rule,\n    settlement_periodicity=periodicidad_pago,\n    stub_period=periodo_irregular_pago,\n    settlement_calendar=calendario,\n    fixing_calendar=calendario,\n    settlement_lag=lag_pago,\n    initial_notional=nominal,\n    amort_is_cashflow=amort_es_flujo,\n    spread=spread,\n    gearing=gearing,\n    interest_rate=qcf.QCInterestRate(0.0, qcf.QCAct360(), qcf.QCLinearWf()),\n    index_name='ICPCLP',\n    eq_rate_decimal_places=2,\n    notional_currency=qcf.QCCLP(),\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, overnight_index_leg.size()):\n    tabla.append(qcf.show(overnight_index_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = list(qcf.get_column_names(\"OvernightIndexCashflow\", \"\"))\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9 # .style.format(format_dict)\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa_equivalente tipo_tasa interes flujo spread gearing 0 2019-01-10 2019-07-10 2019-01-10 2019-07-10 2019-07-10 3.800000e+10 0.000000e+00 True CLP ICPCLP 1.0 1.0 0.0 LinAct360 0.0 0.000000e+00 0.0 1.0 1 2019-07-10 2021-07-12 2019-07-10 2021-07-12 2021-07-12 3.800000e+10 0.000000e+00 True CLP ICPCLP 1.0 1.0 0.0 LinAct360 0.0 0.000000e+00 0.0 1.0 2 2021-07-12 2023-07-10 2021-07-12 2023-07-10 2023-07-10 3.800000e+10 0.000000e+00 True CLP ICPCLP 1.0 1.0 0.0 LinAct360 0.0 0.000000e+00 0.0 1.0 3 2023-07-10 2025-07-10 2023-07-10 2025-07-10 2025-07-10 3.800000e+10 0.000000e+00 True CLP ICPCLP 1.0 1.0 0.0 LinAct360 0.0 0.000000e+00 0.0 1.0 4 2025-07-10 2027-07-12 2025-07-10 2027-07-12 2027-07-12 3.800000e+10 0.000000e+00 True CLP ICPCLP 1.0 1.0 0.0 LinAct360 0.0 0.000000e+00 0.0 1.0 5 2027-07-12 2029-07-10 2027-07-12 2029-07-10 2029-07-10 3.800000e+10 3.800000e+10 True CLP ICPCLP 1.0 1.0 0.0 LinAct360 0.0 3.800000e+10 0.0 1.0 <p>Notar que al dar de alta un Leg con OvernightIndexCashflow, los valores futuros de los \u00edndeces son los default (=1.0). Por lo tanto, el primer paso para valorizar estos cashflows, es calcular los valores forward de los \u00edndices.</p> <p>Ya tenemos un objeto de tipo <code>ForwardRates</code>.</p> <p>Se calculan los \u00edndices forward.</p> <pre><code>icp_val = 18_890.34 # icp a la fecha de proceso\nfecha_hoy = qcf.QCDate(5, 3, 2020)\n\nfor i in range(icp_clp2_leg.size()):\n    cashflow = overnight_index_leg.get_cashflow_at(i)\n    if cashflow.get_start_date() &lt;= fecha_hoy &lt;= cashflow.get_end_date():\n            index = i\n\nicp_fecha_inicio_cupon_vigente = 18_376.69\novernight_index_leg.get_cashflow_at(index).set_start_date_index(icp_fecha_inicio_cupon_vigente)\n\nfwd_rates.set_rates_overnight_index_leg(fecha_hoy, icp_val, overnight_index_leg, zz1)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, overnight_index_leg.size()):\n    tabla.append(qcf.show(overnight_index_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = list(qcf.get_column_names(\"OvernightIndexCashflow\", \"\"))\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9 # .style.format(format_dict)\n</code></pre> fecha_inicial_devengo fecha_final_devengo fecha_inicial_indice fecha_final_indice fecha_pago nocional amortizacion amort_es_flujo moneda_nocional nombre_indice valor_indice_inicial valor_indice_final valor_tasa_equivalente tipo_tasa interes flujo spread gearing 0 2019-01-10 2019-07-10 2019-01-10 2019-07-10 2019-07-10 3.800000e+10 0.000000e+00 True CLP ICPCLP 1.000000 1.000000 0.00 LinAct360 0.000000e+00 0.000000e+00 0.0 1.0 1 2019-07-10 2021-07-12 2019-07-10 2021-07-12 2021-07-12 3.800000e+10 0.000000e+00 True CLP ICPCLP 18376.690000 19227.955278 0.02 LinAct360 1.547444e+09 1.547444e+09 0.0 1.0 2 2021-07-12 2023-07-10 2021-07-12 2023-07-10 2023-07-10 3.800000e+10 0.000000e+00 True CLP ICPCLP 19227.955278 19865.747233 0.02 LinAct360 1.536889e+09 1.536889e+09 0.0 1.0 3 2023-07-10 2025-07-10 2023-07-10 2025-07-10 2025-07-10 3.800000e+10 0.000000e+00 True CLP ICPCLP 19865.747233 21025.943703 0.03 LinAct360 2.314833e+09 2.314833e+09 0.0 1.0 4 2025-07-10 2027-07-12 2025-07-10 2027-07-12 2027-07-12 3.800000e+10 0.000000e+00 True CLP ICPCLP 21025.943703 22642.661052 0.04 LinAct360 3.090667e+09 3.090667e+09 0.0 1.0 5 2027-07-12 2029-07-10 2027-07-12 2029-07-10 2029-07-10 3.800000e+10 3.800000e+10 True CLP ICPCLP 22642.661052 24438.976252 0.04 LinAct360 3.078000e+09 4.107800e+10 0.0 1.0 <p>Con esto, podemos calcular el valor presente.</p> <pre><code>vp_on_index_leg = pv.pv(fecha_hoy, overnight_index_leg, zz1)\nprint(\"Valor presente pata ON Index Leg: {0:,.0f}\".format(vp_on_index_leg))\n</code></pre> <pre><code>Valor presente pata ON Index Leg: 39,062,144,488\n</code></pre> <pre><code>csh = overnight_index_leg.get_cashflow_at(5)\n</code></pre> <pre><code>pv.pv(fecha_hoy, csh, zz1)\n</code></pre> <pre><code>31702674802.50826\n</code></pre> <p>Tambi\u00e9n en este caso es posible calcular la sensibilidad a la curva de descuento.</p> <pre><code>der = pv.get_derivatives()\ni = 0\nbp = .0001\nfor d in der:\n    print(\"Sensibilidad en {0:}: {1:0,.0f}\".format(i, d * bp))\n    i += 1\n</code></pre> <pre><code>Sensibilidad en 0: -0\nSensibilidad en 1: -0\nSensibilidad en 2: -0\nSensibilidad en 3: -0\nSensibilidad en 4: -0\nSensibilidad en 5: -0\nSensibilidad en 6: -0\nSensibilidad en 7: -0\nSensibilidad en 8: -0\nSensibilidad en 9: -0\nSensibilidad en 10: -0\nSensibilidad en 11: -0\nSensibilidad en 12: -0\nSensibilidad en 13: -0\nSensibilidad en 14: -15,407,642\nSensibilidad en 15: -7,831,157\nSensibilidad en 16: -0\nSensibilidad en 17: -0\nSensibilidad en 18: -0\n</code></pre> <p>Podemos ver la sensibilidad total:</p> <pre><code>sens_disc = [d * bp for d in der]\nprint(\"Sensibilidad de descuento: {0:,.0f} CLP\".format(sum(sens_disc)))\n</code></pre> <pre><code>Sensibilidad de descuento: -23,238,799 CLP\n</code></pre> <p>La estructura es la misma que para una pata fija, lo que indica que se debe tambi\u00e9n incluir la sensibilidad a la curva de proyecci\u00f3n.</p> <pre><code>import numpy as np\nbp = .0001\nresult = []\nfor i in range(overnight_index_leg.size()):\n    cshflw = overnight_index_leg.get_cashflow_at(i)\n    amt_der = cshflw.get_amount_derivatives()\n    df = zz1.get_discount_factor_at(fecha_hoy.day_diff(cshflw.get_settlement_date()))\n    amt_der = [a * bp * df for a in amt_der]\n    if len(amt_der) &gt; 0:\n        result.append(np.array(amt_der))\ntotal = result[0] * 0\n\nfor r in result:\n    total += r\n\nfor i in range(len(total)):\n    print(\"Sensibilidad en {0:}: {1:0,.0f}\".format(i, total[i]))\n\nprint(\"Sensibilidad de proyecci\u00f3n: {0:,.0f} CLP\".format(sum(total)))\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: 0\nSensibilidad en 3: 0\nSensibilidad en 4: 0\nSensibilidad en 5: 74,757\nSensibilidad en 6: 158,384\nSensibilidad en 7: 0\nSensibilidad en 8: 256,858\nSensibilidad en 9: 130,015\nSensibilidad en 10: 644,319\nSensibilidad en 11: 327,485\nSensibilidad en 12: 998,768\nSensibilidad en 13: 518,033\nSensibilidad en 14: 15,407,642\nSensibilidad en 15: 7,831,157\nSensibilidad en 16: 0\nSensibilidad en 17: 0\nSensibilidad en 18: 0\nSensibilidad de proyecci\u00f3n: 26,347,418 CLP\n</code></pre> <p>Como se espera de una pata OvernightIndex (con lag de pago igual a 0 y spread igual a 0), ambas sensibilidades se cancelan.</p>"},{"location":"Ejemplos_qcfinancial_3/#se-verifica-la-sensibilidad-de-proyeccion-por-diferencias-finitas_1","title":"Se verifica la sensibilidad de proyecci\u00f3n por diferencias finitas:","text":"<pre><code>fwd_rates.set_rates_overnight_index_leg(fecha_hoy, icp_val, overnight_index_leg, zz_sens_up)\nvp_on_index_leg_up = pv.pv(fecha_hoy, overnight_index_leg, zz1)\n\nfwd_rates.set_rates_overnight_index_leg(fecha_hoy, icp_val, overnight_index_leg, zz_sens_down)\nvp_on_index_leg_down = pv.pv(fecha_hoy, icp_clp2_leg, zz1)\n\nprint(\"Sensibilidad en v\u00e9rtice {0:}: {1:,.0f} CLP\".format(\n    vertice, (vp_on_index_leg_up - vp_on_index_leg_down) / 2))\n</code></pre> <pre><code>Sensibilidad en v\u00e9rtice 13: 518,033 CLP\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#iborcashflow2-leg","title":"IborCashflow2 Leg","text":"<pre><code>### Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(12, 11, 2019)\nfecha_final = qcf.QCDate(12, 11, 2029)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('3M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nperiodicidad_fijacion = qcf.Tenor('3M')\nperiodo_irregular_fijacion = qcf.StubPeriod.NO\n\n# vamos a usar el mismo calendario para pago y fijaciones\nlag_de_fijacion = 2\n\n# Definici\u00f3n del \u00edndice\ncodigo = 'LIBORUSD3M'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('2d')\ntenor = qcf.Tenor('3m')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\nlibor_usd_3m = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd\n)\n# Fin \u00edndice\n\nnominal = 20_000_000.0\namort_es_flujo = True\nmoneda = usd\nspread = .0\ngearing = 1.0\n\n# Es la op 2879 en FD\nibor_leg = qcf.LegFactory.build_bullet_ibor2_leg(\n    rp, \n    fecha_inicio, \n    fecha_final, \n    bus_adj_rule, \n    periodicidad_pago,\n    periodo_irregular_pago, \n    calendario, \n    lag_pago,\n    periodicidad_fijacion, \n    periodo_irregular_fijacion,\n    calendario, \n    lag_de_fijacion, \n    libor_usd_3m,\n    nominal, \n    amort_es_flujo, \n    moneda, \n    spread, \n    gearing\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, ibor_leg.size()):\n    tabla.append(qcf.show(ibor_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha_fixing', 'fecha__pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo',\n            'moneda', 'codigo_indice', 'valor_tasa', 'spread', 'gearing', 'tipo_tasa']\ndf5 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf5.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha_fixing fecha__pago nominal amort interes amort_es_flujo flujo moneda codigo_indice valor_tasa spread gearing tipo_tasa 0 2019-11-12 2020-02-12 2019-11-08 2020-02-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 1 2020-02-12 2020-05-12 2020-02-10 2020-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 2 2020-05-12 2020-08-12 2020-05-08 2020-08-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 3 2020-08-12 2020-11-12 2020-08-10 2020-11-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 4 2020-11-12 2021-02-12 2020-11-10 2021-02-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 5 2021-02-12 2021-05-12 2021-02-10 2021-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 6 2021-05-12 2021-08-12 2021-05-10 2021-08-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 7 2021-08-12 2021-11-12 2021-08-10 2021-11-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 8 2021-11-12 2022-02-14 2021-11-10 2022-02-14 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 9 2022-02-14 2022-05-12 2022-02-10 2022-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 10 2022-05-12 2022-08-12 2022-05-10 2022-08-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 11 2022-08-12 2022-11-14 2022-08-10 2022-11-14 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 12 2022-11-14 2023-02-13 2022-11-10 2023-02-13 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 13 2023-02-13 2023-05-12 2023-02-09 2023-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 14 2023-05-12 2023-08-14 2023-05-10 2023-08-14 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 15 2023-08-14 2023-11-13 2023-08-10 2023-11-13 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 16 2023-11-13 2024-02-12 2023-11-09 2024-02-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 17 2024-02-12 2024-05-13 2024-02-08 2024-05-13 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 18 2024-05-13 2024-08-12 2024-05-09 2024-08-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 19 2024-08-12 2024-11-12 2024-08-08 2024-11-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 20 2024-11-12 2025-02-12 2024-11-08 2025-02-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 21 2025-02-12 2025-05-12 2025-02-10 2025-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 22 2025-05-12 2025-08-12 2025-05-08 2025-08-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 23 2025-08-12 2025-11-12 2025-08-08 2025-11-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 24 2025-11-12 2026-02-12 2025-11-10 2026-02-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 25 2026-02-12 2026-05-12 2026-02-10 2026-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 26 2026-05-12 2026-08-12 2026-05-08 2026-08-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 27 2026-08-12 2026-11-12 2026-08-10 2026-11-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 28 2026-11-12 2027-02-12 2026-11-10 2027-02-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 29 2027-02-12 2027-05-12 2027-02-10 2027-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 30 2027-05-12 2027-08-12 2027-05-10 2027-08-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 31 2027-08-12 2027-11-12 2027-08-10 2027-11-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 32 2027-11-12 2028-02-14 2027-11-10 2028-02-14 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 33 2028-02-14 2028-05-12 2028-02-10 2028-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 34 2028-05-12 2028-08-14 2028-05-10 2028-08-14 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 35 2028-08-14 2028-11-13 2028-08-10 2028-11-13 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 36 2028-11-13 2029-02-12 2028-11-09 2029-02-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 37 2029-02-12 2029-05-14 2029-02-08 2029-05-14 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 38 2029-05-14 2029-08-13 2029-05-10 2029-08-13 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 39 2029-08-13 2029-11-12 2029-08-09 2029-11-12 20,000,000.00 20,000,000.00 0.00 True 20,000,000.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 <pre><code>libor = 0.0190063\nfecha_hoy = qcf.QCDate(25, 2, 2020)\nibor_leg.get_cashflow_at(0).set_rate_value(libor)\nfwd_rates.set_rates_ibor_leg(fecha_hoy, ibor_leg, zz2)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, ibor_leg.size()):\n    tabla.append(qcf.show(ibor_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha_fixing', 'fecha__pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo',\n            'moneda', 'codigo_indice', 'valor_tasa', 'spread', 'gearing', 'tipo_tasa']\ndf5 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf5.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha_fixing fecha__pago nominal amort interes amort_es_flujo flujo moneda codigo_indice valor_tasa spread gearing tipo_tasa 0 2019-11-12 2020-02-12 2019-11-08 2020-02-12 20,000,000.00 0.00 97,143.31 True 97,143.31 USD LIBORUSD3M 1.9006% 0.0000% 1.00 LinAct360 1 2020-02-12 2020-05-12 2020-02-10 2020-05-12 20,000,000.00 0.00 0.00 True 0.00 USD LIBORUSD3M 0.0000% 0.0000% 1.00 LinAct360 2 2020-05-12 2020-08-12 2020-05-08 2020-08-12 20,000,000.00 0.00 87,136.92 True 87,136.92 USD LIBORUSD3M 1.7049% 0.0000% 1.00 LinAct360 3 2020-08-12 2020-11-12 2020-08-10 2020-11-12 20,000,000.00 0.00 83,357.57 True 83,357.57 USD LIBORUSD3M 1.6309% 0.0000% 1.00 LinAct360 4 2020-11-12 2021-02-12 2020-11-10 2021-02-12 20,000,000.00 0.00 79,834.14 True 79,834.14 USD LIBORUSD3M 1.5620% 0.0000% 1.00 LinAct360 5 2021-02-12 2021-05-12 2021-02-10 2021-05-12 20,000,000.00 0.00 75,388.80 True 75,388.80 USD LIBORUSD3M 1.5247% 0.0000% 1.00 LinAct360 6 2021-05-12 2021-08-12 2021-05-10 2021-08-12 20,000,000.00 0.00 75,147.35 True 75,147.35 USD LIBORUSD3M 1.4703% 0.0000% 1.00 LinAct360 7 2021-08-12 2021-11-12 2021-08-10 2021-11-12 20,000,000.00 0.00 75,919.01 True 75,919.01 USD LIBORUSD3M 1.4854% 0.0000% 1.00 LinAct360 8 2021-11-12 2022-02-14 2021-11-10 2022-02-14 20,000,000.00 0.00 76,541.33 True 76,541.33 USD LIBORUSD3M 1.4657% 0.0000% 1.00 LinAct360 9 2022-02-14 2022-05-12 2022-02-10 2022-05-12 20,000,000.00 0.00 72,657.16 True 72,657.16 USD LIBORUSD3M 1.5033% 0.0000% 1.00 LinAct360 10 2022-05-12 2022-08-12 2022-05-10 2022-08-12 20,000,000.00 0.00 76,607.00 True 76,607.00 USD LIBORUSD3M 1.4988% 0.0000% 1.00 LinAct360 11 2022-08-12 2022-11-14 2022-08-10 2022-11-14 20,000,000.00 0.00 77,567.48 True 77,567.48 USD LIBORUSD3M 1.4853% 0.0000% 1.00 LinAct360 12 2022-11-14 2023-02-13 2022-11-10 2023-02-13 20,000,000.00 0.00 74,410.06 True 74,410.06 USD LIBORUSD3M 1.4718% 0.0000% 1.00 LinAct360 13 2023-02-13 2023-05-12 2023-02-09 2023-05-12 20,000,000.00 0.00 74,928.43 True 74,928.43 USD LIBORUSD3M 1.5326% 0.0000% 1.00 LinAct360 14 2023-05-12 2023-08-14 2023-05-10 2023-08-14 20,000,000.00 0.00 80,562.98 True 80,562.98 USD LIBORUSD3M 1.5427% 0.0000% 1.00 LinAct360 15 2023-08-14 2023-11-13 2023-08-10 2023-11-13 20,000,000.00 0.00 77,966.23 True 77,966.23 USD LIBORUSD3M 1.5422% 0.0000% 1.00 LinAct360 16 2023-11-13 2024-02-12 2023-11-09 2024-02-12 20,000,000.00 0.00 77,943.52 True 77,943.52 USD LIBORUSD3M 1.5417% 0.0000% 1.00 LinAct360 17 2024-02-12 2024-05-13 2024-02-08 2024-05-13 20,000,000.00 0.00 80,765.17 True 80,765.17 USD LIBORUSD3M 1.5976% 0.0000% 1.00 LinAct360 18 2024-05-13 2024-08-12 2024-05-09 2024-08-12 20,000,000.00 0.00 81,557.64 True 81,557.64 USD LIBORUSD3M 1.6132% 0.0000% 1.00 LinAct360 19 2024-08-12 2024-11-12 2024-08-08 2024-11-12 20,000,000.00 0.00 82,792.65 True 82,792.65 USD LIBORUSD3M 1.6199% 0.0000% 1.00 LinAct360 20 2024-11-12 2025-02-12 2024-11-08 2025-02-12 20,000,000.00 0.00 83,129.55 True 83,129.55 USD LIBORUSD3M 1.6264% 0.0000% 1.00 LinAct360 21 2025-02-12 2025-05-12 2025-02-10 2025-05-12 20,000,000.00 0.00 83,469.23 True 83,469.23 USD LIBORUSD3M 1.6881% 0.0000% 1.00 LinAct360 22 2025-05-12 2025-08-12 2025-05-08 2025-08-12 20,000,000.00 0.00 87,360.07 True 87,360.07 USD LIBORUSD3M 1.7092% 0.0000% 1.00 LinAct360 23 2025-08-12 2025-11-12 2025-08-08 2025-11-12 20,000,000.00 0.00 87,967.87 True 87,967.87 USD LIBORUSD3M 1.7211% 0.0000% 1.00 LinAct360 24 2025-11-12 2026-02-12 2025-11-10 2026-02-12 20,000,000.00 0.00 88,566.05 True 88,566.05 USD LIBORUSD3M 1.7328% 0.0000% 1.00 LinAct360 25 2026-02-12 2026-05-12 2026-02-10 2026-05-12 20,000,000.00 0.00 86,231.99 True 86,231.99 USD LIBORUSD3M 1.7440% 0.0000% 1.00 LinAct360 26 2026-05-12 2026-08-12 2026-05-08 2026-08-12 20,000,000.00 0.00 89,714.97 True 89,714.97 USD LIBORUSD3M 1.7553% 0.0000% 1.00 LinAct360 27 2026-08-12 2026-11-12 2026-08-10 2026-11-12 20,000,000.00 0.00 90,284.84 True 90,284.84 USD LIBORUSD3M 1.7664% 0.0000% 1.00 LinAct360 28 2026-11-12 2027-02-12 2026-11-10 2027-02-12 20,000,000.00 0.00 90,845.26 True 90,845.26 USD LIBORUSD3M 1.7774% 0.0000% 1.00 LinAct360 29 2027-02-12 2027-05-12 2027-02-10 2027-05-12 20,000,000.00 0.00 90,645.79 True 90,645.79 USD LIBORUSD3M 1.8333% 0.0000% 1.00 LinAct360 30 2027-05-12 2027-08-12 2027-05-10 2027-08-12 20,000,000.00 0.00 94,825.45 True 94,825.45 USD LIBORUSD3M 1.8553% 0.0000% 1.00 LinAct360 31 2027-08-12 2027-11-12 2027-08-10 2027-11-12 20,000,000.00 0.00 95,521.58 True 95,521.58 USD LIBORUSD3M 1.8689% 0.0000% 1.00 LinAct360 32 2027-11-12 2028-02-14 2027-11-10 2028-02-14 20,000,000.00 0.00 98,309.76 True 98,309.76 USD LIBORUSD3M 1.8825% 0.0000% 1.00 LinAct360 33 2028-02-14 2028-05-12 2028-02-10 2028-05-12 20,000,000.00 0.00 92,673.72 True 92,673.72 USD LIBORUSD3M 1.8956% 0.0000% 1.00 LinAct360 34 2028-05-12 2028-08-14 2028-05-10 2028-08-14 20,000,000.00 0.00 99,656.47 True 99,656.47 USD LIBORUSD3M 1.9083% 0.0000% 1.00 LinAct360 35 2028-08-14 2028-11-13 2028-08-10 2028-11-13 20,000,000.00 0.00 97,119.25 True 97,119.25 USD LIBORUSD3M 1.9210% 0.0000% 1.00 LinAct360 36 2028-11-13 2029-02-12 2028-11-09 2029-02-12 20,000,000.00 0.00 97,742.18 True 97,742.18 USD LIBORUSD3M 1.9334% 0.0000% 1.00 LinAct360 37 2029-02-12 2029-05-14 2029-02-08 2029-05-14 20,000,000.00 0.00 98,347.80 True 98,347.80 USD LIBORUSD3M 1.9453% 0.0000% 1.00 LinAct360 38 2029-05-14 2029-08-13 2029-05-10 2029-08-13 20,000,000.00 0.00 98,954.09 True 98,954.09 USD LIBORUSD3M 1.9573% 0.0000% 1.00 LinAct360 39 2029-08-13 2029-11-12 2029-08-09 2029-11-12 20,000,000.00 20,000,000.00 99,543.20 True 20,099,543.20 USD LIBORUSD3M 1.9690% 0.0000% 1.00 LinAct360 <pre><code>which_cashflow = 1\nd1 = fecha_hoy.day_diff(ibor_leg.get_cashflow_at(which_cashflow).get_start_date())\nd2 = fecha_hoy.day_diff(ibor_leg.get_cashflow_at(which_cashflow).get_end_date())\nprint(\"d1: {0:,.0f}\".format(d1))\nprint(\"d2: {0:,.0f}\".format(d2))\ncrv = zz2\nw1 = 1 / crv.get_discount_factor_at(d1)\nw2 = 1 / crv.get_discount_factor_at(d2)\nprint(\"Factor forward: {0:.4%}\".format(w2 / w1))\nprint(\"Tasa forward: {0:.4%}\".format((w2 / w1 - 1) * 360 / (d2 - d1)))\nprint(\"Curve method {0:.4%}\".format(crv.get_forward_rate_with_rate(libor_usd_3m.get_rate(), d1, d2)))\n</code></pre> <pre><code>d1: -13\nd2: 77\nFactor forward: 100.4379%\nTasa forward: 1.7517%\nCurve method 1.5288%\n</code></pre> <pre><code>vp_ibor = pv.pv(fecha_hoy, ibor_leg, zz2)\nprint(\"Valor presente pata IBOR: {0:,.0f}\".format(vp_ibor))\n</code></pre> <pre><code>Valor presente pata IBOR: 19,923,921\n</code></pre> <pre><code>der = pv.get_derivatives()\ni = 0\nbp = .0001\nfor d in der:\n    print(\"Sensibilidad en {0:}: {1:0,.0f}\".format(i, d * bp))\n    i += 1\nprint(\"Sensibilidad de descuento: {0:,.0f} USD\".format(sum(der) * bp))\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: 0\nSensibilidad en 3: 0\nSensibilidad en 4: 0\nSensibilidad en 5: 0\nSensibilidad en 6: 0\nSensibilidad en 7: 0\nSensibilidad en 8: -2\nSensibilidad en 9: -2\nSensibilidad en 10: 0\nSensibilidad en 11: -3\nSensibilidad en 12: -3\nSensibilidad en 13: 0\nSensibilidad en 14: -3\nSensibilidad en 15: -10\nSensibilidad en 16: -21\nSensibilidad en 17: -47\nSensibilidad en 18: -85\nSensibilidad en 19: -114\nSensibilidad en 20: -234\nSensibilidad en 21: -1,895\nSensibilidad en 22: -13,122\nSensibilidad en 23: 0\nSensibilidad en 24: 0\nSensibilidad en 25: 0\nSensibilidad en 26: 0\nSensibilidad en 27: 0\nSensibilidad de descuento: -15,541 USD\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#se-verifica-la-sensibilidad-de-descuento-por-diferencias-finitas","title":"Se verifica la sensibilidad de descuento por diferencias finitas.","text":"<pre><code>vp_ibor_up = pv.pv(fecha_hoy, ibor_leg, zz2_sens_up)\nprint(\"Valor presente up pata IBOR: {0:,.0f}\".format(vp_ibor_up))\n\nvp_ibor_down = pv.pv(fecha_hoy, ibor_leg, zz2_sens_down)\nprint(\"Valor presente down pata IBOR: {0:,.0f}\".format(vp_ibor_down))\n\nprint(\"Sensibilidad de descuento en el v\u00e9rtice {0:}: {1:,.0f}\".format(vertice, (vp_ibor_up - vp_ibor_down) / 2))\n</code></pre> <pre><code>Valor presente up pata IBOR: 19,923,921\nValor presente down pata IBOR: 19,923,921\nSensibilidad de descuento en el v\u00e9rtice 13: 0\n</code></pre> <p>Se calcula tambi\u00e9n la sensibilidad a la curva de proyecci\u00f3n.</p> <pre><code>import numpy as np\nbp = .0001\nresult = []\n\nfor i in range(ibor_leg.size()):\n    cshflw = ibor_leg.get_cashflow_at(i)\n    df = zz2.get_discount_factor_at(fecha_hoy.day_diff(cshflw.get_settlement_date()))\n    amt_der = cshflw.get_amount_derivatives()\n    if len(amt_der) &gt; 0:\n        amt_der = [a * bp * df for a in amt_der]\n        result.append(np.array(amt_der))\n\ntotal = result[0] * 0\nfor r in result:\n    total += r\n\nfor i in range(len(total)):\n    print(\"Sensibilidad en {0:}: {1:0,.0f}\".format(i, total[i]))\n\nprint(\"Sensibilidad de proyecci\u00f3n: {0:,.0f} USD\".format(sum(total)))\n</code></pre> <pre><code>Sensibilidad en 0: 0\nSensibilidad en 1: 0\nSensibilidad en 2: 0\nSensibilidad en 3: 0\nSensibilidad en 4: 0\nSensibilidad en 5: -192\nSensibilidad en 6: -233\nSensibilidad en 7: 0\nSensibilidad en 8: 2\nSensibilidad en 9: 2\nSensibilidad en 10: 0\nSensibilidad en 11: 3\nSensibilidad en 12: 3\nSensibilidad en 13: 0\nSensibilidad en 14: 3\nSensibilidad en 15: 10\nSensibilidad en 16: 21\nSensibilidad en 17: 1\nSensibilidad en 18: 81\nSensibilidad en 19: 193\nSensibilidad en 20: 258\nSensibilidad en 21: 1,820\nSensibilidad en 22: 13,222\nSensibilidad en 23: 0\nSensibilidad en 24: 0\nSensibilidad en 25: 0\nSensibilidad en 26: 0\nSensibilidad en 27: 0\nSensibilidad de proyecci\u00f3n: 15,194 USD\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#se-verifica-la-sensibilidad-de-proyeccion-por-diferencias-finitas_2","title":"Se verifica la sensibilidad de proyecci\u00f3n por diferencias finitas.","text":"<pre><code>fwd_rates.set_rates_ibor_leg(fecha_hoy, ibor_leg, zz2_sens_up)\nvp_ibor_up = pv.pv(fecha_hoy, ibor_leg, zz2)\nprint(\"Valor presente up pata IBOR: {0:,.0f}\".format(vp_ibor_up))\n\nfwd_rates.set_rates_ibor_leg(fecha_hoy, ibor_leg, zz2_sens_down)\nvp_ibor_down = pv.pv(fecha_hoy, ibor_leg, zz2)\nprint(\"Valor presente down pata IBOR: {0:,.0f}\".format(vp_ibor_down))\n\nprint(\"Sensibilidad de proyecci\u00f3n en el v\u00e9rtice {0:}: {1:,.0f}\".format(vertice, (vp_ibor_up - vp_ibor_down) / 2))\n</code></pre> <pre><code>Valor presente up pata IBOR: 19,923,921\nValor presente down pata IBOR: 19,923,921\nSensibilidad de proyecci\u00f3n en el v\u00e9rtice 13: 0\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#icpclfcashflow-leg","title":"IcpClfCashflow Leg","text":"<pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.RECEIVE\nfecha_inicio = qcf.QCDate(31, 5, 2018)\nfecha_final = qcf.QCDate(9, 5, 2026) \nbus_adj_rule = qcf.BusyAdjRules.FOLLOW\nperiodicidad_pago = qcf.Tenor('6M')\nperiodo_irregular_pago = qcf.StubPeriod.SHORTFRONT\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 0\nnominal = 6000_00.0\namort_es_flujo = True \nspread = .0\ngearing = 1.0\n\nicp_clf_leg = qcf.LegFactory.build_bullet_icp_clf_leg(\n    rp, \n    fecha_inicio, \n    fecha_final, \n    bus_adj_rule, \n    periodicidad_pago,\n    periodo_irregular_pago, \n    calendario, \n    lag_pago,\n    nominal, \n    amort_es_flujo, \n    spread, \n    gearing\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, icp_clf_leg.size()):\n    tabla.append(qcf.show(icp_clf_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'amort_es_flujo', 'flujo',\n            'moneda', 'icp_inicial', 'icp_final', 'uf_inicial', 'uf_final',\n            'valor_tasa', 'interes', 'spread', 'gearing', 'tipo_tasa']\ndf8 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf8.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort amort_es_flujo flujo moneda icp_inicial icp_final uf_inicial uf_final valor_tasa interes spread gearing tipo_tasa 0 2018-05-31 2018-11-09 2018-11-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 1 2018-11-09 2019-05-09 2019-05-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 2 2019-05-09 2019-11-11 2019-11-11 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 3 2019-11-11 2020-05-11 2020-05-11 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 4 2020-05-11 2020-11-09 2020-11-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 5 2020-11-09 2021-05-10 2021-05-10 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 6 2021-05-10 2021-11-09 2021-11-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 7 2021-11-09 2022-05-09 2022-05-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 8 2022-05-09 2022-11-09 2022-11-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 9 2022-11-09 2023-05-09 2023-05-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 10 2023-05-09 2023-11-09 2023-11-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 11 2023-11-09 2024-05-09 2024-05-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 12 2024-05-09 2024-11-11 2024-11-11 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 13 2024-11-11 2025-05-09 2025-05-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 14 2025-05-09 2025-11-10 2025-11-10 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 15 2025-11-10 2026-05-11 2026-05-11 600,000.00 600,000.00 True 600,000.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 <pre><code>icp_hoy = 18_882.07\nuf_hoy = 28440.19\nfwd_rates.set_rates_icp_clf_leg(fecha_hoy, icp_hoy, uf_hoy, icp_clf_leg, zz1, zz1, zz3)\ncshflw = icp_clf_leg.get_cashflow_at(3)\ncshflw.set_start_date_uf(28080.26)\ncshflw.set_start_date_icp(18786.13)\n</code></pre> <pre><code>print(fecha_hoy)\n</code></pre> <pre><code>2020-02-25\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, icp_clf_leg.size()):\n    tabla.append(qcf.show(icp_clf_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'amort_es_flujo', 'flujo',\n            'moneda', 'icp_inicial', 'icp_final', 'uf_inicial', 'uf_final',\n            'valor_tasa', 'interes', 'spread', 'gearing', 'tipo_tasa']\ndf8 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf8.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort amort_es_flujo flujo moneda icp_inicial icp_final uf_inicial uf_final valor_tasa interes spread gearing tipo_tasa 0 2018-05-31 2018-11-09 2018-11-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 1 2018-11-09 2019-05-09 2019-05-09 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 2 2019-05-09 2019-11-11 2019-11-11 600,000.00 0.00 True 0.00 CLF 10,000.00 10,000.00 35,000.00 35,000.00 0.0000% 0.00 0.0000% 1.00 LinAct360 3 2019-11-11 2020-05-11 2020-05-11 600,000.00 0.00 True -7,178.78 CLF 18,786.13 18,943.62 28,080.26 28,658.55 -2.3649% -7,173.53 0.0000% 1.00 LinAct360 4 2020-05-11 2020-11-09 2020-11-09 600,000.00 0.00 True -5,300.72 CLF 18,943.62 19,056.79 28,658.55 29,086.73 -1.7492% -5,305.91 0.0000% 1.00 LinAct360 5 2020-11-09 2021-05-10 2021-05-10 600,000.00 0.00 True -3,909.59 CLF 19,056.79 19,182.42 29,086.73 29,470.52 -1.2929% -3,921.80 0.0000% 1.00 LinAct360 6 2021-05-10 2021-11-09 2021-11-09 600,000.00 0.00 True -4,842.13 CLF 19,182.42 19,306.95 29,470.52 29,903.16 -1.5847% -4,833.34 0.0000% 1.00 LinAct360 7 2021-11-09 2022-05-09 2022-05-09 600,000.00 0.00 True -5,431.38 CLF 19,306.95 19,440.27 29,903.16 30,384.70 -1.8038% -5,441.46 0.0000% 1.00 LinAct360 8 2022-05-09 2022-11-09 2022-11-09 600,000.00 0.00 True -3,700.83 CLF 19,440.27 19,606.92 30,384.70 30,835.35 -1.2040% -3,692.27 0.0000% 1.00 LinAct360 9 2022-11-09 2023-05-09 2023-05-09 600,000.00 0.00 True -2,958.63 CLF 19,606.92 19,794.39 30,835.35 31,284.45 -0.9825% -2,963.88 0.0000% 1.00 LinAct360 10 2023-05-09 2023-11-09 2023-11-09 600,000.00 0.00 True -2,109.44 CLF 19,794.39 20,019.87 31,284.45 31,752.45 -0.6866% -2,105.57 0.0000% 1.00 LinAct360 11 2023-11-09 2024-05-09 2024-05-09 600,000.00 0.00 True -1,201.71 CLF 20,019.87 20,277.70 31,752.45 32,225.93 -0.3937% -1,194.22 0.0000% 1.00 LinAct360 12 2024-05-09 2024-11-11 2024-11-11 600,000.00 0.00 True -92.82 CLF 20,277.70 20,590.52 32,225.93 32,728.13 -0.0258% -79.98 0.0000% 1.00 LinAct360 13 2024-11-11 2025-05-09 2025-05-09 600,000.00 0.00 True 488.22 CLF 20,590.52 20,916.74 32,728.13 33,219.63 0.1672% 498.81 0.0000% 1.00 LinAct360 14 2025-05-09 2025-11-10 2025-11-10 600,000.00 0.00 True 892.29 CLF 20,916.74 21,275.98 33,219.63 33,739.98 0.2874% 886.15 0.0000% 1.00 LinAct360 15 2025-11-10 2026-05-11 2026-05-11 600,000.00 600,000.00 True 601,540.00 CLF 21,275.98 21,660.54 33,739.98 34,261.88 0.5124% 1,554.28 0.0000% 1.00 LinAct360 <pre><code>vp_icp_clf = pv.pv(fecha_hoy, icp_clf_leg, zz3)\nprint(\"Valor presente en UF: {0:,.2f}\".format(vp_icp_clf))\nprint(\"Valor presente en CLP: {0:,.0f}\".format(vp_icp_clf * uf_hoy))\n</code></pre> <pre><code>Valor presente en UF: 595,431.99\nValor presente en CLP: 16,934,198,846\n</code></pre> <pre><code>print(\"Dif %: {0:.4%}\".format(12_940.56/12_943.45-1))\n</code></pre> <pre><code>Dif %: -0.0223%\n</code></pre> <pre><code>der = pv.get_derivatives()\ni = 0\nbp = .0001\nfor d in der:\n    print(\"Sensibilidad en {0:}: {1:0,.2f}\".format(i, d * bp))\n    i += 1\nprint(\"Sensibilidad de descuento: {0:,.2f} CLF\".format(sum(der) * bp))\n</code></pre> <pre><code>Sensibilidad en 0: 0.00\nSensibilidad en 1: 0.00\nSensibilidad en 2: 0.00\nSensibilidad en 3: 0.10\nSensibilidad en 4: 0.06\nSensibilidad en 5: 0.00\nSensibilidad en 6: 0.00\nSensibilidad en 7: 0.00\nSensibilidad en 8: 0.00\nSensibilidad en 9: 0.27\nSensibilidad en 10: 0.12\nSensibilidad en 11: 0.00\nSensibilidad en 12: 0.00\nSensibilidad en 13: 0.00\nSensibilidad en 14: 0.00\nSensibilidad en 15: 0.32\nSensibilidad en 16: 0.18\nSensibilidad en 17: 0.00\nSensibilidad en 18: 0.00\nSensibilidad en 19: 0.00\nSensibilidad en 20: 0.65\nSensibilidad en 21: 1.63\nSensibilidad en 22: 2.15\nSensibilidad en 23: 1.29\nSensibilidad en 24: -0.26\nSensibilidad en 25: -335.81\nSensibilidad en 26: -82.41\nSensibilidad en 27: 0.00\nSensibilidad en 28: 0.00\nSensibilidad en 29: 0.00\nSensibilidad en 30: 0.00\nSensibilidad en 31: 0.00\nSensibilidad en 32: 0.00\nSensibilidad de descuento: -411.73 CLF\n</code></pre> <pre><code>bp = .0001\nresult = []\n\nfor i in range(icp_clf_leg.size()):\n    cshflw = icp_clf_leg.get_cashflow_at(i)\n    df = zz3.get_discount_factor_at(fecha_hoy.day_diff(cshflw.date()))\n    amt_der = cshflw.get_amount_ufclf_derivatives()\n    if len(amt_der) &gt; 0:\n        amt_der = [a * bp * df for a in amt_der]\n        result.append(np.array(amt_der))\n\ntotal = result[0] * 0\nfor r in result:\n    total += r\n\nfor i in range(len(total)):\n    print(\"Sensibilidad en {0:}: {1:0,.2f}\".format(i, total[i]))\n</code></pre> <pre><code>Sensibilidad en 0: 0.00\nSensibilidad en 1: 0.00\nSensibilidad en 2: 0.00\nSensibilidad en 3: -0.10\nSensibilidad en 4: -0.06\nSensibilidad en 5: 0.00\nSensibilidad en 6: 0.00\nSensibilidad en 7: 0.00\nSensibilidad en 8: 0.00\nSensibilidad en 9: -0.27\nSensibilidad en 10: -0.12\nSensibilidad en 11: 0.00\nSensibilidad en 12: 0.00\nSensibilidad en 13: 0.00\nSensibilidad en 14: 0.00\nSensibilidad en 15: -0.32\nSensibilidad en 16: -0.18\nSensibilidad en 17: 0.00\nSensibilidad en 18: 0.00\nSensibilidad en 19: 0.00\nSensibilidad en 20: -0.65\nSensibilidad en 21: -1.63\nSensibilidad en 22: -2.15\nSensibilidad en 23: -1.29\nSensibilidad en 24: 0.26\nSensibilidad en 25: 335.81\nSensibilidad en 26: 82.41\nSensibilidad en 27: 0.00\nSensibilidad en 28: 0.00\nSensibilidad en 29: 0.00\nSensibilidad en 30: 0.00\nSensibilidad en 31: 0.00\nSensibilidad en 32: 0.00\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#compoundedovernightrate-leg","title":"CompoundedOvernightRate Leg","text":"<pre><code># Se da de alta los par\u00e1metros requeridos\nrp = qcf.RecPay.PAY\nfecha_inicio = qcf.QCDate(17, 7, 2023)\nfecha_final = qcf.QCDate(17, 7, 2027)\nbus_adj_rule = qcf.BusyAdjRules.MODFOLLOW\nperiodicidad_pago = qcf.Tenor('12M')\nperiodo_irregular_pago = qcf.StubPeriod.NO\ncalendario = qcf.BusinessCalendar(fecha_inicio, 20)\nlag_pago = 2\n\n######################################################################\n# Definici\u00f3n del \u00edndice\n\ncodigo = 'OISTEST'\nlin_act360 = qcf.QCInterestRate(.0, qcf.QCAct360(), qcf.QCLinearWf())\nfixing_lag = qcf.Tenor('0d')\ntenor = qcf.Tenor('1d')\nfixing_calendar = calendario\nsettlement_calendar = calendario\nusd = qcf.QCUSD()\noistest = qcf.InterestRateIndex(\n    codigo,\n    lin_act360,\n    fixing_lag,\n    tenor,\n    fixing_calendar,\n    settlement_calendar,\n    usd)\n\n# Fin \u00edndice\n######################################################################\n\nnominal = 5_500_000.0\namort_es_flujo = True\nmoneda = usd\nspread = .0\ngearing = 1.0\n\ncor_leg = qcf.LegFactory.build_bullet_compounded_overnight_rate_leg(\n    rp,\n    fecha_inicio,\n    fecha_final,\n    bus_adj_rule,\n    periodicidad_pago,\n    periodo_irregular_pago,\n    calendario,\n    lag_pago,\n    calendario,\n    oistest,\n    nominal,\n    amort_es_flujo,\n    usd,\n    spread,\n    gearing,\n    True,\n    10,\n    0,\n    0\n)\n</code></pre> <pre><code>ts = qcf.time_series()\nts[qcf.QCDate(17, 7, 2023)] = .01\nts[qcf.QCDate(18, 7, 2023)] = .02\nts[qcf.QCDate(19, 7, 2023)] = .03\nts[qcf.QCDate(20, 7, 2023)] = .04\nts[qcf.QCDate(21, 7, 2023)] = .04\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#valor-presente","title":"Valor Presente","text":"<pre><code>fwd_rates.set_rates_compounded_overnight_leg(\n    fecha_inicio,\n    cor_leg,\n    zz1,\n    ts\n)\n</code></pre> <pre><code># Se define un list donde almacenar los resultados de la funci\u00f3n show\ntabla = []\nfor i in range(0, cor_leg.size()):\n    tabla.append(qcf.show(cor_leg.get_cashflow_at(i)))\n\n# Se utiliza tabla para inicializar el Dataframe\ncolumnas = ['fecha_inicial', 'fecha__final', 'fecha__pago', 'nominal', 'amort', 'interes', 'amort_es_flujo', 'flujo',\n            'moneda', 'indice', 'valor_tasa', 'spread', 'gearing', 'tipo_tasa']\ndf9 = pd.DataFrame(tabla, columns=columnas)\n\n# Se despliega la data en este formato\ndf9.style.format(format_dict)\n</code></pre> fecha_inicial fecha__final fecha__pago nominal amort interes amort_es_flujo flujo moneda indice valor_tasa spread gearing tipo_tasa 0 2023-07-17 2024-07-17 2024-07-19 -5,500,000.00 0.00 -0.00 True -72,677.25 USD OISTEST 1.2997% 0.0000% 1.00 LinAct360 1 2024-07-17 2025-07-17 2025-07-21 -5,500,000.00 0.00 -0.00 True -71,041.19 USD OISTEST 1.2740% 0.0000% 1.00 LinAct360 2 2025-07-17 2026-07-17 2026-07-21 -5,500,000.00 0.00 -0.00 True -94,449.59 USD OISTEST 1.6937% 0.0000% 1.00 LinAct360 3 2026-07-17 2027-07-19 2027-07-21 -5,500,000.00 -5,500,000.00 -0.00 True -5,626,628.96 USD OISTEST 2.2584% 0.0000% 1.00 LinAct360 <pre><code>print(f'{pv.pv(fecha_inicio, cor_leg, zz1):,.0f}')\n</code></pre> <pre><code>-5,499,256\n</code></pre> <pre><code>pres_value = 0.0\nfor i in range(0, cor_leg.size()):\n    cshflw = cor_leg.get_cashflow_at(i)\n    print(f'{cshflw.amount():,.2f}, {cshflw.get_amortization()}')\n    temp = pv.pv(fecha_inicio, cshflw, zz1)\n    # print(f'{temp:,.0f}')\n    pres_value += temp\nprint(f'{pres_value:,.0f}')\n</code></pre> <pre><code>-72,677.25, 0.0\n-71,041.19, 0.0\n-94,449.59, 0.0\n-5,626,628.96, -5500000.0\n-5,499,256\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#sensibilidad","title":"Sensibilidad","text":"<pre><code>pips = .0001 # 1 punto b\u00e1sico\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#curva-de-proyeccion","title":"Curva de Proyecci\u00f3n","text":"<p>Estas derivadas se deben obtener inmediatamente despu\u00e9s de calcular el valor presente.</p> <pre><code>proj_sens_by_cashflow = np.array([np.array(\n    np.array(cor_leg.get_cashflow_at(i).get_amount_derivatives()) *\n    zz1.get_discount_factor_at(fecha_inicio.day_diff(cor_leg.get_cashflow_at(i).get_settlement_date())) * pips)\n                             for i in range(cor_leg.size())])\nproj_sens = np.sum(proj_sens_by_cashflow, axis=0)\n</code></pre>"},{"location":"Ejemplos_qcfinancial_3/#curva-de-descuento","title":"Curva de Descuento","text":"<pre><code>disc_der = np.array(pv.get_derivatives()) * pips\n</code></pre> <pre><code>disc_der\n</code></pre> <pre><code>array([   0.       ,    0.       ,    0.       ,    0.       ,\n          0.       ,    0.       ,    0.       ,    0.       ,\n          0.       , 2007.0400924,    0.       ,    0.       ,\n          0.       ,    0.       ,    0.       ,    0.       ,\n          0.       ,    0.       ,    0.       ])\n</code></pre>"}]}